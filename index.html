<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta name="googlebot" content="noindex, nofollow">
    <title>Injection Tracker</title>

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Injection Tracker">
    <meta name="description" content="Comprehensive injection tracker with vial management and weight tracking">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Crect width='32' height='32' fill='%231a1a1a'/%3E%3Ctext x='50%25' y='50%25' font-family='sans-serif' font-size='16' fill='white' text-anchor='middle' dominant-baseline='central'%3ESR%3C/text%3E%3C/svg%3E">

    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- Confetti for celebrations -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <!-- Firebase Configuration -->
    <script>
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyDkdbPPZ2pySDOWBhAsSWzkfyYWvR0jlO8",
            authDomain: "reta-tracker.firebaseapp.com",
            projectId: "reta-tracker",
            storageBucket: "reta-tracker.firebasestorage.app",
            messagingSenderId: "273148192362",
            appId: "1:273148192362:web:c3011ac8cf76a3611e0c13"
        };
        firebase.initializeApp(firebaseConfig);
    </script>

    <!-- Test mode detection BEFORE loading auth-manager -->
    <script>
        // Set flag IMMEDIATELY if in test mode on localhost, before any modules load
        const urlParams = new URLSearchParams(window.location.search);
        const isTestMode = urlParams.get('test') === 'true';
        const isLocalhost = window.location.hostname === 'localhost' ||
                            window.location.hostname === '127.0.0.1';

        if (isTestMode && isLocalhost) {
            console.log('[EARLY INIT] Test mode detected on localhost - setting SKIP_AUTH_INIT flag');
            window.SKIP_AUTH_INIT = true;
        } else if (isTestMode && !isLocalhost) {
            console.warn('[EARLY INIT] Test mode parameter detected on production - IGNORING for security');
        }
    </script>

    <!-- Cloud Integration Modules -->
    <script src="js/auth-manager.js"></script>
    <script src="js/api-client.js"></script>
    <script src="js/sync-queue.js"></script>
    <script src="js/cloud-storage.js"></script>

    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: #0a0a0a;
            --secondary-bg: #1a1a1a;
            --card-bg: #2a2a2a;
            --border-color: #333333;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #888888;
            --accent-color: #007AFF;
            --success-color: #34C759;
            --warning-color: #FF9500;
            --danger-color: #FF3B30;
            --border-radius: 12px;
            --border-radius-sm: 8px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
            padding-bottom: 80px;
            line-height: 1.5;
        }

        /* Header Styles */
        #app-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
            height: 60px;
            backdrop-filter: blur(10px);
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-md);
            height: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        .menu-btn, .add-shot-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 18px;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .add-shot-btn {
            background-color: var(--accent-color);
            color: white;
            font-weight: 600;
            font-size: 14px;
            padding: var(--spacing-sm) var(--spacing-md);
        }

        .menu-btn:hover, .add-shot-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .add-shot-btn:hover {
            background-color: #0056b3;
        }

        .build-timestamp {
            font-size: 11px;
            color: var(--text-muted);
            text-align: center;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
        }

        .date-display {
            font-weight: 600;
            font-size: 16px;
            color: var(--text-primary);
        }

        /* Phase 1B: Sync Status Indicator */
        .sync-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 16px;
            background-color: var(--card-bg);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .sync-status:hover {
            background-color: var(--border-color);
        }

        .sync-status.synced {
            background-color: rgba(52, 199, 89, 0.15);
        }

        .sync-status.syncing {
            background-color: rgba(255, 149, 0, 0.15);
        }

        .sync-status.pending {
            background-color: rgba(255, 204, 0, 0.15);
        }

        .sync-status.error {
            background-color: rgba(255, 59, 48, 0.15);
        }

        .sync-status.offline {
            background-color: rgba(136, 136, 136, 0.15);
        }

        .sync-icon {
            font-size: 14px;
            display: inline-block;
            transition: transform 0.3s;
        }

        .sync-status.syncing .sync-icon {
            animation: spin 1s linear infinite;
        }

        .sync-text {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .sync-status.synced .sync-text {
            color: var(--success-color);
        }

        .sync-status.syncing .sync-text {
            color: var(--warning-color);
        }

        .sync-status.pending .sync-text {
            color: var(--warning-color);
        }

        .sync-status.error .sync-text {
            color: var(--danger-color);
        }

        .sync-status.offline .sync-text {
            color: var(--text-muted);
        }

        .sync-badge {
            display: none;
            min-width: 18px;
            height: 18px;
            padding: 0 4px;
            background-color: var(--danger-color);
            color: white;
            font-size: 10px;
            font-weight: 700;
            border-radius: 9px;
            line-height: 18px;
            text-align: center;
        }

        /* App Switcher - Floating above bottom nav */
        .app-switcher-container {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 99;
            pointer-events: none;
        }

        .app-switcher {
            display: flex;
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 3px;
            gap: 3px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: all;
        }

        .app-switcher-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 600;
            padding: 6px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .app-switcher-btn.active {
            background-color: var(--accent-color);
            color: white;
        }

        .app-switcher-btn:hover:not(.active) {
            background-color: rgba(255, 255, 255, 0.05);
        }

        @media (max-width: 480px) {
            .app-switcher-btn {
                font-size: 12px;
                padding: 6px 12px;
            }
        }

        .sync-badge:not(:empty) {
            display: inline-block;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Sync Queue Modal */
        .sync-queue-modal {
            display: none;
            position: fixed;
            top: 60px;
            right: 10px;
            width: 350px;
            max-height: 500px;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            overflow: hidden;
            flex-direction: column;
        }

        .sync-queue-modal.open {
            display: flex;
        }

        .sync-queue-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sync-queue-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
        }

        .sync-queue-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sync-queue-body {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
        }

        .sync-queue-empty {
            text-align: center;
            padding: var(--spacing-xl);
            color: var(--text-muted);
        }

        .sync-queue-item {
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            background-color: var(--card-bg);
            border-radius: var(--border-radius-sm);
            border-left: 3px solid var(--border-color);
        }

        .sync-queue-item.pending {
            border-left-color: var(--warning-color);
        }

        .sync-queue-item.completed {
            border-left-color: var(--success-color);
            opacity: 0.6;
        }

        .sync-queue-item.failed {
            border-left-color: var(--danger-color);
        }

        .sync-queue-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-xs);
        }

        .sync-queue-item-type {
            font-weight: 600;
            font-size: 14px;
        }

        .sync-queue-item-status {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
        }

        .sync-queue-item-status.pending {
            background-color: rgba(255, 149, 0, 0.2);
            color: var(--warning-color);
        }

        .sync-queue-item-status.completed {
            background-color: rgba(52, 199, 89, 0.2);
            color: var(--success-color);
        }

        .sync-queue-item-status.failed {
            background-color: rgba(255, 59, 48, 0.2);
            color: var(--danger-color);
        }

        .sync-queue-item-details {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-xs);
        }

        .sync-queue-item-error {
            font-size: 12px;
            color: var(--danger-color);
            margin-top: var(--spacing-xs);
        }

        .sync-queue-item-actions {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        .sync-queue-item-retry {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: var(--border-radius-sm);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .sync-queue-footer {
            padding: var(--spacing-md);
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: var(--spacing-sm);
        }

        .sync-queue-footer button {
            flex: 1;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            border: none;
            font-weight: 600;
            cursor: pointer;
        }

        .sync-queue-clear-completed {
            background-color: var(--card-bg);
            color: var(--text-primary);
        }

        .sync-queue-clear-failed {
            background-color: var(--danger-color);
            color: white;
        }

        /* Phase 3: Validation Status Indicators */
        .validation-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            margin-left: 8px;
            vertical-align: middle;
        }

        .validation-icon {
            font-size: 16px;
            line-height: 1;
        }

        .validation-success .validation-icon {
            color: var(--success-color);
        }

        .validation-warning .validation-icon {
            color: var(--warning-color);
        }

        .validation-error .validation-icon {
            color: var(--danger-color);
        }

        /* Validation tooltip */
        .validation-tooltip {
            position: relative;
            cursor: help;
        }

        .validation-tooltip .tooltip-content {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .validation-tooltip:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        .validation-tooltip .tooltip-content::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }

        /* Stat card validation enhancement */
        .stat-card .stat-value-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .stat-card.has-validation-issue {
            border-left: 3px solid var(--warning-color);
        }

        .stat-card.has-validation-error {
            border-left: 3px solid var(--danger-color);
        }

        /* Validation summary in sync status modal */
        .validation-summary {
            padding: 12px;
            background-color: rgba(255, 204, 0, 0.1);
            border-radius: 8px;
            margin-bottom: 16px;
            display: none;
        }

        .validation-summary.show {
            display: block;
        }

        .validation-summary-title {
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--warning-color);
        }

        .validation-summary-list {
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .validation-summary-list li {
            margin-left: 20px;
            margin-bottom: 4px;
        }

        /* Main Content */
        #main-content {
            margin-top: 60px;
            min-height: calc(100vh - 140px);
        }

        .container {
            padding: var(--spacing-lg) var(--spacing-md);
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Responsive design */
        @media (min-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .results-stats {
                grid-template-columns: repeat(4, 1fr);
            }

            .inventory-stats {
                grid-template-columns: repeat(4, 1fr);
            }

            .chart-container, .supply-forecast-container {
                padding: var(--spacing-xl);
            }

            .chart-container canvas {
                max-height: 600px;
            }

            .shot-item, .vial-item {
                padding: var(--spacing-lg);
            }

            .form-container {
                max-width: 600px;
                margin: 0 auto;
            }

            .countdown-container {
                max-width: 600px;
                margin: 0 auto var(--spacing-lg);
            }
        }

        /* Tablet specific */
        @media (min-width: 768px) and (max-width: 1024px) {
            .container {
                max-width: 90%;
            }
        }

        /* Large desktop */
        @media (min-width: 1200px) {
            .tab-content {
                max-width: 1000px;
                margin: 0 auto;
            }
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: calc(100vh - 140px);
            font-size: 18px;
            color: var(--text-secondary);
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
        }

        .stat-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            text-align: center;
            transition: background-color 0.2s;
            min-width: 0; /* Allow cards to shrink */
        }

        .stat-card:hover {
            background-color: #353535;
        }

        .stat-value {
            font-size: clamp(20px, 4vw, 24px); /* Fluid typography */
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-muted);
            font-weight: 500;
        }

        /* Chart Container */
        .chart-container, .supply-forecast-container {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .chart-container h3, .supply-forecast-container h3 {
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
        }

        .chart-container canvas {
            max-height: 450px;
            min-height: 300px;
            width: 100% !important;
            height: 400px !important;
        }

        .chart-section {
            margin-bottom: var(--spacing-xl);
        }

        .chart-section-title {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
            padding-left: var(--spacing-md);
        }

        .supply-forecast {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .forecast-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-color);
        }

        .forecast-row:last-child {
            border-bottom: none;
        }

        .forecast-label {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .forecast-value {
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
        }

        .forecast-input-group {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .forecast-input {
            width: 60px;
            padding: var(--spacing-xs);
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            font-size: 16px;
            font-weight: 600;
            text-align: center;
        }

        .forecast-unit {
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Countdown Container */
        .countdown-container {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            text-align: center;
        }

        .countdown-container h3 {
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
        }

        .countdown-circle {
            position: relative;
            display: inline-block;
        }

        .countdown-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .next-shot-day {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-color);
            line-height: 1;
        }

        .next-shot-date {
            font-size: 32px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 4px 0;
        }

        .next-shot-time {
            font-size: 18px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .countdown-progress {
            width: 200px;
            height: 200px;
        }

        .countdown-progress circle {
            transition: stroke-dashoffset 1s ease;
        }

        /* Buttons */
        .btn-primary, .btn-secondary {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md) var(--spacing-lg);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: var(--spacing-sm);
        }

        .btn-secondary {
            background-color: var(--card-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-primary:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        .btn-secondary:hover {
            background-color: #353535;
        }

        /* Shots List */
        .shots-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
            flex-wrap: wrap;
            gap: var(--spacing-sm);
        }

        .shots-header h2 {
            font-size: 24px;
            font-weight: 700;
        }

        .shots-header-actions {
            display: flex;
            gap: var(--spacing-sm);
        }

        .skip-week-btn {
            background-color: var(--card-bg);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .skip-week-btn:hover {
            background-color: #333;
            color: var(--text-primary);
        }

        .shots-list, .weights-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .shot-item, .weight-item {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
            position: relative;
        }

        .shot-item:hover, .weight-item:hover {
            background-color: #353535;
        }

        .shot-content, .weight-content {
            flex: 1;
        }

        .shot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .shot-dose {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-color);
        }

        .shot-date {
            font-size: 14px;
            color: var(--text-muted);
        }

        .shot-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Skipped Shot Styling */
        .shot-item.skipped {
            background-color: rgba(42, 42, 42, 0.5);
            border-color: rgba(51, 51, 51, 0.5);
            opacity: 0.7;
        }

        .shot-item.skipped:hover {
            background-color: rgba(53, 53, 53, 0.6);
        }

        .shot-item.skipped .shot-dose {
            color: var(--text-muted);
            text-decoration: line-through;
        }

        .shot-item.skipped .skipped-badge {
            display: inline-block;
            background-color: rgba(136, 136, 136, 0.2);
            color: var(--text-muted);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }

        /* Results Header */
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .results-header h2 {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }

        .add-shot-btn-results {
            background-color: transparent;
            color: var(--accent-color);
            border: none;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            padding: 8px 0;
        }

        .add-shot-btn-results:hover {
            opacity: 0.7;
        }

        /* Time Period Segmented Control */
        .time-period-control {
            display: flex;
            background-color: #3a3a3a;
            border-radius: 10px;
            padding: 2px;
            margin-bottom: 24px;
        }

        .period-btn {
            flex: 1;
            background-color: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .period-btn.active {
            background-color: #505050;
            color: var(--text-primary);
        }

        .period-btn:hover:not(.active) {
            color: var(--text-primary);
        }

        /* Weight Change Section */
        .weight-change-section {
            margin-bottom: 24px;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title h3 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .section-icon {
            width: 24px;
            height: 24px;
            color: var(--text-secondary);
        }

        .date-range {
            font-size: 14px;
            color: var(--text-muted);
        }

        /* Results Stats Grid (2x3) */
        .results-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        .result-card {
            background-color: #3a3a3a;
            border: 1px solid #4a4a4a;
            border-radius: 12px;
            padding: 16px;
        }

        .result-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .metric-icon {
            width: 16px;
            height: 16px;
            stroke-width: 2.5;
        }

        .result-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Old results-stats for backward compatibility */
        .results-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
        }

        /* Inventory */
        .inventory-header {
            margin-bottom: var(--spacing-lg);
        }

        .vials-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
        }

        .vial-item {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
            position: relative;
        }

        .vial-content {
            flex: 1;
        }

        .vial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .vial-status {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .vial-status.active {
            background-color: var(--success-color);
            color: white;
        }

        .vial-status.expired {
            background-color: var(--danger-color);
            color: white;
        }

        .vial-status.expiring {
            background-color: var(--warning-color);
            color: white;
        }

        .vial-status.empty {
            background-color: var(--text-muted);
            color: white;
        }

        .vial-status.dry_stock {
            background-color: var(--warning-color);
            color: var(--bg-color);
        }

        .vial-item.dry_stock {
            border-left: 4px solid var(--warning-color);
        }

        /* Delete Button Styles */
        .item-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .edit-btn {
            background-color: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            border-radius: var(--border-radius-sm);
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .edit-btn:hover {
            background-color: var(--primary-color);
            color: white;
            opacity: 1;
            transform: scale(1.05);
        }

        .edit-btn:active {
            transform: scale(0.95);
        }

        .edit-btn svg {
            width: 20px;
            height: 20px;
        }

        .delete-btn {
            background-color: transparent;
            border: 2px solid var(--danger-color);
            color: var(--danger-color);
            border-radius: var(--border-radius-sm);
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .delete-btn:hover {
            background-color: var(--danger-color);
            color: white;
            opacity: 1;
            transform: scale(1.05);
        }

        .delete-btn:active {
            transform: scale(0.95);
        }

        .delete-btn svg {
            width: 20px;
            height: 20px;
        }

        .edit-btn {
            background-color: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            border-radius: var(--border-radius-sm);
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            margin-right: 8px;
        }

        .edit-btn:hover {
            background-color: var(--primary-color);
            color: white;
            opacity: 1;
            transform: scale(1.05);
        }

        .edit-btn:active {
            transform: scale(0.95);
        }

        .edit-btn svg {
            width: 20px;
            height: 20px;
        }

        .vial-info {
            flex: 1;
        }

        .vial-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .vial-subtitle {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 2px;
        }

        .vial-details {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .vial-detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .vial-detail-row span:first-child {
            color: var(--text-muted);
            font-weight: 500;
        }

        .vial-detail-row span:last-child {
            color: var(--text-secondary);
            font-weight: 600;
        }

        .inventory-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
        }


        .inventory-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            text-align: center;
        }

        .inventory-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--warning-color);
            margin-bottom: var(--spacing-xs);
        }

        .inventory-label {
            font-size: 14px;
            color: var(--text-muted);
        }

        /* Settings */
        .settings-section {
            margin-bottom: var(--spacing-xl);
        }

        .settings-section h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
        }

        .settings-section label {
            display: block;
            margin-bottom: var(--spacing-md);
            color: var(--text-secondary);
        }

        .settings-section select,
        .settings-section input[type="number"],
        .settings-section input[type="text"] {
            width: 100%;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            color: var(--text-primary);
            font-size: 16px;
            margin-top: var(--spacing-sm);
        }

        .settings-section input[type="checkbox"] {
            width: auto;
            margin-left: var(--spacing-sm);
            transform: scale(1.2);
        }

        .btn-secondary.connected {
            background-color: var(--success-color);
            color: white;
        }

        .setting-input-wrapper {
            position: relative;
        }

        .save-indicator {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%) scale(0.8);
            font-size: 13px;
            font-weight: 600;
            color: #34C759;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            white-space: nowrap;
        }

        .save-indicator.show {
            opacity: 1;
            transform: translateY(-50%) scale(1);
        }

        @keyframes saveTextPulse {
            0%, 100% { opacity: 1; transform: translateY(-50%) scale(1); }
            50% { opacity: 0.7; transform: translateY(-50%) scale(0.95); }
        }

        .save-indicator.show {
            animation: saveTextPulse 0.6s ease-in-out;
        }

        .sync-status {
            margin-top: var(--spacing-md);
            padding: var(--spacing-md);
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .modal-content {
            padding: var(--spacing-lg);
        }

        .modal-content p,
        .modal-content li {
            color: var(--text-secondary);
            margin-bottom: var(--spacing-sm);
        }

        .modal-content a {
            color: var(--accent-color);
            text-decoration: none;
        }

        .modal-content a:hover {
            text-decoration: underline;
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--secondary-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: var(--spacing-sm) 0;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .nav-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            transition: color 0.2s;
            min-width: 60px;
        }

        .nav-btn.active {
            color: var(--accent-color);
        }

        .nav-btn:hover {
            color: var(--text-primary);
        }

        .nav-btn.active:hover {
            color: var(--accent-color);
        }

        .nav-icon {
            width: 24px;
            height: 24px;
            margin-bottom: var(--spacing-xs);
            stroke: currentColor;
        }

        .nav-btn.active .nav-icon {
            stroke: var(--accent-color);
        }

        .nav-label {
            font-size: 12px;
            font-weight: 500;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-xl);
            margin: var(--spacing-md);
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Migration Modal Styles */
        #migration-modal .modal-content {
            max-width: 500px;
        }

        .migration-summary {
            background: var(--card-bg);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-lg) 0;
        }

        .migration-summary h3 {
            margin-bottom: var(--spacing-sm);
        }

        .migration-summary ul {
            list-style: none;
            margin: var(--spacing-sm) 0;
        }

        .migration-summary li {
            padding: var(--spacing-xs) 0;
        }

        .migration-actions {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--card-bg);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: var(--spacing-md);
        }

        .progress-fill {
            height: 100%;
            background: var(--success-color);
            transition: width 0.3s ease;
            width: 0%;
        }

        .migration-success,
        .migration-error {
            text-align: center;
            padding: var(--spacing-lg);
        }

        .migration-stats {
            background: var(--card-bg);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
        }

        .migration-stats p {
            padding: var(--spacing-xs) 0;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
        }

        .modal-title {
            font-size: 20px;
            font-weight: 700;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
            padding: var(--spacing-xs);
        }

        /* Form Styles */
        .form-group {
            margin-bottom: var(--spacing-lg);
        }

        .form-group label {
            display: block;
            margin-bottom: var(--spacing-sm);
            color: var(--text-secondary);
            font-weight: 500;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            color: var(--text-primary);
            font-size: 16px;
            transition: border-color 0.2s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Enhanced Responsive Design */

        /* Mobile First - Small phones (320px - 480px) */
        @media (max-width: 480px) {
            :root {
                --spacing-sm: 8px;
                --spacing-md: 12px;
                --spacing-lg: 16px;
                --spacing-xl: 20px;
            }

            body {
                font-size: 14px;
            }

            .container {
                padding: var(--spacing-md) var(--spacing-sm);
            }

            .stats-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-sm);
            }

            .header-content {
                padding: 0 var(--spacing-sm);
                flex-wrap: wrap;
                gap: var(--spacing-sm);
            }

            header h1 {
                font-size: 20px;
            }

            .tab-nav {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
            }

            .tab-nav::-webkit-scrollbar {
                display: none;
            }

            .tab-button {
                min-width: 80px;
                padding: 10px 12px;
                font-size: 13px;
                white-space: nowrap;
            }

            .shot-details {
                grid-template-columns: 1fr;
            }

            .results-stats,
            .inventory-stats {
                grid-template-columns: 1fr;
            }

            .results-stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .result-card {
                padding: 12px;
            }

            .result-value {
                font-size: 20px;
            }

            .period-btn {
                font-size: 12px;
                padding: 6px 12px;
            }

            .section-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .modal-content {
                margin: var(--spacing-sm);
                max-width: calc(100% - 32px);
                padding: var(--spacing-lg);
            }

            .btn-primary,
            .btn-secondary {
                padding: 12px 16px;
                font-size: 14px;
                min-height: 44px; /* Touch-friendly */
            }

            input,
            select,
            textarea {
                min-height: 44px; /* Touch-friendly */
                font-size: 16px; /* Prevent iOS zoom */
            }

            .notification-container {
                right: 10px;
                left: 10px;
                max-width: calc(100% - 20px);
            }

            .notification {
                min-width: unset;
                width: 100%;
            }

            .chart-container canvas {
                max-height: 400px !important;
                min-height: 350px !important;
            }

            .chart-container,
            .supply-forecast-container {
                padding: var(--spacing-md) 8px;
                margin-left: -4px;
                margin-right: -4px;
            }

            .stat-label {
                font-size: 12px;
            }

            .card,
            .vial-card,
            .result-card {
                padding: var(--spacing-md);
            }
        }

        /* Tablets and small laptops (481px - 768px) */
        @media (min-width: 481px) and (max-width: 768px) {
            .container {
                padding: var(--spacing-lg) var(--spacing-md);
                max-width: 95%;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .shot-details {
                grid-template-columns: repeat(2, 1fr);
            }

            .results-stats,
            .inventory-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-content {
                max-width: 90%;
            }

            .tab-button {
                min-width: 90px;
            }
        }

        /* Medium devices (769px - 1024px) */
        @media (min-width: 769px) and (max-width: 1024px) {
            .container {
                max-width: 90%;
            }

            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .tab-button {
                min-width: 100px;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .btn-primary,
            .btn-secondary,
            .tab-button,
            button {
                min-height: 44px;
                min-width: 44px;
            }

            .modal-close {
                min-width: 44px;
                min-height: 44px;
                font-size: 24px;
            }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .modal-content {
                max-height: 90vh;
                overflow-y: auto;
            }

            header {
                padding: var(--spacing-sm) 0;
            }
        }

        /* Print styles */
        @media print {
            header,
            .tab-nav,
            .modal,
            .notification-container,
            #undo-button {
                display: none !important;
            }

            .tab-content {
                display: block !important;
            }
        }

        /* Loading Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 2s infinite;
        }

        /* Notification System */
        #notification-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .notification {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 16px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: slideInRight 0.3s ease-out;
            min-width: 300px;
        }

        .notification.success {
            border-left: 4px solid var(--success-color);
        }

        .notification.error {
            border-left: 4px solid var(--danger-color);
        }

        .notification.warning {
            border-left: 4px solid var(--warning-color);
        }

        .notification.info {
            border-left: 4px solid var(--accent-color);
        }

        .notification.saving {
            border-left: 4px solid var(--accent-color);
        }

        .notification-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .notification-content {
            flex: 1;
        }

        .notification-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        .notification-message {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .notification-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-close:hover {
            color: var(--text-primary);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification.hiding {
            animation: slideOutRight 0.3s ease-in forwards;
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Undo Button */
        #undo-button {
            position: fixed;
            bottom: 100px;
            right: 20px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 9999;
            display: none;
        }

        #undo-button:hover {
            background-color: #0066CC;
        }

        #undo-button.show {
            display: block;
            animation: slideInUp 0.3s ease-out;
        }

        @keyframes slideInUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Save Indicator Animations */
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translateX(-50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }
        }

        @keyframes fadeOutScale {
            from {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }
            to {
                opacity: 0;
                transform: translateX(-50%) scale(0.8);
            }
        }

        /* Utility Classes */
        .text-center { text-align: center; }
        .text-left { text-align: left; }
        .text-right { text-align: right; }
        .mb-0 { margin-bottom: 0; }
        .mb-sm { margin-bottom: var(--spacing-sm); }
        .mb-md { margin-bottom: var(--spacing-md); }
        .mb-lg { margin-bottom: var(--spacing-lg); }
        .hidden { display: none !important; }
        .flex { display: flex; }
        .flex-column { flex-direction: column; }
        .justify-between { justify-content: space-between; }
        .align-center { align-items: center; }

        /* Empty States */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-xl) var(--spacing-md);
            text-align: center;
            min-height: 300px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: var(--spacing-md);
            opacity: 0.5;
        }

        .empty-state h3 {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
        }

        .empty-state p {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: var(--spacing-lg);
            max-width: 300px;
        }

        /* Form Validation */
        .form-group input:invalid:not(:focus):not(:placeholder-shown),
        .form-group select:invalid:not(:focus) {
            border-color: var(--danger-color);
        }

        .form-group input:valid:not(:focus):not(:placeholder-shown):not([type="datetime-local"]):not([type="date"]),
        .form-group select:valid:not(:focus):not([value=""]) {
            border-color: var(--success-color);
        }

        .field-error {
            color: var(--danger-color);
            font-size: 12px;
            margin-top: 4px;
            display: none;
        }

        .form-group.error .field-error {
            display: block;
        }

        /* Pull to Refresh Indicator - Disabled due to UX issues */
        .pull-to-refresh {
            display: none !important;  /* Completely hidden */
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            background: var(--card-bg);
            padding: 12px 24px;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s;
            z-index: 1001;
            align-items: center;
            gap: 8px;
        }

        .pull-to-refresh.active {
            transform: translateX(-50%) translateY(10px);
        }

        .pull-to-refresh-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Time Range Selector - Removed, now using .period-btn styles defined above */

        /* Swipe to Delete */
        .shot-item, .weight-item, .vial-item {
            position: relative;
            transition: transform 0.3s;
        }

        .shot-item.swiping, .weight-item.swiping, .vial-item.swiping {
            transition: none;
        }

        .delete-action {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 80px;
            background: var(--danger-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .shot-item.swiped .delete-action,
        .weight-item.swiped .delete-action,
        .vial-item.swiped .delete-action {
            opacity: 1;
        }

        /* Animated Transitions */
        .tab-content {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Offline Indicator */
        .offline-indicator {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--warning-color);
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            z-index: 10002;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .offline-indicator.show {
            display: block;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100%);
            }
            to {
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Weekly Insights Card */
        .insight-card {
            background: linear-gradient(135deg, var(--card-bg) 0%, #2d2d2d 100%);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .insight-card h3 {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
        }

        .insight-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-color);
        }

        .insight-stat:last-child {
            border-bottom: none;
        }

        .insight-label {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .insight-value {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 700;
        }

        .insight-trend {
            color: var(--success-color);
            font-size: 14px;
            font-weight: 600;
        }

        .insight-trend.negative {
            color: var(--danger-color);
        }

        /* Loading Spinner */
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        /* Countdown Timer Enhancements */
        .countdown-circle {
            cursor: pointer;
            user-select: none;
        }

        .countdown-circle:active {
            transform: scale(0.98);
        }

        .countdown-pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.02);
            }
        }
    </style>
</head>
<body>
    <!-- Authentication Gate -->
    <div id="auth-gate" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%); padding: 20px;">
        <div style="text-align: center; max-width: 400px;">
            <h1 style="font-size: 32px; margin-bottom: 16px; background: linear-gradient(135deg, #007AFF 0%, #0051a8 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                Retatrutide Tracker
            </h1>
            <p style="color: #888888; margin-bottom: 32px; font-size: 16px;">
                Please sign in to access your tracking data
            </p>

            <!-- Error message (hidden by default) -->
            <div id="auth-error-message" style="display: none; background: rgba(255, 59, 48, 0.1); border: 1px solid rgba(255, 59, 48, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 20px; color: #ff3b30;">
                <p id="auth-error-text" style="margin: 0; font-size: 14px;"></p>
            </div>

            <button id="auth-gate-button" style="background: linear-gradient(135deg, #007AFF 0%, #0051a8 100%); color: white; border: none; padding: 16px 32px; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3); transition: transform 0.2s, box-shadow 0.2s; min-width: 200px; touch-action: manipulation; -webkit-tap-highlight-color: rgba(0, 122, 255, 0.3);">
                Sign In with Google
            </button>

            <!-- Popup mode fallback button (hidden by default) -->
            <button id="auth-popup-fallback-button" style="display: none; background: transparent; border: 2px solid #007AFF; color: #007AFF; padding: 12px 24px; border-radius: 12px; font-size: 14px; font-weight: 600; cursor: pointer; margin-top: 12px; min-width: 200px; touch-action: manipulation;">
                Try Popup Mode
            </button>

            <p style="color: #666666; margin-top: 32px; font-size: 12px;">
                This is a private application. No data is shared publicly.
            </p>
        </div>
    </div>

    <!-- Application Content (hidden until authenticated) -->
    <div id="app-content" style="display: none;">
        <!-- Notification Container -->
        <div id="notification-container"></div>

        <!-- Undo Button -->
        <button id="undo-button"> Undo Delete</button>

        <!-- Save Indicator -->
        <div id="save-indicator" style="position: fixed; top: 70px; left: 50%; transform: translateX(-50%); background-color: #34C759; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 600; display: none; z-index: 10001; box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3);">
             Saved
        </div>

        <!-- Offline Indicator -->
        <div id="offline-indicator" class="offline-indicator">
             Offline - Changes saved locally
        </div>

        <!-- Header -->
        <header id="app-header">
        <div class="header-content">
            <button id="menu-btn" class="menu-btn"></button>
            <div id="build-timestamp" class="build-timestamp"></div>
            <button id="add-shot-btn" class="add-shot-btn">+ Shot</button>
        </div>
    </header>

    <!-- Phase 1B: Sync Queue Modal -->
    <div id="sync-queue-modal" class="sync-queue-modal">
        <div class="sync-queue-header">
            <h3>Sync Queue</h3>
            <button id="sync-queue-close" class="sync-queue-close"></button>
        </div>
        <div class="sync-queue-body" id="sync-queue-body">
            <div class="sync-queue-empty">No pending operations</div>
        </div>
        <div class="sync-queue-footer">
            <button id="sync-queue-clear-completed" class="sync-queue-clear-completed">Clear Completed</button>
            <button id="sync-queue-clear-failed" class="sync-queue-clear-failed">Clear Failed</button>
        </div>
    </div>

    <!-- Main Content Area -->
    <main id="main-content">
        <div class="loading" id="loading-screen">
            Loading Injection Tracker...
        </div>

        <!-- Summary Tab -->
        <div id="summary-tab" class="tab-content" style="display: none;">
            <div class="container">
                <!-- Weekly Insights Card -->
                <div id="weekly-insights" class="insight-card" style="display: none;">
                    <h3>This Week's Progress</h3>
                    <div class="insight-stat">
                        <span class="insight-label">Weight Change</span>
                        <span class="insight-value" id="insight-weight-change">--</span>
                        <span class="insight-trend" id="insight-weight-trend">--</span>
                    </div>
                    <div class="insight-stat">
                        <span class="insight-label">Avg Dose/Shot</span>
                        <span class="insight-value" id="insight-avg-dose">--</span>
                        <span class="insight-trend">--</span>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="total-shots">0</div>
                        <div class="stat-label">Total Shots</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="last-dose">0 mg</div>
                        <div class="stat-label">Last Dose</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="current-level">0%</div>
                        <div class="stat-label">Level at Last Shot</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="next-shot">0 days</div>
                        <div class="stat-label">Next Shot</div>
                    </div>
                </div>

                <div class="countdown-container">
                    <h3>Next Shot Due</h3>
                    <div class="countdown-circle">
                        <div class="countdown-content">
                            <div class="next-shot-day" id="next-shot-day">Saturday</div>
                            <div class="next-shot-date" id="next-shot-date">Jan 1</div>
                            <div class="next-shot-time" id="next-shot-time">8:00 AM</div>
                        </div>
                        <svg class="countdown-progress" width="200" height="200">
                            <circle cx="100" cy="100" r="90" stroke="#333333" stroke-width="8" fill="none"/>
                            <circle id="countdown-circle" cx="100" cy="100" r="90" stroke="#007AFF" stroke-width="8"
                                    fill="none" stroke-linecap="round" transform="rotate(-90 100 100)"
                                    stroke-dasharray="565.48" stroke-dashoffset="0"/>
                        </svg>
                    </div>
                </div>

                <div class="supply-forecast-container">
                    <h3>Supply Forecast</h3>
                    <div class="supply-forecast">
                        <div class="forecast-row">
                            <span class="forecast-label">Total Supply:</span>
                            <span class="forecast-value" id="total-supply">0 mg</span>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Planned Weekly Dose:</span>
                            <div class="forecast-input-group">
                                <input type="number" id="planned-dose" step="0.5" min="0" max="20" value="4.0" class="forecast-input">
                                <span class="forecast-unit">mg</span>
                            </div>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Supply Will Last:</span>
                            <div class="stat-value-container">
                                <span class="forecast-value" id="supply-duration">0 weeks</span>
                                <span id="supply-duration-validation-indicator"></span>
                            </div>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Estimated Run Out Date:</span>
                            <div class="stat-value-container">
                                <span class="forecast-value" id="run-out-date">--</span>
                                <span id="run-out-date-validation-indicator"></span>
                            </div>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Days Until Reorder:</span>
                            <div class="stat-value-container">
                                <span class="forecast-value" id="reorder-days">--</span>
                                <span id="reorder-days-validation-indicator"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Shots Tab -->
        <div id="shots-tab" class="tab-content" style="display: none;">
            <div class="container">
                <div class="shots-header">
                    <h2>Shot History</h2>
                    <button id="skip-week-btn" class="skip-week-btn">Skip</button>
                </div>
                <div id="shots-list" class="shots-list"></div>
            </div>
        </div>

        <!-- Results Tab -->
        <div id="results-tab" class="tab-content" style="display: none;">
            <div class="container">
                <!-- Results Header -->
                <div class="results-header">
                    <h2>Results</h2>
                    <button class="skip-week-btn" onclick="app.showSkipWeekModal()">Skip</button>
                </div>

                <!-- Time Period Segmented Control -->
                <div class="time-period-control">
                    <button class="period-btn active" data-months="1">1 month</button>
                    <button class="period-btn" data-months="3">3 months</button>
                    <button class="period-btn" data-months="6">6 months</button>
                    <button class="period-btn" data-months="all">All time</button>
                </div>

                <!-- Add Weight Button -->
                <div style="text-align: center; margin: 20px 0;">
                    <button class="btn-primary" onclick="app.openModal('add-weight-modal')" style="padding: 12px 24px; font-size: 16px;">
                        Add Weight
                    </button>
                </div>

                <!-- Shots with Weight Chart -->
                <div class="chart-section">
                    <h3 class="chart-section-title">Shots with Weight</h3>
                    <div class="chart-container" id="shots-weight-chart-view">
                        <canvas id="shots-weight-chart"></canvas>
                    </div>
                </div>

                <!-- Weight Only Chart -->
                <div class="chart-section">
                    <h3 class="chart-section-title">Weight Trend</h3>
                    <div class="chart-container" id="weight-only-chart-view">
                        <canvas id="weight-only-chart"></canvas>
                    </div>
                </div>

                <div id="table-view" class="table-view" style="display: none;">
                    <div id="weight-table"></div>
                </div>

                <!-- Weight Change Section -->
                <div class="weight-change-section">
                    <div class="section-header">
                        <div class="section-title">
                            <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                                <path d="M2 17l10 5 10-5M2 12l10 5 10-5"/>
                            </svg>
                            <h3>Weight Change</h3>
                        </div>
                        <div class="date-range" id="date-range-display">Sep 27, 2025 - Oct 29</div>
                    </div>

                    <!-- Metric Cards Grid (2x3) -->
                    <div class="results-stats-grid">
                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                                </svg>
                                Total change
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="total-change">-11.3 kg</div>
                                <span id="total-change-validation-indicator"></span>
                            </div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                                    <circle cx="12" cy="7" r="4"/>
                                </svg>
                                Current BMI
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="current-bmi">--</div>
                                <span id="bmi-validation-indicator"></span>
                            </div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M12 6v6l4 2"/>
                                </svg>
                                Weight
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="current-weight">94.5 kg</div>
                                <span id="current-weight-validation-indicator"></span>
                            </div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <text x="12" y="16" text-anchor="middle" fill="currentColor" font-size="10">%</text>
                                </svg>
                                Percent
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="percent-change">-11%</div>
                                <span id="percent-change-validation-indicator"></span>
                            </div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 2v20M17 12H7M17 7H7M17 17H7"/>
                                </svg>
                                Weekly avg
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="weekly-avg">-2.5 kg/wk</div>
                                <span id="weekly-avg-validation-indicator"></span>
                            </div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/>
                                </svg>
                                Progress
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="goal-progress">52%</div>
                                <span id="goal-progress-validation-indicator"></span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Goal Progress Card -->
                <div id="goal-progress-card" style="display: none; margin-top: 24px; background: linear-gradient(135deg, var(--card-bg) 0%, #2d2d2d 100%); border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: var(--spacing-lg);">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Goal Progress</h3>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-sm);">
                        <span style="color: var(--text-secondary); font-size: 14px;">
                            <span id="goal-start-weight">--</span> kg  <span id="goal-target-weight">--</span> kg
                        </span>
                        <span style="color: var(--text-primary); font-weight: 600; font-size: 16px;">
                            <span id="goal-progress-percent">0</span>%
                        </span>
                    </div>
                    <div style="width: 100%; height: 8px; background: var(--border-color); border-radius: 4px; overflow: hidden; margin-bottom: var(--spacing-md);">
                        <div id="goal-progress-bar" style="height: 100%; background: linear-gradient(90deg, var(--accent-color), #34C759); width: 0%; transition: width 0.5s ease;"></div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: var(--spacing-md);">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 4px;">Remaining</div>
                            <div style="color: var(--text-primary); font-weight: 600; font-size: 16px;" id="goal-remaining">-- kg</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 4px;">Weekly Avg</div>
                            <div style="color: var(--text-primary); font-weight: 600; font-size: 16px;" id="goal-weekly-rate">-- kg</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 4px;">Est. Date</div>
                            <div style="color: var(--text-primary); font-weight: 600; font-size: 16px;" id="goal-eta-date">--</div>
                        </div>
                    </div>
                    <p id="goal-message" style="margin-top: var(--spacing-md); padding: var(--spacing-sm); background: rgba(52, 199, 89, 0.1); border-radius: 6px; color: var(--success-color); font-size: 14px; text-align: center;">
                        Keep up the great work!
                    </p>
                </div>

                <h3 style="margin-top: 32px; margin-bottom: 16px;">Weight History</h3>
                <div id="weights-list" class="weights-list"></div>
            </div>
        </div>

        <!-- Inventory Tab -->
        <div id="inventory-tab" class="tab-content" style="display: none;">
            <div class="container">
                <h2>Vial Management</h2>
                <div class="inventory-header">
                    <button id="add-vial-btn" class="btn-primary">Add Vials to Stock</button>
                    <button id="activate-vial-btn" class="btn-secondary">Activate Vial</button>
                </div>
                <div id="vials-list" class="vials-list"></div>
                <div class="inventory-stats">
                    <div class="inventory-card">
                        <div class="inventory-value" id="total-stock">0</div>
                        <div class="inventory-label">Doses in Stock</div>
                    </div>
                    <div class="inventory-card">
                        <div class="inventory-value" id="days-remaining">0</div>
                        <div class="inventory-label">Days Remaining</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Tab -->
        <div id="settings-tab" class="tab-content" style="display: none;">
            <div class="container">
                <h2>Settings</h2>

                <!-- Cloud Sync Section -->
                <div class="settings-section" style="background: linear-gradient(135deg, var(--accent-color) 0%, #0051a8 100%); border-radius: var(--border-radius); padding: var(--spacing-lg); margin-bottom: var(--spacing-lg);">
                    <h3 style="margin-bottom: var(--spacing-sm);"> Cloud Sync</h3>
                    <p id="user-info" style="display: none; margin-bottom: var(--spacing-md); opacity: 0.9;"></p>
                    <button id="auth-button" class="btn-primary" style="width: 100%; background: white; color: var(--accent-color); font-weight: 600;">
                        Sign In with Google
                    </button>
                    <p style="margin-top: var(--spacing-sm); font-size: 0.85em; opacity: 0.8;">
                        Sign in to sync your data across devices and enable automatic backups
                    </p>
                </div>

                <div class="settings-section">
                    <h3>Injection Schedule</h3>
                    <label>
                        Injection Frequency (days):
                        <div class="setting-input-wrapper">
                            <input type="number" id="injection-frequency" step="1" min="1" max="90" value="7" placeholder="Days between injections">
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <p style="font-size: 0.85em; color: var(--text-secondary); margin-top: -12px; margin-left: 8px;">
                        Common intervals: 7 (weekly), 14 (bi-weekly), 21 (every 3 weeks), 28 (monthly)
                    </p>
                    <label>
                        Default Dose (mg):
                        <div class="setting-input-wrapper">
                            <input type="number" id="default-dose" step="0.1" min="0" max="50" value="2.0">
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <p style="font-size: 0.85em; color: var(--text-secondary); margin-top: -12px; margin-left: 8px;">
                        Used for calculating remaining doses in vials and pre-filling new injection entries
                    </p>
                    <label>
                        Pre-fill New Injection Dose From:
                        <div class="setting-input-wrapper">
                            <select id="prefill-dose-from">
                                <option value="last">Last injection dose</option>
                                <option value="default">Default dose</option>
                            </select>
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <label>
                        Height (cm):
                        <div class="setting-input-wrapper">
                            <input type="number" id="user-height" step="0.1" min="0" max="300" placeholder="Enter height">
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <label>
                        Goal Weight (kg):
                        <div class="setting-input-wrapper">
                            <input type="number" id="goal-weight" step="0.1" min="0" max="300" placeholder="Enter goal weight">
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                </div>
                <div class="settings-section">
                    <h3>Data Management</h3>
                    <button id="export-data-btn" class="btn-secondary">Export Data</button>
                    <button id="import-data-btn" class="btn-secondary">Import Data from File</button>
                </div>
                <div class="settings-section">
                    <h3> Cloud Backup</h3>
                    <div id="cloud-backup-info" style="margin-bottom: 16px; padding: 12px; background-color: var(--secondary-bg); border-radius: var(--border-radius-sm);">
                        <p style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">
                            Store a secure backup of all your data in the cloud (AWS S3).
                        </p>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span>Status:</span>
                            <span id="cloud-backup-status">Not authenticated</span>
                        </div>
                        <div id="cloud-backup-last" style="display: none; justify-content: space-between; margin-bottom: 8px;">
                            <span>Last Cloud Backup:</span>
                            <span id="cloud-backup-timestamp">Never</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-muted);">
                            <span>Next Auto-Backup:</span>
                            <span id="next-backup-date">-</span>
                        </div>
                    </div>
                    <button id="create-cloud-backup-btn" class="btn-primary" style="margin-bottom: 8px;" disabled>
                        Backup to Cloud
                    </button>
                    <p style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">
                         Cloud backups: Auto-backup every Monday at 9 AM. Keeps only 4 most recent backups. Sign in required.
                    </p>
                </div>

                <!-- Danger Zone: Reset Options -->
                <div class="settings-section" style="background-color: rgba(239, 68, 68, 0.05); border: 2px solid rgba(239, 68, 68, 0.2); border-radius: var(--border-radius);">
                    <h3 style="color: #ef4444; margin-bottom: var(--spacing-md);"> Danger Zone</h3>

                    <div style="margin-bottom: 20px; padding: 12px; background-color: rgba(255, 255, 255, 0.5); border-radius: var(--border-radius-sm);">
                        <h4 style="color: var(--text-primary); margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">Reset Local Data & Sync from Cloud</h4>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                            Delete all local data and reload from cloud. Use this if you're seeing duplicate records or outdated data.
                        </p>
                        <button id="reset-local-data-btn" class="btn-danger" style="width: 100%;">
                             Reset Local Data & Sync from Cloud
                        </button>
                        <p style="font-size: 11px; color: var(--text-muted); margin-top: 8px; font-style: italic;">
                             Make sure you're signed in and your data is backed up to cloud first.
                        </p>
                    </div>

                    <div style="padding: 12px; background-color: rgba(255, 255, 255, 0.5); border-radius: var(--border-radius-sm);">
                        <h4 style="color: var(--text-primary); margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">Nuclear Reset</h4>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                            Permanently delete ALL local data (localStorage, IndexedDB, caches) and reload the page. Use this for severe data sync issues or phantom records.
                        </p>
                        <button id="nuclear-reset-btn" class="btn-secondary" style="background-color: #ef4444; color: white; border: none; width: 100%;">
                             Nuclear Reset
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- TRT TABS (hidden by default) -->

        <!-- TRT Dashboard Tab -->
        <div id="trt-dashboard-tab" class="tab-content" style="display: none;">
            <h2 style="margin-bottom: var(--spacing-lg);">TRT Dashboard</h2>

            <!-- Summary Metrics -->
            <div class="metrics-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: var(--spacing-md); margin-bottom: var(--spacing-lg);">
                <div class="metric-card card" style="padding: var(--spacing-md); text-align: center;">
                    <div class="metric-label" style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Total Injections</div>
                    <div class="metric-value" id="trt-total-injections" style="font-size: 24px; font-weight: 600;">0</div>
                </div>
                <div class="metric-card card" style="padding: var(--spacing-md); text-align: center;">
                    <div class="metric-label" style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Last Dose</div>
                    <div class="metric-value" id="trt-last-dose" style="font-size: 24px; font-weight: 600;">0 mg</div>
                </div>
                <div class="metric-card card" style="padding: var(--spacing-md); text-align: center;">
                    <div class="metric-label" style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Next Injection</div>
                    <div class="metric-value" id="trt-next-injection" style="font-size: 24px; font-weight: 600;">-</div>
                </div>
                <div class="metric-card card" style="padding: var(--spacing-md); text-align: center;">
                    <div class="metric-label" style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Supply</div>
                    <div class="metric-value" id="trt-supply-remaining" style="font-size: 24px; font-weight: 600;">0 weeks</div>
                </div>
            </div>

            <!-- Supply Forecast Card -->
            <div class="card">
                <h3> Supply Forecast</h3>
                <div id="trt-supply-forecast"></div>
            </div>

            <!-- Current Protocol Card -->
            <div class="card">
                <h3> Current Protocol</h3>
                <div id="trt-protocol-summary">
                    <p style="color: var(--text-secondary); font-size: 14px;">No protocol data yet. Add injections to see your protocol summary.</p>
                </div>
            </div>
        </div>

        <!-- TRT Shots Tab -->
        <div id="trt-shots-tab" class="tab-content" style="display: none;">
            <h2 style="margin-bottom: var(--spacing-lg);">TRT Injections</h2>

            <!-- Injection Site Rotation Warning -->
            <div id="trt-site-rotation-warning" style="display: none; margin-bottom: var(--spacing-md);"></div>

            <!-- Injection List -->
            <div id="trt-injections-list"></div>

            <div id="trt-no-injections" style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
                <p>No TRT injections recorded yet.</p>
                <p style="font-size: 14px; margin-top: 8px;">Tap "+ Shot" to add your first injection.</p>
            </div>
        </div>

        <!-- TRT Symptoms Tab -->
        <div id="trt-symptoms-tab" class="tab-content" style="display: none;">
            <h2 style="margin-bottom: var(--spacing-lg);">Symptom Tracking</h2>

            <!-- Quick Check-in Card -->
            <div class="card">
                <h3> Today's Check-in</h3>
                <div id="trt-symptom-form">
                    <div class="symptom-slider">
                        <label>Energy Level</label>
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <span style="font-size: 12px; color: var(--text-muted);">Low</span>
                            <input type="range" id="trt-energy" min="1" max="10" value="5" style="flex: 1;">
                            <span style="font-size: 12px; color: var(--text-muted);">High</span>
                            <span id="trt-energy-value" style="font-weight: 600; min-width: 30px; text-align: right;">5</span>
                        </div>
                    </div>

                    <div class="symptom-slider" style="margin-top: var(--spacing-md);">
                        <label>Mood</label>
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <span style="font-size: 12px; color: var(--text-muted);">Low</span>
                            <input type="range" id="trt-mood" min="1" max="10" value="5" style="flex: 1;">
                            <span style="font-size: 12px; color: var(--text-muted);">High</span>
                            <span id="trt-mood-value" style="font-weight: 600; min-width: 30px; text-align: right;">5</span>
                        </div>
                    </div>

                    <div class="symptom-slider" style="margin-top: var(--spacing-md);">
                        <label>Libido</label>
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <span style="font-size: 12px; color: var(--text-muted);">Low</span>
                            <input type="range" id="trt-libido" min="1" max="10" value="5" style="flex: 1;">
                            <span style="font-size: 12px; color: var(--text-muted);">High</span>
                            <span id="trt-libido-value" style="font-weight: 600; min-width: 30px; text-align: right;">5</span>
                        </div>
                    </div>

                    <div class="symptom-slider" style="margin-top: var(--spacing-md);">
                        <label>Sleep Quality</label>
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <span style="font-size: 12px; color: var(--text-muted);">Poor</span>
                            <input type="range" id="trt-sleep" min="1" max="10" value="5" style="flex: 1;">
                            <span style="font-size: 12px; color: var(--text-muted);">Great</span>
                            <span id="trt-sleep-value" style="font-weight: 600; min-width: 30px; text-align: right;">5</span>
                        </div>
                    </div>

                    <div style="margin-top: var(--spacing-md);">
                        <label for="trt-symptom-notes">Notes (optional)</label>
                        <textarea id="trt-symptom-notes" style="width: 100%; min-height: 80px; margin-top: 8px; padding: 12px; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); color: var(--text-primary); font-family: inherit; resize: vertical;" placeholder="Any other symptoms or observations..."></textarea>
                    </div>

                    <button id="trt-save-symptom-btn" class="btn-primary" style="width: 100%; margin-top: var(--spacing-md);">
                        Save Check-in
                    </button>
                </div>
            </div>

            <!-- Symptom Trend Graph -->
            <div class="card" style="margin-top: var(--spacing-md);">
                <h3> Symptom Trends</h3>
                <div id="trt-symptom-graph-container" style="position: relative; height: 300px; margin-top: 16px;">
                    <canvas id="trt-symptom-graph"></canvas>
                </div>
                <div id="trt-no-symptom-data" style="display: none; text-align: center; padding: 60px 20px; color: var(--text-muted); font-size: 14px;">
                    Add at least 2 symptom check-ins to see trend graphs.
                </div>
            </div>

            <!-- Symptom History -->
            <div class="card" style="margin-top: var(--spacing-md);">
                <h3> Symptom History</h3>
                <div id="trt-symptoms-list"></div>
                <div id="trt-no-symptoms" style="text-align: center; padding: 20px; color: var(--text-muted); font-size: 14px;">
                    No symptom check-ins yet. Track your daily symptoms above.
                </div>
            </div>
        </div>

        <!-- TRT Inventory Tab -->
        <div id="trt-inventory-tab" class="tab-content" style="display: none;">
            <h2 style="margin-bottom: var(--spacing-lg);">TRT Vial Inventory</h2>

            <button id="add-trt-vial-btn" class="btn-primary" style="width: 100%; margin-bottom: var(--spacing-lg);">
                + Add Vial
            </button>

            <div id="trt-vials-list"></div>

            <div id="trt-no-vials" style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
                <p>No vials in inventory yet.</p>
                <p style="font-size: 14px; margin-top: 8px;">Add your first vial above to start tracking.</p>
            </div>
        </div>

        <!-- TRT Settings Tab -->
        <div id="trt-settings-tab" class="tab-content" style="display: none;">
            <h2 style="margin-bottom: var(--spacing-lg);">TRT Settings</h2>

            <div class="settings-section">
                <h3>Injection Settings</h3>

                <div class="setting-group">
                    <label for="trt-injection-frequency">Injection Frequency (days)</label>
                    <input type="number" id="trt-injection-frequency" min="1" max="14" step="0.5" placeholder="e.g., 3.5 for twice weekly">
                </div>

                <div class="setting-group">
                    <label for="trt-default-dose-mg">Default Dose (mg)</label>
                    <input type="number" id="trt-default-dose-mg" min="1" step="1" placeholder="e.g., 100">
                </div>

                <div class="setting-group">
                    <label for="trt-default-dose-ml">Default Dose (ml)</label>
                    <input type="number" id="trt-default-dose-ml" min="0.1" step="0.05" placeholder="e.g., 0.5">
                </div>

                <div class="setting-group">
                    <label for="trt-concentration">Testosterone Concentration (mg/ml)</label>
                    <input type="number" id="trt-concentration" min="1" step="1" placeholder="e.g., 200">
                </div>

                <button id="trt-save-settings-btn" class="btn-primary" style="width: 100%; margin-top: var(--spacing-md);">
                    Save TRT Settings
                </button>
            </div>
        </div>

    </main>

    <!-- Floating App Switcher -->
    <div class="app-switcher-container">
        <div class="app-switcher">
            <button class="app-switcher-btn active" data-app="reta">Reta</button>
            <button class="app-switcher-btn" data-app="trt">TRT</button>
        </div>
    </div>

    <!-- Bottom Navigation -->
    <nav id="bottom-nav" class="bottom-nav">
        <button class="nav-btn active" data-tab="summary">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <path d="M3 9h18M9 21V9"/>
            </svg>
            <span class="nav-label">Summary</span>
        </button>
        <button class="nav-btn" data-tab="shots">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 2l4 4-4 4M10 8l-2 2 2 2"/>
                <path d="M22 6H10a8 8 0 00-8 8v0a2 2 0 002 2h10"/>
                <circle cx="18" cy="18" r="3"/>
            </svg>
            <span class="nav-label">Shots</span>
        </button>
        <button class="nav-btn" data-tab="results">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 3v18h18"/>
                <path d="M18 17l-5-5-4 4-4-7"/>
            </svg>
            <span class="nav-label">Results</span>
        </button>
        <button class="nav-btn" data-tab="inventory">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 16V8a2 2 0 00-1-1.73l-7-4a2 2 0 00-2 0l-7 4A2 2 0 003 8v8a2 2 0 001 1.73l7 4a2 2 0 002 0l7-4A2 2 0 0021 16z"/>
                <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
                <line x1="12" y1="22.08" x2="12" y2="12"/>
            </svg>
            <span class="nav-label">Inventory</span>
        </button>
        <button class="nav-btn" data-tab="settings">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.25m4.24 4.24l4.24 4.25M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.25"/>
            </svg>
            <span class="nav-label">Settings</span>
        </button>

        <!-- TRT Navigation (hidden by default) -->
        <button class="nav-btn" data-tab="trt-dashboard" style="display: none;">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <path d="M3 9h18M9 21V9"/>
            </svg>
            <span class="nav-label">Dashboard</span>
        </button>
        <button class="nav-btn" data-tab="trt-shots" style="display: none;">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 2l4 4-4 4M10 8l-2 2 2 2"/>
                <path d="M22 6H10a8 8 0 00-8 8v0a2 2 0 002 2h10"/>
                <circle cx="18" cy="18" r="3"/>
            </svg>
            <span class="nav-label">Shots</span>
        </button>
        <button class="nav-btn" data-tab="trt-symptoms" style="display: none;">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
            </svg>
            <span class="nav-label">Symptoms</span>
        </button>
        <button class="nav-btn" data-tab="trt-inventory" style="display: none;">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 16V8a2 2 0 00-1-1.73l-7-4a2 2 0 00-2 0l-7 4A2 2 0 003 8v8a2 2 0 001 1.73l7 4a2 2 0 002 0l7-4A2 2 0 0021 16z"/>
                <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
                <line x1="12" y1="22.08" x2="12" y2="12"/>
            </svg>
            <span class="nav-label">Inventory</span>
        </button>
        <button class="nav-btn" data-tab="trt-settings" style="display: none;">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.25m4.24 4.24l4.24 4.25M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.25"/>
            </svg>
            <span class="nav-label">Settings</span>
        </button>
    </nav>

    <!-- Modals -->
    <div id="modal-overlay" class="modal-overlay" style="display: none;">
        <!-- Add Shot Modal -->
        <div id="add-shot-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 id="add-shot-modal-title" class="modal-title">Add New Shot</h3>
                <button class="modal-close" data-modal="add-shot-modal">&times;</button>
            </div>
            <form id="add-shot-form">
                <div class="form-group">
                    <label for="shot-date">Date & Time</label>
                    <input type="datetime-local" id="shot-date" required>
                </div>
                <div class="form-group">
                    <label for="shot-dose">Dose (mg)</label>
                    <input type="number" id="shot-dose" step="0.1" min="0" max="50" required>
                    <div id="dose-ml-helper" style="font-size: 12px; color: var(--text-secondary); margin-top: 4px; min-height: 18px;">
                        <!-- Live ml conversion will appear here -->
                    </div>
                </div>
                <div class="form-group">
                    <label for="shot-site">Injection Site</label>
                    <select id="shot-site" required>
                        <option value="">Select injection site</option>
                        <option value="left_thigh">Left Thigh</option>
                        <option value="right_thigh">Right Thigh</option>
                        <option value="left_arm">Left Arm</option>
                        <option value="right_arm">Right Arm</option>
                        <option value="abdomen_left">Abdomen Left</option>
                        <option value="abdomen_right">Abdomen Right</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="shot-vial">Vial</label>
                    <select id="shot-vial" required>
                        <option value="">Select vial</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="shot-notes">Notes - Optional</label>
                    <textarea id="shot-notes" placeholder="Side effects, timing, etc."></textarea>
                </div>
                <div class="form-group">
                    <button type="submit" id="shot-submit-btn" class="btn-primary">Add Shot</button>
                    <button type="button" class="btn-secondary" data-modal="add-shot-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Skip Week Modal -->
        <div id="skip-shot-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Skip Week/Dose</h3>
                <button class="modal-close" data-modal="skip-shot-modal">&times;</button>
            </div>
            <form id="skip-shot-form">
                <div class="form-group">
                    <label for="skip-shot-date">Date & Time</label>
                    <input type="datetime-local" id="skip-shot-date" required>
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                        When was this dose scheduled?
                    </p>
                </div>
                <div class="form-group">
                    <label for="skip-planned-dose">Planned Dose (mg)</label>
                    <input type="number" id="skip-planned-dose" step="0.1" min="0" max="50" required readonly>
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                        This is the dose you would have taken (for reference)
                    </p>
                </div>
                <div class="form-group">
                    <label for="skip-reason">Reason - Optional</label>
                    <textarea id="skip-reason" placeholder="e.g., Traveling, side effects, etc."></textarea>
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Confirm Skip</button>
                    <button type="button" class="btn-secondary" data-modal="skip-shot-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Add Vial Modal -->
        <div id="add-vial-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 id="add-vial-modal-title" class="modal-title">Add New Vials to Dry Stock</h3>
                <button class="modal-close" data-modal="add-vial-modal">&times;</button>
            </div>
            <form id="add-vial-form">
                <div class="form-group">
                    <label for="vial-order-date">Order Date</label>
                    <input type="date" id="vial-order-date" required>
                </div>
                <div class="form-group">
                    <label for="vial-supplier">Supplier</label>
                    <input type="text" id="vial-supplier" placeholder="Pharmacy name">
                </div>
                <div class="form-group">
                    <label for="vial-mg">mg per Vial</label>
                    <input type="number" id="vial-mg" step="0.1" min="0" required placeholder="10" value="10">
                </div>
                <div class="form-group">
                    <label for="vial-quantity">Number of Vials</label>
                    <input type="number" id="vial-quantity" min="1" required placeholder="2" value="1">
                </div>
                <div class="form-group">
                    <button id="vial-submit-btn" type="submit" class="btn-primary">Add to Dry Stock</button>
                    <button type="button" class="btn-secondary" data-modal="add-vial-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Edit Vial Modal -->
        <div id="edit-vial-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Edit Vial</h3>
                <button class="modal-close" data-modal="edit-vial-modal">&times;</button>
            </div>
            <form id="edit-vial-form">
                <input type="hidden" id="edit-vial-id">
                <div class="form-group">
                    <label for="edit-vial-order-date">Order Date</label>
                    <input type="date" id="edit-vial-order-date" required>
                </div>
                <div class="form-group">
                    <label for="edit-vial-supplier">Supplier</label>
                    <input type="text" id="edit-vial-supplier" placeholder="Pharmacy name">
                </div>
                <div class="form-group">
                    <label for="edit-vial-mg">mg per Vial</label>
                    <input type="number" id="edit-vial-mg" step="0.1" min="0" required placeholder="10">
                </div>
                <div class="form-group" id="edit-vial-volume-group" style="display: none;">
                    <label for="edit-vial-current-volume">Current Volume (ml)</label>
                    <input type="number" id="edit-vial-current-volume" step="0.01" min="0" placeholder="0.50">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                        Manually adjust remaining volume in this vial (active vials only)
                    </p>
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Save Changes</button>
                    <button type="button" class="btn-secondary" data-modal="edit-vial-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Activate Vial Modal -->
        <div id="activate-vial-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Activate Vial</h3>
                <button class="modal-close" data-modal="activate-vial-modal">&times;</button>
            </div>
            <form id="activate-vial-form">
                <div class="form-group">
                    <label for="activate-vial-id">Select Vial to Activate</label>
                    <select id="activate-vial-id" required>
                        <option value="">Select a vial to activate...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="activate-bac-water">BAC Water (ml)</label>
                    <input type="number" id="activate-bac-water" step="0.1" min="0" required placeholder="1.0" value="1.0">
                </div>
                <div class="form-group">
                    <label for="activate-reconstitution-date">Reconstitution Date & Time</label>
                    <input type="datetime-local" id="activate-reconstitution-date" required>
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Activate Vial</button>
                    <button type="button" class="btn-secondary" data-modal="activate-vial-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Add Weight Modal -->
        <div id="add-weight-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 id="add-weight-modal-title" class="modal-title">Add Weight Entry</h3>
                <button class="modal-close" data-modal="add-weight-modal">&times;</button>
            </div>
            <form id="add-weight-form">
                <div class="form-group">
                    <label for="weight-date">Date & Time</label>
                    <input type="datetime-local" id="weight-date" required>
                </div>
                <div class="form-group">
                    <label for="weight-kg">Weight (kg)</label>
                    <input type="number" id="weight-kg" step="0.1" min="0" max="500" required>
                </div>
                <div class="form-group">
                    <label for="weight-body-fat">Body Fat % - Optional</label>
                    <input type="number" id="weight-body-fat" step="0.1" min="0" max="100">
                </div>
                <div class="form-group">
                    <button type="submit" id="weight-submit-btn" class="btn-primary">Add Weight</button>
                    <button type="button" class="btn-secondary" data-modal="add-weight-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- TRT Add Injection Modal -->
        <div id="add-trt-injection-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 id="add-trt-injection-modal-title" class="modal-title">Add TRT Injection</h3>
                <button class="modal-close" data-modal="add-trt-injection-modal">&times;</button>
            </div>
            <form id="add-trt-injection-form">
                <div class="form-group">
                    <label for="trt-injection-date">Date & Time</label>
                    <input type="datetime-local" id="trt-injection-date" required>
                </div>
                <div class="form-group">
                    <label for="trt-injection-vial">Vial</label>
                    <select id="trt-injection-vial" required>
                        <option value="">Select vial</option>
                    </select>
                </div>
                <div class="form-group" style="display: flex; align-items: center; gap: 8px; padding: 12px; background: var(--secondary-bg); border-radius: var(--border-radius-sm); margin-bottom: var(--spacing-md);">
                    <input type="checkbox" id="trt-finish-vial-checkbox" style="width: auto; margin: 0;">
                    <label for="trt-finish-vial-checkbox" style="margin: 0; cursor: pointer; user-select: none;">
                        Finish this vial (use all remaining volume)
                    </label>
                </div>
                <div class="form-group">
                    <label for="trt-injection-volume">Volume (ml)</label>
                    <input type="number" id="trt-injection-volume" step="0.05" min="0.1" max="2" required placeholder="0.5">
                    <p id="trt-remaining-volume-hint" style="font-size: 12px; color: var(--text-secondary); margin-top: 4px; display: none;">
                        Remaining in vial: <span id="trt-vial-remaining-display">--</span> ml
                    </p>
                </div>
                <div id="trt-dose-display" style="background: var(--secondary-bg); padding: 12px; border-radius: var(--border-radius-sm); margin-bottom: var(--spacing-md); display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: var(--text-secondary);">Concentration:</span>
                        <span id="trt-concentration-display" style="font-weight: 600;">--</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                        <span style="color: var(--text-secondary);">Calculated Dose:</span>
                        <span id="trt-calculated-dose" style="font-weight: 600; color: var(--primary-color); font-size: 18px;">--</span>
                    </div>
                </div>
                <div class="form-group">
                    <label for="trt-injection-site">Injection Site</label>
                    <select id="trt-injection-site" required>
                        <option value="">Select site</option>
                        <option value="left_front_thigh">Left Front Thigh</option>
                        <option value="right_front_thigh">Right Front Thigh</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="trt-injection-time-of-day">Time of Day</label>
                    <select id="trt-injection-time-of-day">
                        <option value="">Select time (optional)</option>
                        <option value="morning">Morning</option>
                        <option value="afternoon">Afternoon</option>
                        <option value="evening">Evening</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="trt-injection-technique">Technique Notes - Optional</label>
                    <input type="text" id="trt-injection-technique" placeholder="e.g., 25g 1in IM">
                </div>
                <div class="form-group">
                    <label for="trt-injection-notes">Notes - Optional</label>
                    <textarea id="trt-injection-notes" placeholder="How you felt, side effects, etc."></textarea>
                </div>
                <div class="form-group">
                    <button type="submit" id="trt-injection-submit-btn" class="btn-primary">Add Injection</button>
                    <button type="button" class="btn-secondary" data-modal="add-trt-injection-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- TRT Add Vial Modal -->
        <div id="add-trt-vial-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 id="add-trt-vial-modal-title" class="modal-title">Add TRT Vial</h3>
                <button class="modal-close" data-modal="add-trt-vial-modal">&times;</button>
            </div>
            <form id="add-trt-vial-form">
                <div class="form-group">
                    <label for="trt-vial-concentration">Testosterone Concentration (mg/ml)</label>
                    <input type="number" id="trt-vial-concentration" step="1" min="1" required placeholder="200" value="200">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                        Common: 200mg/ml or 250mg/ml
                    </p>
                </div>
                <div class="form-group">
                    <label for="trt-vial-volume">Total Volume (ml)</label>
                    <input type="number" id="trt-vial-volume" step="0.1" min="0.1" required placeholder="10" value="10">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                        Original volume when vial is new/full
                    </p>
                </div>
                <div class="form-group" id="trt-vial-remaining-group" style="display: none;">
                    <label for="trt-vial-remaining">Remaining Volume (ml)</label>
                    <input type="number" id="trt-vial-remaining" step="0.1" min="0.1" placeholder="7.5">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                        How much is currently left in the vial (leave blank if full)
                    </p>
                </div>
                <div class="form-group">
                    <label for="trt-vial-lot">Lot Number - Optional</label>
                    <input type="text" id="trt-vial-lot" placeholder="LOT123456">
                </div>
                <div class="form-group">
                    <label for="trt-vial-expiry">Expiry Date</label>
                    <input type="date" id="trt-vial-expiry" required>
                </div>
                <div class="form-group">
                    <label for="trt-vial-status">Status</label>
                    <select id="trt-vial-status" required>
                        <option value="dry_stock">Dry Stock (Unopened)</option>
                        <option value="active">Active (In Use)</option>
                    </select>
                </div>
                <div class="form-group" id="trt-vial-opened-group" style="display: none;">
                    <label for="trt-vial-opened">Opened Date</label>
                    <input type="date" id="trt-vial-opened">
                </div>
                <div class="form-group">
                    <label for="trt-vial-notes">Notes - Optional</label>
                    <textarea id="trt-vial-notes" placeholder="Storage location, batch info, etc."></textarea>
                </div>
                <div class="form-group">
                    <button type="submit" id="trt-vial-submit-btn" class="btn-primary">Add Vial</button>
                    <button type="button" class="btn-secondary" data-modal="add-trt-vial-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- TRT Skip Week Modal -->
        <div id="skip-trt-injection-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Skip TRT Injection</h3>
                <button class="modal-close" data-modal="skip-trt-injection-modal">&times;</button>
            </div>
            <form id="skip-trt-injection-form">
                <div class="form-group">
                    <label for="skip-trt-injection-date">Date & Time</label>
                    <input type="datetime-local" id="skip-trt-injection-date" required>
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                        When was this injection scheduled?
                    </p>
                </div>
                <div class="form-group">
                    <label for="skip-trt-planned-dose">Planned Dose (mg)</label>
                    <input type="number" id="skip-trt-planned-dose" step="1" min="0" required readonly>
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                        This is the dose you would have taken (for reference)
                    </p>
                </div>
                <div class="form-group">
                    <label for="skip-trt-reason">Reason - Optional</label>
                    <textarea id="skip-trt-reason" placeholder="e.g., Traveling, labs needed, etc."></textarea>
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Confirm Skip</button>
                    <button type="button" class="btn-secondary" data-modal="skip-trt-injection-modal">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // ====================================
        // VERSION INFORMATION
        // ====================================
        const APP_VERSION = {
            frontend: '1.3.0',
            timestamp: '2025-11-11 11:04:45'
        };

        // ====================================
        // DATA STRUCTURES & STORAGE SYSTEM
        // ====================================

        class InjectionTracker {
            constructor() {
                // App mode state
                this.currentApp = localStorage.getItem('currentApp') || 'reta'; // 'reta' or 'trt'

                this.data = {
                    // Retatrutide tracking
                    injections: [],
                    vials: [],
                    weights: [],
                    settings: {
                        injectionFrequency: 7,
                        defaultDose: 2.0,
                        prefillDoseFrom: 'last', // 'last' or 'default'
                        heightCm: null,
                        goalWeightKg: null,
                        units: 'metric',
                        lastSync: null
                    },
                    // TRT tracking
                    trtInjections: [],
                    trtVials: [],
                    trtSymptoms: [],
                    trtSettings: {
                        injectionFrequency: 3.5, // Common TRT: 2x per week
                        defaultDoseMl: 0.5,
                        defaultDoseMg: 100,
                        concentrationMgMl: 200, // Default: 200mg/ml
                        injectionSites: ['left_ventrogluteal', 'right_ventrogluteal', 'left_deltoid', 'right_deltoid', 'left_vastus_lateralis', 'right_vastus_lateralis'],
                        lastSync: null
                    }
                };
                this.charts = {};
                this.timeRange = 30; // Default to 30 days
                this._isSyncing = false;  // Guard against concurrent syncs
                this._lastSyncTime = 0;    // Debounce rapid syncs
                // Phase 1 Fix: Use persistent pending deletions manager instead of in-memory Set
                this._pendingDeletions = this.initPendingDeletions();
                // Phase 1B: Initialize sync queue
                this.syncQueue = null; // Will be initialized after auth
                // Edit mode state
                this.editMode = {
                    active: false,
                    entityType: null,  // 'injection' or 'weight'
                    entityId: null,
                    originalData: null
                };
                this.init();
            }

            // Initialize pending deletions manager
            initPendingDeletions() {
                const stored = localStorage.getItem('pending_deletions');
                const deletions = stored ? JSON.parse(stored) : {};

                // Cleanup expired deletions
                const now = Date.now();
                for (const [id, expiryTime] of Object.entries(deletions)) {
                    if (now > expiryTime) {
                        delete deletions[id];
                    }
                }
                localStorage.setItem('pending_deletions', JSON.stringify(deletions));

                // Return object with Set-like interface
                return {
                    deletions,
                    add: (id, ttlMs = 120000) => {
                        deletions[id] = Date.now() + ttlMs;
                        localStorage.setItem('pending_deletions', JSON.stringify(deletions));
                        console.log(`[PendingDeletions] Added ${id} (expires in ${ttlMs/1000}s)`);
                    },
                    has: (id) => {
                        if (!(id in deletions)) return false;
                        if (Date.now() > deletions[id]) {
                            delete deletions[id];
                            localStorage.setItem('pending_deletions', JSON.stringify(deletions));
                            return false;
                        }
                        return true;
                    },
                    delete: (id) => {
                        if (id in deletions) {
                            delete deletions[id];
                            localStorage.setItem('pending_deletions', JSON.stringify(deletions));
                            console.log(`[PendingDeletions] Removed ${id}`);
                        }
                    },
                    clear: () => {
                        Object.keys(deletions).forEach(k => delete deletions[k]);
                        localStorage.setItem('pending_deletions', JSON.stringify(deletions));
                    },
                    size: () => Object.keys(deletions).length
                };
            }

            // Initialize the application
            async init() {
                try {
                    await this.loadData();
                    this.setupEventListeners();
                    this.setupUXEnhancements(); // NEW: Setup all UX improvements
                    this.updateUI();
                    this.updateHeaderTimestamp(); // Update build timestamp in header
                    this.startCountdownTimer();
                    this.validateDataIntegrity();
                    this.updateWeeklyInsights(); // NEW: Update insights on load
                } catch (error) {
                    console.error('Error during initialization:', error);
                } finally {
                    // Always hide loading screen, even if there's an error
                    this.hideLoadingScreen();
                }
            }

            // ====================================
            // UX ENHANCEMENTS
            // ====================================

            setupUXEnhancements() {
                this.setupFAB();
                this.setupOfflineIndicator();
                this.setupPullToRefresh();
                this.setupKeyboardShortcuts();
                this.setupTimeRangeSelector();
                this.setupCountdownInteraction();
                this.setupSwipeToDelete();
                this.setupSyncStatusUI(); // Phase 1B: Sync status indicator
            }

            // Floating Action Button (context-aware)
            setupFAB() {
                const fab = document.getElementById('fab-button');
                if (fab) {
                    fab.addEventListener('click', () => {
                        this.triggerHaptic();

                        // Get active tab to determine which modal to open
                        const activeTab = document.querySelector('.nav-btn.active');
                        const currentTab = activeTab ? activeTab.dataset.tab : 'summary';

                        // Open appropriate modal based on current tab
                        switch (currentTab) {
                            case 'shots':
                                this.openModal('add-shot-modal');
                                break;
                            case 'results':
                                this.openModal('add-weight-modal');
                                break;
                            case 'inventory':
                                this.openModal('add-vial-modal');
                                break;
                            case 'summary':
                                // On summary, default to adding a shot
                                this.openModal('add-shot-modal');
                                break;
                            case 'settings':
                                // On settings, hide FAB or default to shot
                                this.openModal('add-shot-modal');
                                break;
                            default:
                                this.openModal('add-shot-modal');
                                break;
                        }
                    });
                }
            }

            // Haptic Feedback
            triggerHaptic(type = 'light') {
                if ('vibrate' in navigator) {
                    const patterns = {
                        light: 10,
                        medium: 20,
                        heavy: 30
                    };
                    navigator.vibrate(patterns[type] || 10);
                }
            }

            // Offline/Online Indicators
            setupOfflineIndicator() {
                const indicator = document.getElementById('offline-indicator');

                window.addEventListener('online', () => {
                    if (indicator) indicator.classList.remove('show');
                    this.showNotification('Back online - syncing data...', 'success');
                    this.syncFromCloud();
                });

                window.addEventListener('offline', () => {
                    if (indicator) indicator.classList.add('show');
                    this.showNotification('Offline - changes saved locally', 'warning');
                });
            }

            // Pull to Refresh (DISABLED - element removed from DOM)
            setupPullToRefresh() {
                // Disabled to prevent "Refreshing..." indicator from appearing
                // Pull-to-refresh functionality removed for better UX
                console.log('Pull-to-refresh disabled');
            }

            // Keyboard Shortcuts
            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Ignore if typing in input/textarea
                    if (e.target.matches('input, textarea')) return;

                    // Cmd/Ctrl + N: New shot
                    if ((e.metaKey || e.ctrlKey) && e.key === 'n') {
                        e.preventDefault();
                        this.triggerHaptic();
                        this.openModal('add-shot-modal');
                    }

                    // Cmd/Ctrl + W: New weight
                    if ((e.metaKey || e.ctrlKey) && e.key === 'w') {
                        e.preventDefault();
                        this.triggerHaptic();
                        this.openModal('add-weight-modal');
                    }

                    // Number keys 1-5: Switch tabs
                    if (/[1-5]/.test(e.key)) {
                        e.preventDefault();
                        const tabs = ['summary', 'shots', 'results', 'inventory', 'settings'];
                        this.switchTab(tabs[parseInt(e.key) - 1]);
                    }
                });
            }

            setupTimeRangeSelector() {
                const buttons = document.querySelectorAll('.period-btn');
                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.triggerHaptic('light');
                        buttons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        const months = btn.dataset.months;
                        // Convert months to days for internal time range
                        if (months === 'all') {
                            this.timeRange = 'all';
                        } else {
                            const monthsNum = parseInt(months);
                            this.timeRange = monthsNum * 30; // Approximate days per month
                        }

                        // Update stats with new time range
                        this.updateWeightStats();

                        // Update chart with new time range (always show combined weight + dose labels)
                        this.updateWeightChart('combined');
                    });
                });
            }

            switchChartView(view) {
                const chartView = document.getElementById('chart-view');
                const tableView = document.getElementById('table-view');

                if (view === 'table') {
                    chartView.style.display = 'none';
                    tableView.style.display = 'block';
                    this.renderWeightTable();
                } else {
                    chartView.style.display = 'block';
                    tableView.style.display = 'none';
                    this.updateWeightChart(view);
                }
            }

            renderWeightTable() {
                const tableDiv = document.getElementById('weight-table');
                if (!tableDiv) return;

                const sortedWeights = [...this.data.weights].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                let html = `
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border-color);">
                                <th style="padding: 12px; text-align: left; color: var(--text-secondary);">Date</th>
                                <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Weight (kg)</th>
                                <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Change</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                sortedWeights.forEach((weight, idx) => {
                    const date = new Date(weight.timestamp).toLocaleDateString();
                    const nextWeight = sortedWeights[idx + 1];
                    const change = nextWeight ? (weight.weight_kg - nextWeight.weight_kg).toFixed(1) : '--';
                    const changeColor = change > 0 ? 'var(--danger-color)' : change < 0 ? 'var(--success-color)' : 'var(--text-secondary)';

                    html += `
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 12px; color: var(--text-primary);">${date}</td>
                            <td style="padding: 12px; text-align: right; color: var(--text-primary); font-weight: 600;">${weight.weight_kg.toFixed(1)}</td>
                            <td style="padding: 12px; text-align: right; color: ${changeColor}; font-weight: 600;">${change !== '--' ? (change > 0 ? '+' : '') + change : '--'}</td>
                        </tr>
                    `;
                });

                html += `
                        </tbody>
                    </table>
                `;

                tableDiv.innerHTML = html;
            }

            // Enhanced Countdown Interaction
            setupCountdownInteraction() {
                const countdown = document.querySelector('.countdown-circle');
                if (countdown) {
                    countdown.addEventListener('click', () => {
                        this.triggerHaptic('medium');
                        this.openModal('add-shot-modal');
                    });
                }
            }

            // Swipe to Delete
            setupSwipeToDelete() {
                // Will be applied to dynamically created list items
                this.swipeToDeleteEnabled = true;
            }

            // Phase 1B: Sync Status UI
            setupSyncStatusUI() {
                const syncStatus = document.getElementById('sync-status');
                const syncQueueModal = document.getElementById('sync-queue-modal');
                const syncQueueClose = document.getElementById('sync-queue-close');
                const clearCompleted = document.getElementById('sync-queue-clear-completed');
                const clearFailed = document.getElementById('sync-queue-clear-failed');

                if (!syncStatus || !syncQueueModal) return;

                // Click sync status to open modal
                syncStatus.addEventListener('click', () => {
                    syncQueueModal.classList.toggle('open');
                    this.updateSyncQueueModal();
                });

                // Close modal
                syncQueueClose.addEventListener('click', () => {
                    syncQueueModal.classList.remove('open');
                });

                // Click outside to close
                document.addEventListener('click', (e) => {
                    if (!syncStatus.contains(e.target) && !syncQueueModal.contains(e.target)) {
                        syncQueueModal.classList.remove('open');
                    }
                });

                // Clear completed button
                clearCompleted.addEventListener('click', () => {
                    if (this.syncQueue) {
                        this.syncQueue.clearCompleted();
                        this.updateSyncQueueModal();
                    }
                });

                // Clear failed button
                clearFailed.addEventListener('click', () => {
                    if (this.syncQueue) {
                        this.syncQueue.clearFailed();
                        this.updateSyncQueueModal();
                    }
                });

                // Listen for queue updates
                window.addEventListener('sync-queue-updated', (e) => {
                    this.updateSyncStatus(e.detail);
                    if (syncQueueModal.classList.contains('open')) {
                        this.updateSyncQueueModal();
                    }
                });

                // Listen for sync failures
                window.addEventListener('sync-failure', (e) => {
                    console.error('[SyncUI] Sync failure:', e.detail);
                    // Could show a toast notification here
                });

                // Update status every 5 seconds
                setInterval(() => {
                    if (this.syncQueue) {
                        const status = this.syncQueue.getStatus();
                        this.updateSyncStatus(status);
                    }
                }, 5000);

                // Initial update
                if (this.syncQueue) {
                    const status = this.syncQueue.getStatus();
                    this.updateSyncStatus(status);
                }
            }

            updateSyncStatus(status) {
                const syncStatusEl = document.getElementById('sync-status');
                const syncText = syncStatusEl.querySelector('.sync-text');
                const syncBadge = document.getElementById('sync-badge');

                if (!syncStatusEl || !syncText || !syncBadge) return;

                // Remove all state classes
                syncStatusEl.classList.remove('synced', 'syncing', 'pending', 'error', 'offline');

                // Determine state
                if (!navigator.onLine) {
                    syncStatusEl.classList.add('offline');
                    syncText.textContent = 'Offline';
                    syncBadge.textContent = status.pending > 0 ? status.pending : '';
                } else if (status.isProcessing) {
                    syncStatusEl.classList.add('syncing');
                    syncText.textContent = 'Syncing...';
                    syncBadge.textContent = '';
                } else if (status.failed > 0) {
                    syncStatusEl.classList.add('error');
                    syncText.textContent = 'Sync Error';
                    syncBadge.textContent = status.failed;
                } else if (status.pending > 0) {
                    syncStatusEl.classList.add('pending');
                    syncText.textContent = `${status.pending} Pending`;
                    syncBadge.textContent = status.pending;
                } else {
                    syncStatusEl.classList.add('synced');
                    syncText.textContent = 'Synced';
                    syncBadge.textContent = '';
                }
            }

            updateSyncQueueModal() {
                const syncQueueBody = document.getElementById('sync-queue-body');
                if (!syncQueueBody || !this.syncQueue) return;

                const operations = this.syncQueue.getOperations();

                if (operations.length === 0) {
                    syncQueueBody.innerHTML = '<div class="sync-queue-empty">No pending operations</div>';
                    return;
                }

                syncQueueBody.innerHTML = operations.map(op => {
                    const entityName = op.entity.charAt(0).toUpperCase() + op.entity.slice(1);
                    const actionName = op.type.charAt(0).toUpperCase() + op.type.slice(1);
                    const timeSince = this.formatTimeSince(op.addedAt);

                    return `
                        <div class="sync-queue-item ${op.status}">
                            <div class="sync-queue-item-header">
                                <span class="sync-queue-item-type">${actionName} ${entityName}</span>
                                <span class="sync-queue-item-status ${op.status}">${op.status}</span>
                            </div>
                            <div class="sync-queue-item-details">
                                ${op.retryCount > 0 ? `Attempt ${op.retryCount + 1}/${this.syncQueue.retryDelays.length}  ` : ''}
                                ${timeSince}
                            </div>
                            ${op.error ? `<div class="sync-queue-item-error">Error: ${op.error}</div>` : ''}
                            ${op.status === 'failed' ? `
                                <div class="sync-queue-item-actions">
                                    <button class="sync-queue-item-retry" onclick="app.retrySyncOperation('${op.id}')">
                                        Retry Now
                                    </button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            }

            retrySyncOperation(operationId) {
                if (this.syncQueue) {
                    this.syncQueue.retryOperation(operationId);
                    this.updateSyncQueueModal();
                }
            }

            formatTimeSince(timestamp) {
                const seconds = Math.floor((Date.now() - timestamp) / 1000);
                if (seconds < 60) return `${seconds}s ago`;
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                return `${hours}h ago`;
            }

            addSwipeToDeleteHandlers(element) {
                if (!this.swipeToDeleteEnabled) return;

                let touchStartX = 0;
                let touchEndX = 0;
                const swipeThreshold = 80;

                element.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    element.classList.add('swiping');
                }, { passive: true });

                element.addEventListener('touchmove', (e) => {
                    touchEndX = e.touches[0].clientX;
                    const swipeDistance = touchStartX - touchEndX;

                    if (swipeDistance > 0 && swipeDistance < 100) {
                        element.style.transform = `translateX(-${swipeDistance}px)`;
                    }
                }, { passive: true });

                element.addEventListener('touchend', () => {
                    element.classList.remove('swiping');
                    const swipeDistance = touchStartX - touchEndX;

                    if (swipeDistance > swipeThreshold) {
                        element.classList.add('swiped');
                        element.style.transform = `translateX(-80px)`;
                        this.triggerHaptic('medium');
                    } else {
                        element.classList.remove('swiped');
                        element.style.transform = '';
                    }

                    touchStartX = 0;
                    touchEndX = 0;
                }, { passive: true });
            }

            // Weekly Insights
            updateWeeklyInsights() {
                const insightsCard = document.getElementById('weekly-insights');
                if (!insightsCard) return;

                const now = new Date();
                const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

                // Get this week's weights
                const weekWeights = this.data.weights.filter(w =>
                    new Date(w.timestamp) >= oneWeekAgo
                ).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                // Get this week's injections
                const weekInjections = this.data.injections.filter(i =>
                    new Date(i.timestamp) >= oneWeekAgo
                );

                if (weekWeights.length < 2 && weekInjections.length === 0) {
                    insightsCard.style.display = 'none';
                    return;
                }

                insightsCard.style.display = 'block';

                // Weight change
                if (weekWeights.length >= 2) {
                    const firstWeight = weekWeights[0].weight_kg;
                    const lastWeight = weekWeights[weekWeights.length - 1].weight_kg;
                    const change = lastWeight - firstWeight;

                    document.getElementById('insight-weight-change').textContent =
                        `${change >= 0 ? '+' : ''}${change.toFixed(1)} kg`;

                    const trendEl = document.getElementById('insight-weight-trend');
                    if (change < 0) {
                        trendEl.textContent = ` ${Math.abs(change).toFixed(1)} kg`;
                        trendEl.classList.remove('negative');
                    } else {
                        trendEl.textContent = ` ${change.toFixed(1)} kg`;
                        trendEl.classList.add('negative');
                    }
                } else {
                    document.getElementById('insight-weight-change').textContent = '--';
                    document.getElementById('insight-weight-trend').textContent = '--';
                }

                // Average dose
                if (weekInjections.length > 0) {
                    const avgDose = weekInjections.reduce((sum, inj) => sum + inj.dose_mg, 0) / weekInjections.length;
                    document.getElementById('insight-avg-dose').textContent =
                        `${avgDose.toFixed(1)} mg`;
                } else {
                    document.getElementById('insight-avg-dose').textContent = '--';
                }
            }

            // ====================================
            // DATA MANAGEMENT
            // ====================================

            async loadData() {
                try {
                    const stored = localStorage.getItem('injectionTrackerData');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.data = { ...this.data, ...data };

                        // Normalize vial data formats (fix mixed camelCase/snake_case)
                        this.normalizeVialData();

                        // Migrate old injection site naming to consistent format
                        this.migrateInjectionSiteNames();
                    } else {
                        // Check if we should skip sample data (nuclear reset)
                        const skipSampleData = localStorage.getItem('__skip_sample_data__');
                        if (skipSampleData === 'true') {
                            console.log(' Skipping sample data load (nuclear reset)');
                            localStorage.removeItem('__skip_sample_data__');
                        } else {
                            // Check if we should load sample data (not in test mode)
                            const urlParams = new URLSearchParams(window.location.search);
                            if (!urlParams.get('test')) {
                                // Load sample data for demo purposes
                                this.loadSampleData();
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error loading data:', error);
                    // Check if we should skip sample data (nuclear reset)
                    const skipSampleData = localStorage.getItem('__skip_sample_data__');
                    if (skipSampleData !== 'true') {
                        // Load sample data if there's an error (unless in test mode)
                        const urlParams = new URLSearchParams(window.location.search);
                        if (!urlParams.get('test')) {
                            this.loadSampleData();
                        }
                    }
                }
            }

            /**
             * Normalize vial data to consistent snake_case format
             * Fixes mixed API format (camelCase) and app format (snake_case)
             */
            normalizeVialData() {
                if (!this.data.vials || this.data.vials.length === 0) return;

                this.data.vials = this.data.vials.map(vial => {
                    // If vial is in API format (has 'id' instead of 'vial_id'), convert it
                    if (vial.id && !vial.vial_id) {
                        console.log('Converting vial from API format to app format:', vial.id);
                        return {
                            vial_id: vial.id,
                            order_date: vial.startDate,
                            total_mg: vial.initialVolumeMl * vial.concentrationMgPerMl,
                            bac_water_ml: vial.initialVolumeMl,
                            concentration_mg_per_ml: vial.concentrationMgPerMl,
                            current_volume_ml: vial.currentVolumeMl,
                            used_volume_ml: vial.usedVolumeMl,
                            status: vial.status,
                            supplier: vial.source || '',
                            notes: vial.notes || '',
                            reconstitution_date: vial.startDate
                        };
                    }
                    // Already in correct format, but sync property names (Hotfix)
                    // Ensure both current_volume_ml and remaining_ml are synced
                    if (vial.remaining_ml !== undefined && vial.current_volume_ml === undefined) {
                        vial.current_volume_ml = vial.remaining_ml;
                        console.log(`Synced current_volume_ml for vial ${vial.vial_id || vial.id}`);
                    } else if (vial.current_volume_ml !== undefined && vial.remaining_ml === undefined) {
                        vial.remaining_ml = vial.current_volume_ml;
                        console.log(`Synced remaining_ml for vial ${vial.vial_id || vial.id}`);
                    }

                    // Fix missing expiration dates for dry stock vials
                    if (vial.status === 'dry_stock' && !vial.expiration_date && vial.order_date) {
                        vial.expiration_date = this.calculateExpirationDate(null, vial.order_date);
                        console.log(`Fixed expiration for dry stock vial ${vial.vial_id || vial.id}`);
                    }

                    return vial;
                });

                console.log('Vial data normalized');
            }

            /**
             * Migrate old injection site naming format to consistent format
             * Old format: left_abdomen, right_abdomen, left_thigh, right_thigh
             * New format: abdomen_left, abdomen_right, thigh_left, thigh_right
             */
            migrateInjectionSiteNames() {
                if (!this.data.injections || this.data.injections.length === 0) return;

                const siteMapping = {
                    'left_abdomen': 'abdomen_left',
                    'right_abdomen': 'abdomen_right',
                    'left_thigh': 'thigh_left',
                    'right_thigh': 'thigh_right',
                    'left_arm': 'left_arm',  // No change
                    'right_arm': 'right_arm',  // No change
                    'abdomen': 'abdomen',  // No change
                    'thigh': 'thigh'  // No change
                };

                let migratedCount = 0;
                this.data.injections = this.data.injections.map(injection => {
                    const oldSite = injection.injection_site;
                    if (siteMapping[oldSite] && siteMapping[oldSite] !== oldSite) {
                        injection.injection_site = siteMapping[oldSite];
                        migratedCount++;
                        console.log(`Migrated injection site: ${oldSite}  ${injection.injection_site}`);
                    }
                    return injection;
                });

                if (migratedCount > 0) {
                    console.log(`Migrated ${migratedCount} injection site names to consistent format`);
                    this.saveData();  // Save migrated data
                }
            }

            // ====================================
            // VIAL HELPER METHODS (Phase 1 Fix)
            // ====================================

            /**
             * Get vial ID consistently regardless of format
             * Handles both vial_id (frontend) and id (API) formats
             */
            getVialId(vial) {
                return vial.vial_id || vial.id;
            }

            /**
             * Find vial by ID, handling both frontend and API formats
             */
            findVialById(vialId) {
                if (!vialId) return null;
                return this.data.vials.find(v => this.getVialId(v) === vialId);
            }

            // ====================================
            // DATA MERGE HELPER
            // ====================================

            mergeArrays(localData, cloudData, keyField) {
                // Intelligent merge: prefer local data for items not yet in cloud
                const merged = new Map();

                // First, add all cloud items (source of truth for synced data)
                // BUT exclude items that are pending deletion
                cloudData.forEach(item => {
                    const itemId = item[keyField];
                    if (!this._pendingDeletions.has(itemId)) {
                        merged.set(itemId, item);
                    } else {
                        console.log(`Skipping ${itemId} from cloud sync - pending deletion`);
                    }
                });

                // Then add local items that aren't in cloud yet
                // These are likely pending sync or were just added
                localData.forEach(item => {
                    const itemId = item[keyField];
                    const cloudItem = merged.get(itemId);
                    if (!cloudItem && !this._pendingDeletions.has(itemId)) {
                        // Item exists locally but not in cloud - keep it (pending sync)
                        merged.set(itemId, item);
                    }
                    // If item exists in cloud, cloud version is source of truth
                });

                return Array.from(merged.values()).sort(
                    (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
                );
            }

            async syncFromCloud() {
                // Guard against concurrent syncs
                if (this._isSyncing) {
                    console.log('Sync already in progress, skipping...');
                    return;
                }

                // Debounce rapid syncs (wait at least 2 seconds between syncs)
                const now = Date.now();
                if (now - this._lastSyncTime < 2000) {
                    console.log('Sync called too soon after previous sync, skipping...');
                    return;
                }

                // Check if user is authenticated
                if (!authManager || !authManager.isAuthenticated()) {
                    console.log('User not authenticated, skipping cloud sync');
                    return;
                }

                this._isSyncing = true;
                this._lastSyncTime = now;

                try {
                    console.log('Syncing data from cloud...');

                    // Fetch all data from API
                    const [injectionsAPI, weightsAPI, vialsAPI] = await Promise.all([
                        apiClient.getInjections(),
                        apiClient.getWeights(),
                        apiClient.getVials()
                    ]);

                    console.log(`Fetched from cloud: ${injectionsAPI.length} injections, ${weightsAPI.length} weights, ${vialsAPI.length} vials`);

                    // Map API format (camelCase) to app format (snake_case)
                    const cloudInjections = injectionsAPI.map(inj => ({
                        id: inj.id,
                        timestamp: inj.timestamp,
                        dose_mg: inj.doseMg,
                        injection_site: inj.site,
                        vial_id: inj.vialId,
                        notes: inj.notes || ''
                    }));

                    const cloudWeights = weightsAPI.map(wt => ({
                        id: wt.id,
                        timestamp: wt.timestamp,
                        weight_kg: wt.weightKg,
                        notes: wt.notes || ''
                    }));

                    // Note: API now returns snake_case directly, no transformation needed
                    const cloudVials = vialsAPI.map(vial => ({
                        vial_id: vial.vial_id,
                        order_date: vial.order_date,
                        reconstitution_date: vial.reconstitution_date,
                        expiration_date: vial.expiration_date,
                        total_mg: vial.total_mg,
                        bac_water_ml: vial.bac_water_ml,
                        concentration_mg_ml: vial.concentration_mg_ml,
                        current_volume_ml: vial.current_volume_ml,
                        remaining_ml: vial.current_volume_ml,  // Sync both properties
                        status: vial.status,
                        supplier: vial.supplier || '',
                        lot_number: vial.lot_number || '',
                        doses_used: vial.doses_used || 0,
                        notes: vial.notes || '',
                        used_volume_ml: vial.used_volume_ml
                    }));

                    // MERGE cloud data with local data (prevents losing pending items)
                    this.data.injections = this.mergeArrays(this.data.injections, cloudInjections, 'id');
                    this.data.weights = this.mergeArrays(this.data.weights, cloudWeights, 'id');
                    this.data.vials = this.mergeArrays(this.data.vials, cloudVials, 'vial_id');

                    // Save to localStorage (without showing indicator - this is a sync, not a user save)
                    this.saveData(false);

                    // Update UI
                    this.updateUI();

                    console.log('Cloud sync complete');
                } catch (error) {
                    console.error('Error syncing from cloud:', error);
                    // Don't rethrow - sync failures should be silent
                } finally {
                    this._isSyncing = false;
                }
            }

            /**
             * Sync settings from cloud
             */
            async syncSettingsFromCloud() {
                // Check if user is authenticated
                if (!authManager || !authManager.isAuthenticated()) {
                    return;
                }

                try {
                    console.log('Syncing settings from cloud...');
                    const cloudSettings = await apiClient.getSettings();

                    // Only update if cloud has non-null values
                    if (cloudSettings.heightCm !== null && cloudSettings.heightCm !== undefined) {
                        this.data.settings.heightCm = cloudSettings.heightCm;
                    }
                    if (cloudSettings.goalWeightKg !== null && cloudSettings.goalWeightKg !== undefined) {
                        this.data.settings.goalWeightKg = cloudSettings.goalWeightKg;
                    }
                    if (cloudSettings.defaultDose !== null && cloudSettings.defaultDose !== undefined) {
                        this.data.settings.defaultDose = cloudSettings.defaultDose;
                    }
                    if (cloudSettings.injectionFrequencyDays !== null && cloudSettings.injectionFrequencyDays !== undefined) {
                        this.data.settings.injectionFrequencyDays = cloudSettings.injectionFrequencyDays;
                    }

                    // Save to localStorage
                    this.saveData(false);

                    // Update UI elements with synced settings
                    if (this.data.settings.heightCm) {
                        const heightInput = document.getElementById('user-height');
                        if (heightInput) heightInput.value = this.data.settings.heightCm;
                    }
                    if (this.data.settings.goalWeightKg) {
                        const goalWeightInput = document.getElementById('goal-weight');
                        if (goalWeightInput) goalWeightInput.value = this.data.settings.goalWeightKg;
                    }

                    // Update dependent calculations
                    this.updateBMI();
                    this.updateGoalProgress();

                    console.log('Settings synced from cloud');
                } catch (error) {
                    console.error('Error syncing settings from cloud:', error);
                }
            }

            /**
             * Sync settings to cloud
             */
            async syncSettingsToCloud() {
                // Check if user is authenticated
                if (!authManager || !authManager.isAuthenticated()) {
                    return;
                }

                try {
                    console.log('Syncing settings to cloud...');
                    await apiClient.updateSettings({
                        defaultDose: this.data.settings.defaultDose || 2.0,
                        injectionFrequencyDays: this.data.settings.injectionFrequencyDays || 7,
                        heightCm: this.data.settings.heightCm || null,
                        goalWeightKg: this.data.settings.goalWeightKg || null,
                        prefillDoseFrom: this.data.settings.prefillDoseFrom || 'lastShot',
                        trtSettings: {
                            injectionFrequency: this.data.trtSettings.injectionFrequency || 3.5,
                            defaultDoseMl: this.data.trtSettings.defaultDoseMl || 0.5,
                            defaultDoseMg: this.data.trtSettings.defaultDoseMg || 100,
                            concentrationMgMl: this.data.trtSettings.concentrationMgMl || 200,
                            injectionSites: this.data.trtSettings.injectionSites || [
                                'left_ventrogluteal', 'right_ventrogluteal',
                                'left_deltoid', 'right_deltoid',
                                'left_vastus_lateralis', 'right_vastus_lateralis'
                            ],
                        },
                    });
                    console.log('Settings synced to cloud successfully');
                } catch (error) {
                    console.error('Error syncing settings to cloud:', error);
                }
            }

            loadSampleData() {
                const now = new Date();

                // Add a sample vial
                const sampleVial = {
                    order_date: new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 15 days ago
                    supplier: 'Sample Pharmacy',
                    lot_number: 'LOT123456',
                    total_mg: 15,
                    bac_water_ml: 1.5,
                    reconstitution_date: new Date(now.getTime() - 10 * 24 * 60 * 60 * 1000).toISOString() // 10 days ago
                };

                this.addVial(sampleVial);

                // Add sample weights
                for (let i = 0; i < 8; i++) {
                    const weightDate = new Date(now.getTime() - (i * 3.5 * 24 * 60 * 60 * 1000)); // Every 3.5 days
                    this.addWeight({
                        timestamp: weightDate.toISOString(),
                        weight_kg: 85 - (i * 0.3) + (Math.random() * 0.4 - 0.2), // Gradual weight loss with some variation
                        source: 'manual'
                    });
                }

                // Add sample injections (use full vial to make it realistic)
                const sampleDoses = [2.0, 2.5, 3.0, 3.5, 4.0]; // Total = 15mg (use full vial)
                for (let i = 0; i < sampleDoses.length; i++) {
                    const injectionDate = new Date(now.getTime() - (i * 7 * 24 * 60 * 60 * 1000)); // Weekly
                    const vialId = this.data.vials[0]?.vial_id;
                    if (vialId) {
                        this.data.injections.push({
                            id: this.generateId(),
                            timestamp: injectionDate.toISOString(),
                            dose_mg: sampleDoses[i],
                            injection_site: ['abdomen_right', 'abdomen_left', 'thigh_right', 'thigh_left', 'right_arm'][i % 5],
                            vial_id: vialId,
                            weight_kg: null,
                            weight_source: 'manual',
                            notes: i === 0 ? 'Final injection - vial finished' : i === sampleDoses.length - 1 ? 'First injection - starting treatment' : '',
                            medication_level_at_injection: i > 0 ? sampleDoses[i-1] : 0
                        });
                        this.updateVialUsage(vialId, sampleDoses[i]);
                    }
                }

                this.data.injections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Save the sample data to localStorage
                this.saveData();
            }

            async saveData(showIndicator = true) {
                try {
                    if (window.backupManager) {
                        await backupManager.saveData(this.data);
                    } else {
                        // Fallback to simple localStorage if backup manager not ready
                        localStorage.setItem('injectionTrackerData', JSON.stringify(this.data));
                    }
                    if (showIndicator) {
                        this.showSaveIndicator();
                    }
                } catch (error) {
                    console.error('Error saving data:', error);
                }
            }

            showSaveIndicator() {
                const indicator = document.getElementById('save-indicator');
                if (indicator) {
                    indicator.style.display = 'block';
                    indicator.style.animation = 'fadeInScale 0.2s ease-out';

                    clearTimeout(this.saveIndicatorTimeout);
                    this.saveIndicatorTimeout = setTimeout(() => {
                        indicator.style.animation = 'fadeOutScale 0.2s ease-in';
                        setTimeout(() => {
                            indicator.style.display = 'none';
                        }, 200);
                    }, 1500);
                }
            }

            // ====================================
            // INJECTION MANAGEMENT
            // ====================================

            async addInjection(injection) {
                const newInjection = {
                    id: this.generateId(),
                    timestamp: injection.timestamp || new Date().toISOString(),
                    dose_mg: parseFloat(injection.dose_mg),
                    injection_site: injection.injection_site,
                    vial_id: injection.vial_id,
                    notes: injection.notes || '',
                    medication_level_at_injection: this.calculateCurrentMedicationLevel(injection.timestamp).value || 0,
                    skipped: injection.skipped || false,
                    planned_dose_mg: injection.planned_dose_mg || null
                };

                this.data.injections.push(newInjection);
                this.data.injections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Skip vial usage update if this is a skipped injection
                if (!injection.skipped) {
                    await this.updateVialUsage(injection.vial_id, injection.dose_mg);
                }

                this.saveData();
                this.updateUI();

                // Check for milestones and celebrate
                this.checkMilestones();

                // Push to sync queue if authenticated (Phase 1B: Reliable sync with retry)
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'create',
                        entity: 'injection',
                        localId: newInjection.id,
                        data: {
                            id: newInjection.id,
                            timestamp: newInjection.timestamp,
                            doseMg: newInjection.dose_mg,
                            site: newInjection.injection_site,
                            vialId: newInjection.vial_id,
                            notes: newInjection.notes,
                            skipped: newInjection.skipped || false,
                            plannedDoseMg: newInjection.planned_dose_mg || null
                        }
                    });
                    console.log('Injection added to sync queue');
                }
            }

            async updateInjection(injectionId, updates) {
                // Find existing injection
                const injectionIndex = this.data.injections.findIndex(inj => inj.id === injectionId);
                if (injectionIndex === -1) {
                    throw new Error('Injection not found');
                }

                const oldInjection = this.data.injections[injectionIndex];
                const oldDose = oldInjection.dose_mg;
                const oldVialId = oldInjection.vial_id;

                // Update injection with new data
                const updatedInjection = {
                    ...oldInjection,
                    timestamp: updates.timestamp || oldInjection.timestamp,
                    dose_mg: parseFloat(updates.dose_mg),
                    injection_site: updates.injection_site,
                    vial_id: updates.vial_id,
                    notes: updates.notes || '',
                    medication_level_at_injection: this.calculateCurrentMedicationLevel(updates.timestamp || oldInjection.timestamp).value || 0
                };

                this.data.injections[injectionIndex] = updatedInjection;
                this.data.injections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Handle vial usage changes
                if (oldVialId === updates.vial_id) {
                    // Same vial, adjust usage
                    if (oldDose !== updates.dose_mg) {
                        await this.reverseVialUsage(oldVialId, oldDose);
                        await this.updateVialUsage(updates.vial_id, updates.dose_mg);
                    }
                } else {
                    // Different vial, reverse old and apply new
                    await this.reverseVialUsage(oldVialId, oldDose);
                    await this.updateVialUsage(updates.vial_id, updates.dose_mg);
                }

                this.saveData();
                this.updateUI();

                // Push to sync queue if authenticated
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'update',
                        entity: 'injection',
                        localId: injectionId,
                        data: {
                            id: injectionId,
                            timestamp: updatedInjection.timestamp,
                            doseMg: updatedInjection.dose_mg,
                            site: updatedInjection.injection_site,
                            vialId: updatedInjection.vial_id,
                            notes: updatedInjection.notes
                        }
                    });
                    console.log('Injection update added to sync queue');
                }
            }

            async updateVialUsage(vialId, doseMg) {
                const vial = this.findVialById(vialId);
                if (vial) {
                    const doseVolumeML = doseMg / vial.concentration_mg_ml;
                    vial.remaining_ml = Math.max(0, vial.remaining_ml - doseVolumeML);
                    vial.current_volume_ml = vial.remaining_ml; // Sync property for consistency (Hotfix)
                    vial.doses_used++;

                    // Check if vial has less than next required dose
                    const plannedDose = parseFloat(document.getElementById('planned-dose')?.value || 4.0);
                    const remainingMg = vial.remaining_ml * vial.concentration_mg_ml;

                    if (remainingMg < plannedDose && remainingMg > 0) {
                        // Mark vial as empty if it can't provide the next dose
                        vial.status = 'insufficient';
                        vial.remaining_ml = 0;
                        vial.current_volume_ml = 0; // Sync property (Hotfix)
                    } else if (vial.remaining_ml <= 0) {
                        vial.status = 'empty';
                    }

                    // Push vial update to sync queue (Phase 1B: Reliable sync with retry)
                    if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                        this.syncQueue.add({
                            type: 'update',
                            entity: 'vial',
                            localId: vialId,
                            data: {
                                id: vialId,
                                currentVolumeMl: vial.remaining_ml,
                                usedVolumeMl: vial.bac_water_ml - vial.remaining_ml,
                                status: vial.status
                            }
                        });
                        console.log('Vial update added to sync queue');
                    }
                }
            }

            async reverseVialUsage(vialId, doseMg) {
                const vial = this.findVialById(vialId);
                if (!vial) {
                    console.log(`Vial ${vialId} not found for usage reversal`);
                    return;
                }

                const concentration = vial.concentration_mg_per_ml || vial.concentration_mg_ml;
                const doseVolumeML = doseMg / concentration;

                // Add back the dose volume to current_volume_ml
                const currentVol = vial.current_volume_ml || vial.remaining_ml || 0;
                const newVolume = Math.min(vial.bac_water_ml, currentVol + doseVolumeML);
                vial.current_volume_ml = newVolume;
                vial.remaining_ml = newVolume;  // Sync both properties

                // Update used_volume_ml
                vial.used_volume_ml = vial.bac_water_ml - newVolume;

                // Update status based on new remaining amount
                if (vial.current_volume_ml > 0 && (vial.status === 'empty' || vial.status === 'finished')) {
                    vial.status = 'active';
                }

                console.log(`Reversed ${doseMg}mg (${doseVolumeML.toFixed(2)}ml) from vial ${vialId}. New volume: ${newVolume.toFixed(2)}ml`);

                // Save locally
                this.saveData();

                // Sync vial update to cloud if authenticated
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        await apiClient.updateVial(vialId, {
                            currentVolumeMl: vial.current_volume_ml,
                            usedVolumeMl: vial.used_volume_ml,
                            status: vial.status
                        });
                        console.log('Vial usage reversal synced to cloud successfully');
                    } catch (error) {
                        console.error('Failed to sync vial usage reversal to cloud:', error);
                        // Still updated locally, so don't block the user
                    }
                }
            }

            // ====================================
            // VIAL MANAGEMENT
            // ====================================

            async addVial(vial) {
                const concentration = vial.total_mg / vial.bac_water_ml;
                const newVial = {
                    vial_id: this.generateId(),
                    order_date: vial.order_date,
                    supplier: vial.supplier || '',
                    lot_number: vial.lot_number || '',
                    total_mg: parseFloat(vial.total_mg),
                    bac_water_ml: parseFloat(vial.bac_water_ml),
                    concentration_mg_ml: concentration,
                    reconstitution_date: vial.reconstitution_date,
                    expiration_date: this.calculateExpirationDate(vial.reconstitution_date, vial.order_date),
                    remaining_ml: parseFloat(vial.bac_water_ml),
                    doses_used: 0,
                    status: 'active'
                };

                this.data.vials.push(newVial);
                this.data.vials.sort((a, b) => new Date(b.reconstitution_date) - new Date(a.reconstitution_date));
                this.saveData();
                this.updateUI();

                // Push to sync queue if authenticated (Phase 1B: Reliable sync with retry)
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'create',
                        entity: 'vial',
                        localId: newVial.vial_id,
                        data: {
                            id: newVial.vial_id,
                            startDate: newVial.order_date,
                            initialVolumeMl: newVial.bac_water_ml,
                            concentrationMgPerMl: newVial.concentration_mg_ml,
                            currentVolumeMl: newVial.remaining_ml,
                            usedVolumeMl: 0,
                            status: newVial.status,
                            source: newVial.supplier || '',
                            notes: ''
                        }
                    });
                    console.log('Vial added to sync queue');
                }
            }

            async updateVial(vialId, updates) {
                // Find existing vial
                const vialIndex = this.data.vials.findIndex(v => v.id === vialId || v.vial_id === vialId);
                if (vialIndex === -1) {
                    throw new Error('Vial not found');
                }

                const oldVial = this.data.vials[vialIndex];

                // Update vial with new data (only update basic properties, not status/volume/doses)
                const updatedVial = {
                    ...oldVial,
                    order_date: updates.order_date || oldVial.order_date,
                    supplier: updates.supplier || oldVial.supplier,
                    total_mg: parseFloat(updates.total_mg) || oldVial.total_mg,
                    quantity: parseInt(updates.quantity) || oldVial.quantity || 1,
                    lot_number: updates.lot_number || oldVial.lot_number || ''
                };

                this.data.vials[vialIndex] = updatedVial;
                this.saveData();
                this.updateUI();

                // Push to sync queue if authenticated
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'update',
                        entity: 'vial',
                        localId: vialId,
                        data: {
                            id: vialId,
                            startDate: updatedVial.order_date,
                            initialVolumeMl: updatedVial.bac_water_ml || 0,
                            concentrationMgPerMl: updatedVial.concentration_mg_ml || 0,
                            currentVolumeMl: updatedVial.remaining_ml || 0,
                            usedVolumeMl: (updatedVial.bac_water_ml || 0) - (updatedVial.remaining_ml || 0),
                            status: updatedVial.status,
                            source: updatedVial.supplier || '',
                            notes: updatedVial.notes || ''
                        }
                    });
                    console.log('Vial update added to sync queue');
                }
            }

            calculateExpirationDate(reconstitutionDate, orderDate) {
                if (reconstitutionDate) {
                    // Reconstituted peptide lasts 30 days in refrigerator
                    const date = new Date(reconstitutionDate);
                    date.setDate(date.getDate() + 30);
                    return date.toISOString();
                } else if (orderDate) {
                    // Lyophilized powder lasts 2 years in freezer
                    const date = new Date(orderDate);
                    date.setFullYear(date.getFullYear() + 2);
                    return date.toISOString();
                }
                // Default to 2 years from now
                const date = new Date();
                date.setFullYear(date.getFullYear() + 2);
                return date.toISOString();
            }

            calculateDaysRemaining(totalDoses) {
                if (totalDoses <= 0) return 0;

                const today = new Date();
                const injectionFrequency = this.data.settings.injectionFrequency || 7;

                // Find the last injection date
                let nextDoseDate = new Date(today);

                if (this.data.injections && this.data.injections.length > 0) {
                    // Get the most recent injection
                    const sortedInjections = [...this.data.injections].sort((a, b) =>
                        new Date(b.timestamp) - new Date(a.timestamp)
                    );
                    const lastInjection = new Date(sortedInjections[0].timestamp);

                    // Calculate next dose based on last injection + frequency
                    nextDoseDate = new Date(lastInjection);
                    nextDoseDate.setDate(lastInjection.getDate() + injectionFrequency);

                    // If next dose is in the past, calculate from today
                    if (nextDoseDate < today) {
                        nextDoseDate = new Date(today);
                        nextDoseDate.setDate(today.getDate() + injectionFrequency);
                    }
                } else {
                    // No injections yet, assume starting from today
                    nextDoseDate.setDate(today.getDate() + injectionFrequency);
                }

                // Calculate when the last dose will be taken
                const totalDaysOfMedication = (totalDoses - 1) * injectionFrequency;
                const lastDoseDate = new Date(nextDoseDate);
                lastDoseDate.setDate(nextDoseDate.getDate() + totalDaysOfMedication);

                // Calculate days from today to last dose
                const daysRemaining = Math.ceil((lastDoseDate - today) / (1000 * 60 * 60 * 24));
                return Math.max(0, daysRemaining);
            }

            getActiveVial() {
                const plannedDose = parseFloat(document.getElementById('planned-dose')?.value || 4.0);
                return this.data.vials.find(v => {
                    const remainingMg = v.remaining_ml * v.concentration_mg_ml;
                    return v.status === 'active' &&
                           remainingMg >= plannedDose && // Must have enough for next dose
                           new Date(v.expiration_date) > new Date();
                });
            }

            // ====================================
            // WEIGHT MANAGEMENT
            // ====================================

            async addWeight(weight) {
                const newWeight = {
                    id: this.generateId(),
                    timestamp: weight.timestamp || new Date().toISOString(),
                    weight_kg: parseFloat(weight.weight_kg),
                    weight_lbs: this.kgToLbs(parseFloat(weight.weight_kg)),
                    source: weight.source || 'manual',
                    bmi: weight.bmi || null,
                    body_fat_percentage: weight.body_fat_percentage || null
                };

                this.data.weights.push(newWeight);
                this.data.weights.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                this.saveData();
                this.updateUI();

                // Check for milestones and celebrate
                this.checkMilestones();

                // Push to sync queue if authenticated (Phase 1B: Reliable sync with retry)
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'create',
                        entity: 'weight',
                        localId: newWeight.id,
                        data: {
                            id: newWeight.id,
                            timestamp: newWeight.timestamp,
                            weightKg: newWeight.weight_kg,
                            source: newWeight.source,
                            bmi: newWeight.bmi,
                            bodyFatPercentage: newWeight.body_fat_percentage
                        }
                    });
                    console.log('Weight added to sync queue');
                }
            }

            async updateWeight(weightId, updates) {
                // Find existing weight
                const weightIndex = this.data.weights.findIndex(w => (w.id || w.timestamp) === weightId);
                if (weightIndex === -1) {
                    throw new Error('Weight entry not found');
                }

                const oldWeight = this.data.weights[weightIndex];

                // Update weight with new data
                const updatedWeight = {
                    ...oldWeight,
                    timestamp: updates.timestamp || oldWeight.timestamp,
                    weight_kg: parseFloat(updates.weight_kg),
                    weight_lbs: this.kgToLbs(parseFloat(updates.weight_kg)),
                    body_fat_percentage: updates.body_fat_percentage || null
                };

                this.data.weights[weightIndex] = updatedWeight;
                this.data.weights.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                this.saveData();
                this.updateUI();

                // Push to sync queue if authenticated
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'update',
                        entity: 'weight',
                        localId: weightId,
                        data: {
                            id: weightId,
                            timestamp: updatedWeight.timestamp,
                            weightKg: updatedWeight.weight_kg,
                            source: updatedWeight.source,
                            bmi: updatedWeight.bmi,
                            bodyFatPercentage: updatedWeight.body_fat_percentage
                        }
                    });
                    console.log('Weight update added to sync queue');
                }
            }

            // ====================================
            // MEDICATION LEVEL CALCULATIONS
            // ====================================

            calculateCurrentMedicationLevel(currentTime = new Date().toISOString()) {
                const medicationHalfLife = 165; // 165 hours (about 7 days) - adjust as needed

                // Phase 2: Validate input data
                const injections = this.data.injections || [];
                if (injections.length === 0) {
                    return {
                        success: false,
                        error: 'No injection data available',
                        value: 0,
                        validCount: 0,
                        totalCount: 0
                    };
                }

                // Validate current time
                const currentTimestamp = new Date(currentTime).getTime();
                if (isNaN(currentTimestamp)) {
                    return {
                        success: false,
                        error: 'Invalid current time',
                        value: 0
                    };
                }

                let totalLevel = 0;
                let validCount = 0;
                let invalidCount = 0;

                injections.forEach(injection => {
                    // Phase 2: Validate injection has required fields
                    if (!injection.timestamp || !injection.dose_mg) {
                        console.warn('[MedicationLevel] Invalid injection:', injection.id,
                            'missing timestamp or dose_mg');
                        invalidCount++;
                        return; // Skip this injection
                    }

                    const injectionTime = new Date(injection.timestamp).getTime();

                    // Validate injection timestamp
                    if (isNaN(injectionTime)) {
                        console.warn('[MedicationLevel] Invalid timestamp for injection:', injection.id);
                        invalidCount++;
                        return;
                    }

                    // Validate dose is positive number
                    const doseMg = parseFloat(injection.dose_mg);
                    if (isNaN(doseMg) || doseMg <= 0) {
                        console.warn('[MedicationLevel] Invalid dose for injection:', injection.id, doseMg);
                        invalidCount++;
                        return;
                    }

                    const hoursElapsed = (currentTimestamp - injectionTime) / (1000 * 60 * 60);

                    if (hoursElapsed >= 0) {
                        const remainingLevel = doseMg * Math.pow(0.5, hoursElapsed / medicationHalfLife);
                        totalLevel += remainingLevel;
                        validCount++;
                    }
                });

                // Return structured result
                return {
                    success: validCount > 0,
                    value: totalLevel,
                    validCount,
                    totalCount: injections.length,
                    invalidCount,
                    warning: invalidCount > 0 ? `${invalidCount} injection(s) skipped due to invalid data` : null
                };
            }

            // ====================================
            // TRT INJECTION MANAGEMENT
            // ====================================

            async addTrtInjection(injection) {
                const newInjection = {
                    id: this.generateId(),
                    timestamp: injection.timestamp || new Date().toISOString(),
                    volume_ml: parseFloat(injection.volume_ml),
                    concentration_mg_ml: parseFloat(injection.concentration_mg_ml),
                    dose_mg: parseFloat(injection.volume_ml) * parseFloat(injection.concentration_mg_ml),
                    injection_site: injection.injection_site,
                    time_of_day: injection.time_of_day || null,
                    technique_notes: injection.technique_notes || '',
                    notes: injection.notes || '',
                    vial_id: injection.vial_id || null,
                    skipped: injection.skipped || false,
                    planned_volume_ml: injection.planned_volume_ml || null,
                    planned_dose_mg: injection.planned_dose_mg || null
                };

                this.data.trtInjections.push(newInjection);
                this.data.trtInjections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Update vial usage if not skipped and vial specified
                if (!injection.skipped && injection.vial_id) {
                    await this.updateTrtVialUsage(injection.vial_id, injection.volume_ml);
                }

                this.saveData();
                this.updateUI();

                // Push to sync queue if authenticated
                if (authManager && authManager.isAuthenticated() && cloudStorage) {
                    try {
                        await cloudStorage.saveTrtInjection(newInjection);
                    } catch (error) {
                        console.warn('Failed to sync TRT injection to cloud:', error);
                    }
                }

                return newInjection;
            }

            async updateTrtInjection(injectionId, updates) {
                const injectionIndex = this.data.trtInjections.findIndex(inj => inj.id === injectionId);
                if (injectionIndex === -1) {
                    throw new Error('TRT injection not found');
                }

                const oldInjection = this.data.trtInjections[injectionIndex];
                const oldVolume = oldInjection.volume_ml;
                const oldVialId = oldInjection.vial_id;

                const updatedInjection = {
                    ...oldInjection,
                    timestamp: updates.timestamp || oldInjection.timestamp,
                    volume_ml: parseFloat(updates.volume_ml),
                    concentration_mg_ml: parseFloat(updates.concentration_mg_ml),
                    dose_mg: parseFloat(updates.volume_ml) * parseFloat(updates.concentration_mg_ml),
                    injection_site: updates.injection_site,
                    time_of_day: updates.time_of_day || null,
                    technique_notes: updates.technique_notes || '',
                    notes: updates.notes || ''
                };

                this.data.trtInjections[injectionIndex] = updatedInjection;
                this.data.trtInjections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Handle vial usage changes
                if (oldVialId === updates.vial_id) {
                    if (oldVolume !== updates.volume_ml) {
                        await this.reverseTrtVialUsage(oldVialId, oldVolume);
                        await this.updateTrtVialUsage(updates.vial_id, updates.volume_ml);
                    }
                } else {
                    await this.reverseTrtVialUsage(oldVialId, oldVolume);
                    await this.updateTrtVialUsage(updates.vial_id, updates.volume_ml);
                }

                this.saveData();
                this.updateUI();

                if (authManager && authManager.isAuthenticated() && cloudStorage) {
                    try {
                        await cloudStorage.saveTrtInjection(updatedInjection);
                    } catch (error) {
                        console.warn('Failed to sync TRT injection update to cloud:', error);
                    }
                }

                return updatedInjection;
            }

            async deleteTrtInjection(injectionId) {
                const injectionIndex = this.data.trtInjections.findIndex(inj => inj.id === injectionId);
                if (injectionIndex === -1) {
                    throw new Error('TRT injection not found');
                }

                const injection = this.data.trtInjections[injectionIndex];

                // Restore vial volume if injection used a vial
                if (injection.vial_id && !injection.skipped) {
                    await this.reverseTrtVialUsage(injection.vial_id, injection.volume_ml);
                }

                this.data.trtInjections.splice(injectionIndex, 1);
                this.saveData();
                this.updateUI();

                if (authManager && authManager.isAuthenticated() && cloudStorage) {
                    try {
                        await cloudStorage.deleteTrtInjection(injectionId);
                    } catch (error) {
                        console.warn('Failed to delete TRT injection from cloud:', error);
                    }
                }
            }

            // ====================================
            // TRT VIAL MANAGEMENT
            // ====================================

            async addTrtVial(vial) {
                const newVial = {
                    id: this.generateId(),
                    concentration_mg_ml: parseFloat(vial.concentration_mg_ml),
                    volume_ml: parseFloat(vial.volume_ml),
                    remaining_ml: parseFloat(vial.remaining_ml || vial.volume_ml),
                    lot_number: vial.lot_number || '',
                    expiry_date: vial.expiry_date,
                    opened_date: vial.opened_date || null,
                    status: vial.status || 'dry_stock',
                    notes: vial.notes || ''
                };

                this.data.trtVials.push(newVial);
                this.saveData();
                this.updateUI();

                if (authManager && authManager.isAuthenticated() && cloudStorage) {
                    try {
                        await cloudStorage.saveTrtVial(newVial);
                    } catch (error) {
                        console.warn('Failed to sync TRT vial to cloud:', error);
                    }
                }

                return newVial;
            }

            async updateTrtVial(vialId, updates) {
                const vialIndex = this.data.trtVials.findIndex(v => v.id === vialId);
                if (vialIndex === -1) {
                    throw new Error('TRT vial not found');
                }

                const updatedVial = {
                    ...this.data.trtVials[vialIndex],
                    ...updates
                };

                this.data.trtVials[vialIndex] = updatedVial;
                this.saveData();
                this.updateUI();

                if (authManager && authManager.isAuthenticated() && cloudStorage) {
                    try {
                        await cloudStorage.saveTrtVial(updatedVial);
                    } catch (error) {
                        console.warn('Failed to sync TRT vial update to cloud:', error);
                    }
                }

                return updatedVial;
            }

            async deleteTrtVial(vialId) {
                const vialIndex = this.data.trtVials.findIndex(v => v.id === vialId);
                if (vialIndex === -1) {
                    throw new Error('TRT vial not found');
                }

                this.data.trtVials.splice(vialIndex, 1);
                this.saveData();
                this.updateUI();

                if (authManager && authManager.isAuthenticated() && cloudStorage) {
                    try {
                        await cloudStorage.deleteTrtVial(vialId);
                    } catch (error) {
                        console.warn('Failed to delete TRT vial from cloud:', error);
                    }
                }
            }

            async updateTrtVialUsage(vialId, volumeMl) {
                if (!vialId) return;

                const vial = this.data.trtVials.find(v => v.id === vialId);
                if (!vial) {
                    console.warn('TRT vial not found:', vialId);
                    return;
                }

                vial.remaining_ml = Math.max(0, vial.remaining_ml - volumeMl);

                // Mark as empty if no volume remaining
                if (vial.remaining_ml === 0) {
                    vial.status = 'empty';
                }

                this.saveData();
            }

            async reverseTrtVialUsage(vialId, volumeMl) {
                if (!vialId) return;

                const vial = this.data.trtVials.find(v => v.id === vialId);
                if (!vial) {
                    console.warn('TRT vial not found:', vialId);
                    return;
                }

                vial.remaining_ml = Math.min(vial.volume_ml, vial.remaining_ml + volumeMl);

                // Restore status if was empty
                if (vial.status === 'empty' && vial.remaining_ml > 0) {
                    vial.status = 'active';
                }

                this.saveData();
            }

            // ====================================
            // TRT SYMPTOM MANAGEMENT
            // ====================================

            async addTrtSymptom(symptom) {
                const newSymptom = {
                    id: this.generateId(),
                    timestamp: symptom.timestamp || new Date().toISOString(),
                    energyLevel: parseInt(symptom.energyLevel),
                    mood: parseInt(symptom.mood),
                    libido: parseInt(symptom.libido),
                    sleepQuality: parseInt(symptom.sleepQuality),
                    notes: symptom.notes || ''
                };

                this.data.trtSymptoms.push(newSymptom);
                this.data.trtSymptoms.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                this.saveData();
                this.updateUI();

                // Push to cloud if authenticated
                if (authManager && authManager.isAuthenticated() && cloudStorage) {
                    try {
                        await cloudStorage.saveTrtSymptom(newSymptom);
                        console.log('TRT symptom synced to cloud successfully');
                    } catch (error) {
                        console.warn('Failed to sync TRT symptom to cloud:', error);
                    }
                }

                return newSymptom;
            }

            async deleteTrtSymptom(symptomId) {
                const symptomIndex = this.data.trtSymptoms.findIndex(s => s.id === symptomId);
                if (symptomIndex === -1) {
                    throw new Error('TRT symptom not found');
                }

                this.data.trtSymptoms.splice(symptomIndex, 1);
                this.saveData();
                this.updateUI();

                // Delete from cloud if authenticated
                if (authManager && authManager.isAuthenticated() && cloudStorage) {
                    try {
                        await cloudStorage.deleteTrtSymptom(symptomId);
                        console.log('TRT symptom deleted from cloud successfully');
                    } catch (error) {
                        console.warn('Failed to delete TRT symptom from cloud:', error);
                    }
                }
            }

            // ====================================
            // TRT CALCULATIONS
            // ====================================

            calculateTrtDose(volumeMl, concentrationMgMl) {
                return parseFloat(volumeMl) * parseFloat(concentrationMgMl);
            }

            calculateTrtWeeklyDose() {
                const recentInjections = this.data.trtInjections
                    .filter(inj => !inj.skipped)
                    .slice(0, 4); // Last 4 injections

                if (recentInjections.length === 0) {
                    return this.data.trtSettings.defaultDoseMg;
                }

                const totalDose = recentInjections.reduce((sum, inj) => sum + inj.dose_mg, 0);
                const avgDose = totalDose / recentInjections.length;

                // Calculate average days between injections
                if (recentInjections.length > 1) {
                    let totalDays = 0;
                    for (let i = 0; i < recentInjections.length - 1; i++) {
                        const days = (new Date(recentInjections[i].timestamp) - new Date(recentInjections[i + 1].timestamp)) / (24 * 60 * 60 * 1000);
                        totalDays += days;
                    }
                    const avgDaysBetween = totalDays / (recentInjections.length - 1);
                    const weeklyDose = (avgDose * 7) / avgDaysBetween;
                    return weeklyDose;
                }

                // Fallback: use frequency from settings
                return (avgDose * 7) / this.data.trtSettings.injectionFrequency;
            }

            calculateTrtSupplyForecast() {
                const activeVials = this.data.trtVials.filter(v => v.status === 'active');
                if (activeVials.length === 0) {
                    return {
                        totalSupplyMl: 0,
                        totalSupplyMg: 0,
                        activeWeeksRemaining: 0,
                        skippedWeeksCount: 0,
                        calendarWeeksRemaining: 0,
                        adjustmentText: '',
                        runOutDate: null,
                        reorderDate: null,
                        daysUntilReorder: 0
                    };
                }

                const totalRemainingMl = activeVials.reduce((sum, v) => sum + v.remaining_ml, 0);
                const avgConcentration = activeVials.reduce((sum, v) => sum + v.concentration_mg_ml, 0) / activeVials.length;
                const totalSupplyMg = totalRemainingMl * avgConcentration;

                const weeklyDoseMg = this.calculateTrtWeeklyDose();
                const activeWeeks = Math.floor(totalSupplyMg / weeklyDoseMg);

                // Add skipped weeks (direct 1:1 extension)
                const skippedWeeks = this.data.trtInjections.filter(inj => inj.skipped).length;
                const calendarWeeks = activeWeeks + skippedWeeks;

                const today = new Date();
                const runOutDate = new Date(today.getTime() + calendarWeeks * 7 * 24 * 60 * 60 * 1000);
                const reorderDate = new Date(runOutDate.getTime() - 14 * 24 * 60 * 60 * 1000); // 2 weeks before

                return {
                    totalSupplyMl: totalRemainingMl.toFixed(1),
                    totalSupplyMg: totalSupplyMg.toFixed(0),
                    activeWeeksRemaining: activeWeeks,
                    skippedWeeksCount: skippedWeeks,
                    calendarWeeksRemaining: calendarWeeks,
                    adjustmentText: skippedWeeks > 0 ? `+${skippedWeeks} weeks from skips` : '',
                    runOutDate: runOutDate.toISOString().split('T')[0],
                    reorderDate: reorderDate.toISOString().split('T')[0],
                    daysUntilReorder: Math.ceil((reorderDate - today) / (24 * 60 * 60 * 1000))
                };
            }

            getTrtNextInjectionDate() {
                const lastInjection = this.data.trtInjections
                    .filter(inj => !inj.skipped)
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];

                if (!lastInjection) {
                    return new Date().toISOString();
                }

                const lastDate = new Date(lastInjection.timestamp);
                const nextDate = new Date(lastDate.getTime() + this.data.trtSettings.injectionFrequency * 24 * 60 * 60 * 1000);
                return nextDate.toISOString();
            }

            // ====================================
            // UTILITY FUNCTIONS
            // ====================================

            generateId() {
                return 'id_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            }

            kgToLbs(kg) {
                return kg * 2.20462;
            }

            lbsToKg(lbs) {
                return lbs / 2.20462;
            }

            formatDate(dateString) {
                return new Date(dateString).toLocaleDateString();
            }

            formatDateTime(dateString) {
                return new Date(dateString).toLocaleString();
            }

            formatInjectionSite(site) {
                // Convert underscore format to readable format
                // abdomen_left  Abdomen Left
                // thigh_right  Thigh Right
                // left_arm  Left Arm
                if (!site) return 'Unknown';

                return site
                    .split('_')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
            }

            // ====================================
            // UI UPDATE FUNCTIONS
            // ====================================

            updateUI() {
                if (this.currentApp === 'reta') {
                    this.updateSummaryTab();
                    this.updateShotsTab();
                    this.updateResultsTab();
                    this.updateInventoryTab();
                    this.updateSettingsTab();
                } else if (this.currentApp === 'trt') {
                    this.updateTrtDashboard();
                    this.updateTrtInjectionsList();
                    this.updateTrtSymptomsList();
                    this.updateTrtSymptomsGraph();
                    this.updateTrtVialsList();
                    this.updateTrtSupplyForecast();
                }
            }

            getMostRecentInjection() {
                if (this.data.injections.length === 0) return null;

                return this.data.injections.reduce((mostRecent, current) => {
                    const currentDate = new Date(current.timestamp);
                    const mostRecentDate = new Date(mostRecent.timestamp);
                    return currentDate > mostRecentDate ? current : mostRecent;
                });
            }

            updateSummaryTab() {
                const totalShots = this.data.injections.length;
                const lastInjection = this.getMostRecentInjection();

                // Calculate remaining vial volume after last shot
                let vialRemainingMl = 0;
                if (lastInjection && lastInjection.vial_id) {
                    const vial = this.data.vials.find(v => v.id === lastInjection.vial_id);
                    if (vial) {
                        // Calculate total used from this vial (excluding skipped injections)
                        const injectionsFromVial = this.data.injections
                            .filter(inj => inj.vial_id === vial.id && !inj.skipped)
                            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                        const totalUsedMg = injectionsFromVial.reduce((sum, inj) => sum + inj.dose_mg, 0);
                        const totalUsedMl = totalUsedMg / vial.concentration_mg_ml;
                        vialRemainingMl = 1.0 - totalUsedMl; // Assuming 1ml bac water per vial
                    }
                }

                const nextShotDays = this.calculateNextShotDays();

                document.getElementById('total-shots').textContent = totalShots;
                document.getElementById('last-dose').textContent = lastInjection ?
                    `${lastInjection.dose_mg} mg` : '0 mg';
                document.getElementById('current-level').textContent = `${vialRemainingMl.toFixed(2)} ml`;
                document.getElementById('next-shot').textContent = `${nextShotDays} days`;

                this.updateCountdown();
                this.updateSupplyForecast();
            }

            updateShotsTab() {
                const shotsList = document.getElementById('shots-list');
                shotsList.innerHTML = '';

                // Sort injections by date (newest first) and display
                const sortedInjections = [...this.data.injections].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                sortedInjections.forEach(injection => {
                    const shotItem = this.createShotListItem(injection);
                    shotsList.appendChild(shotItem);
                });
            }

            updateResultsTab() {
                try {
                    this.updateWeightChart();
                } catch (error) {
                    console.error('Error updating weight chart:', error);
                }
                try {
                    this.updateWeightStats();
                } catch (error) {
                    console.error('Error updating weight stats:', error);
                }
                try {
                    this.updateGoalProgress();
                } catch (error) {
                    console.error('Error updating goal progress:', error);
                }
                try {
                    this.updateWeightsList();
                } catch (error) {
                    console.error('Error updating weights list:', error);
                }
            }

            updateInventoryTab() {
                const vialsList = document.getElementById('vials-list');
                vialsList.innerHTML = '';

                // Sort vials: Active first, Dry stock middle, Finished/Expired last
                const sortedVials = [...this.data.vials].sort((a, b) => {
                    const getStatusPriority = (vial) => {
                        // Check if vial is expired, empty, or expiring (finished status)
                        const now = new Date();
                        const expDate = vial.expiration_date ? new Date(vial.expiration_date) : null;
                        const isExpired = expDate && expDate < now;
                        const isEmpty = vial.remaining_ml <= 0;

                        if (vial.status === 'active' && !isExpired && !isEmpty) return 1; // Active at top
                        if (vial.status === 'dry_stock') return 2; // Dry stock in middle
                        return 3; // Finished/expired/empty at bottom
                    };

                    const priorityA = getStatusPriority(a);
                    const priorityB = getStatusPriority(b);

                    if (priorityA !== priorityB) {
                        return priorityA - priorityB;
                    }

                    // Within same priority group, sort by most recent date
                    if (priorityA === 1) {
                        // Active vials: sort by reconstitution date (newest first)
                        return new Date(b.reconstitution_date || 0) - new Date(a.reconstitution_date || 0);
                    } else if (priorityA === 2) {
                        // Dry stock: sort by order date (newest first)
                        return new Date(b.order_date || 0) - new Date(a.order_date || 0);
                    } else {
                        // Finished: sort by expiration date (oldest first)
                        return new Date(a.expiration_date || 0) - new Date(b.expiration_date || 0);
                    }
                });

                sortedVials.forEach(vial => {
                    const vialItem = this.createVialListItem(vial);
                    vialsList.appendChild(vialItem);
                });

                this.updateInventoryStats();
            }

            updateSettingsTab() {
                // Update injection frequency
                document.getElementById('injection-frequency').value = this.data.settings.injectionFrequency;

                // Update default dose
                if (this.data.settings.defaultDose) {
                    document.getElementById('default-dose').value = this.data.settings.defaultDose;
                }

                // Update prefill dose from
                if (this.data.settings.prefillDoseFrom) {
                    document.getElementById('prefill-dose-from').value = this.data.settings.prefillDoseFrom;
                }

                // Update user height
                if (this.data.settings.heightCm) {
                    document.getElementById('user-height').value = this.data.settings.heightCm;
                }

                // Update goal weight
                if (this.data.settings.goalWeightKg) {
                    document.getElementById('goal-weight').value = this.data.settings.goalWeightKg;
                }
            }

            updateHeaderTimestamp() {
                // Display build timestamp in header
                const buildTimestampEl = document.getElementById('build-timestamp');
                if (buildTimestampEl && APP_VERSION.timestamp) {
                    buildTimestampEl.textContent = `Build: ${APP_VERSION.timestamp}`;
                }
            }

            calculateNextShotDays() {
                if (this.data.injections.length === 0) return 0;

                const lastInjection = this.getMostRecentInjection();
                const lastShot = new Date(lastInjection.timestamp);
                const nextShot = new Date(lastShot);
                const frequency = this.data.settings.injectionFrequency ||
                                this.data.settings.injectionFrequencyDays || 7;
                nextShot.setDate(nextShot.getDate() + frequency);

                const now = new Date();
                const diffTime = nextShot - now;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                return Math.max(0, diffDays);
            }

            // ====================================
            // TRT UI UPDATE FUNCTIONS
            // ====================================

            updateTrtDashboard() {
                // Update dashboard summary cards
                const totalInjections = this.data.trtInjections.filter(inj => !inj.skipped).length;
                const lastInjection = this.data.trtInjections
                    .filter(inj => !inj.skipped)
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];

                // Calculate next injection date
                const nextInjectionDate = this.getTrtNextInjectionDate();

                // Get supply forecast
                const supplyForecast = this.calculateTrtSupplyForecast();

                // Update DOM elements (will be added in dashboard HTML)
                const totalInjectionsEl = document.getElementById('trt-total-injections');
                if (totalInjectionsEl) {
                    totalInjectionsEl.textContent = totalInjections;
                }

                const lastDoseEl = document.getElementById('trt-last-dose');
                if (lastDoseEl && lastInjection) {
                    lastDoseEl.textContent = `${lastInjection.dose_mg.toFixed(1)} mg`;
                }

                const nextInjectionEl = document.getElementById('trt-next-injection');
                if (nextInjectionEl) {
                    if (nextInjectionDate) {
                        const daysUntil = Math.ceil((new Date(nextInjectionDate) - new Date()) / (1000 * 60 * 60 * 24));
                        nextInjectionEl.textContent = daysUntil > 0 ? `${daysUntil} days` : 'Today';
                    } else {
                        nextInjectionEl.textContent = 'Not scheduled';
                    }
                }

                const supplyRemainingEl = document.getElementById('trt-supply-remaining');
                if (supplyRemainingEl) {
                    supplyRemainingEl.textContent = `${supplyForecast.calendarWeeksRemaining} weeks`;
                }
            }

            updateTrtSettingsTab() {
                // Load TRT settings into form fields
                const injectionFrequencyEl = document.getElementById('trt-injection-frequency');
                if (injectionFrequencyEl) {
                    injectionFrequencyEl.value = this.data.trtSettings.injectionFrequency || 3.5;
                }

                const defaultDoseMgEl = document.getElementById('trt-default-dose-mg');
                if (defaultDoseMgEl) {
                    defaultDoseMgEl.value = this.data.trtSettings.defaultDoseMg || 100;
                }

                const defaultDoseMlEl = document.getElementById('trt-default-dose-ml');
                if (defaultDoseMlEl) {
                    defaultDoseMlEl.value = this.data.trtSettings.defaultDoseMl || 0.5;
                }

                const concentrationEl = document.getElementById('trt-concentration');
                if (concentrationEl) {
                    concentrationEl.value = this.data.trtSettings.concentrationMgMl || 200;
                }
            }

            updateTrtInjectionsList() {
                const injectionsList = document.getElementById('trt-injections-list');
                if (!injectionsList) return;

                injectionsList.innerHTML = '';

                // Sort injections by date (newest first)
                const sortedInjections = [...this.data.trtInjections].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                if (sortedInjections.length === 0) {
                    injectionsList.innerHTML = '<div class="empty-state">No TRT injections recorded yet. Add your first injection to get started!</div>';
                    return;
                }

                sortedInjections.forEach(injection => {
                    const injectionItem = this.createTrtInjectionListItem(injection);
                    injectionsList.appendChild(injectionItem);
                });
            }

            createTrtInjectionListItem(injection) {
                const div = document.createElement('div');
                div.className = injection.skipped ? 'shot-item skipped' : 'shot-item';
                div.setAttribute('data-item-id', injection.id);
                div.setAttribute('data-timestamp', injection.timestamp);

                if (injection.skipped) {
                    // Skipped injection display
                    div.innerHTML = `
                        <div class="shot-content">
                            <div class="shot-header">
                                <div class="shot-dose">
                                    ${injection.planned_dose_mg ? injection.planned_dose_mg.toFixed(1) : '0'} mg
                                    <span class="skipped-badge">SKIPPED</span>
                                </div>
                                <div class="shot-date">${this.formatDate(injection.timestamp)}</div>
                            </div>
                            <div class="shot-details">
                                <div>Reason: ${injection.notes || 'Not specified'}</div>
                            </div>
                        </div>
                        <div class="item-actions">
                            <button class="delete-btn" aria-label="Delete skipped entry" title="Delete this skipped entry">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                                    <path d="M10 11v6M14 11v6"/>
                                </svg>
                            </button>
                        </div>
                        <div class="delete-action">Delete</div>
                    `;
                } else {
                    // Normal injection display
                    const timeOfDay = injection.time_of_day ? ` (${injection.time_of_day})` : '';
                    div.innerHTML = `
                        <div class="shot-content">
                            <div class="shot-header">
                                <div class="shot-dose">${injection.dose_mg.toFixed(1)} mg (${injection.volume_ml.toFixed(2)}ml)</div>
                                <div class="shot-date">${this.formatDate(injection.timestamp)}${timeOfDay}</div>
                            </div>
                            <div class="shot-details">
                                <div>Site: ${this.formatTrtInjectionSite(injection.injection_site)}</div>
                                ${injection.technique_notes ? `<div>Technique: ${injection.technique_notes}</div>` : ''}
                                ${injection.notes ? `<div>Notes: ${injection.notes}</div>` : ''}
                            </div>
                        </div>
                        <div class="item-actions">
                            <button class="delete-btn" aria-label="Delete injection" title="Delete this injection">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                                    <path d="M10 11v6M14 11v6"/>
                                </svg>
                            </button>
                        </div>
                        <div class="delete-action">Delete</div>
                    `;
                }

                // Add delete handler
                const deleteBtn = div.querySelector('.delete-btn');
                deleteBtn.addEventListener('click', async () => {
                    if (confirm('Delete this injection?')) {
                        await this.deleteTrtInjection(injection.id);
                    }
                });

                return div;
            }

            formatTrtInjectionSite(site) {
                if (!site) return 'Not specified';
                const siteMap = {
                    'left_front_thigh': 'Left Front Thigh',
                    'right_front_thigh': 'Right Front Thigh'
                };
                return siteMap[site] || site;
            }

            updateTrtSymptomsList() {
                const symptomsList = document.getElementById('trt-symptoms-list');
                const noSymptoms = document.getElementById('trt-no-symptoms');
                if (!symptomsList) return;

                symptomsList.innerHTML = '';

                // Sort symptoms by date (newest first)
                const sortedSymptoms = [...this.data.trtSymptoms].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                if (sortedSymptoms.length === 0) {
                    if (noSymptoms) noSymptoms.style.display = 'block';
                    return;
                }

                if (noSymptoms) noSymptoms.style.display = 'none';

                sortedSymptoms.forEach(symptom => {
                    const symptomItem = this.createTrtSymptomListItem(symptom);
                    symptomsList.appendChild(symptomItem);
                });
            }

            createTrtSymptomListItem(symptom) {
                const div = document.createElement('div');
                div.className = 'shot-item';
                div.style.cssText = 'margin-bottom: 12px; padding: 16px; background: var(--secondary-bg); border-radius: var(--border-radius); border: 1px solid var(--border-color);';
                div.setAttribute('data-item-id', symptom.id);
                div.setAttribute('data-timestamp', symptom.timestamp);

                const getScoreColor = (score) => {
                    if (score >= 8) return 'var(--success-color)';
                    if (score >= 6) return 'var(--warning-color)';
                    return 'var(--danger-color)';
                };

                const avgScore = ((symptom.energyLevel + symptom.mood + symptom.libido + symptom.sleepQuality) / 4).toFixed(1);
                const avgColor = getScoreColor(parseFloat(avgScore));

                div.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">${this.formatDate(symptom.timestamp)}</div>
                        <div style="font-weight: 600; color: ${avgColor}; font-size: 18px;">Avg: ${avgScore}/10</div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 14px;">
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: var(--text-secondary);">Energy:</span>
                            <span style="color: ${getScoreColor(symptom.energyLevel)}; font-weight: 600;">${symptom.energyLevel}/10</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: var(--text-secondary);">Mood:</span>
                            <span style="color: ${getScoreColor(symptom.mood)}; font-weight: 600;">${symptom.mood}/10</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: var(--text-secondary);">Libido:</span>
                            <span style="color: ${getScoreColor(symptom.libido)}; font-weight: 600;">${symptom.libido}/10</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: var(--text-secondary);">Sleep:</span>
                            <span style="color: ${getScoreColor(symptom.sleepQuality)}; font-weight: 600;">${symptom.sleepQuality}/10</span>
                        </div>
                    </div>
                    ${symptom.notes ? `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); color: var(--text-secondary); font-size: 13px;">${symptom.notes}</div>` : ''}
                    <button class="delete-symptom-btn" style="margin-top: 12px; padding: 6px 12px; background: var(--danger-color); color: white; border: none; border-radius: var(--border-radius-sm); cursor: pointer; font-size: 13px; width: 100%;">Delete</button>
                `;

                // Add delete handler
                const deleteBtn = div.querySelector('.delete-symptom-btn');
                deleteBtn.addEventListener('click', async () => {
                    if (confirm('Delete this symptom check-in?')) {
                        await this.deleteTrtSymptom(symptom.id);
                    }
                });

                return div;
            }

            updateTrtSymptomsGraph() {
                const canvas = document.getElementById('trt-symptom-graph');
                const container = document.getElementById('trt-symptom-graph-container');
                const noDataMessage = document.getElementById('trt-no-symptom-data');

                if (!canvas || !container) return;

                // Need at least 2 data points to show a graph
                if (this.data.trtSymptoms.length < 2) {
                    container.style.display = 'none';
                    if (noDataMessage) noDataMessage.style.display = 'block';
                    return;
                }

                container.style.display = 'block';
                if (noDataMessage) noDataMessage.style.display = 'none';

                // Destroy existing chart if it exists
                if (this.charts && this.charts.trtSymptomsChart) {
                    this.charts.trtSymptomsChart.destroy();
                }

                // Sort symptoms by date (oldest first for chart)
                const sortedSymptoms = [...this.data.trtSymptoms].sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                );

                // Prepare datasets for each symptom type
                const symptomTypes = [
                    { key: 'energyLevel', label: 'Energy', color: '#34C759' },      // Green
                    { key: 'mood', label: 'Mood', color: '#5AC8FA' },               // Cyan
                    { key: 'libido', label: 'Libido', color: '#FF6B6B' },           // Red
                    { key: 'sleepQuality', label: 'Sleep', color: '#AF52DE' }       // Purple
                ];

                const datasets = symptomTypes.map(symptom => ({
                    label: symptom.label,
                    data: sortedSymptoms.map(s => ({
                        x: s.timestamp,
                        y: s[symptom.key]
                    })),
                    borderColor: symptom.color,
                    backgroundColor: symptom.color,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    pointHitRadius: 10,
                    pointBackgroundColor: symptom.color,
                    pointBorderColor: symptom.color,
                    pointBorderWidth: 2
                }));

                // Responsive font sizing
                const isMobile = window.innerWidth < 768;
                const fontSize = {
                    legend: isMobile ? 11 : 12,
                    tick: isMobile ? 10 : 11,
                    title: isMobile ? 11 : 12
                };

                // Calculate date range with padding
                const firstTimestamp = new Date(sortedSymptoms[0].timestamp).getTime();
                const lastTimestamp = new Date(sortedSymptoms[sortedSymptoms.length - 1].timestamp).getTime();
                const dayInMs = 24 * 60 * 60 * 1000;
                const padding = 2 * dayInMs; // 2 days padding

                // Get canvas context and create chart
                const ctx = canvas.getContext('2d');

                // Initialize charts object if it doesn't exist
                if (!this.charts) {
                    this.charts = {};
                }

                this.charts.trtSymptomsChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                top: 10,
                                left: 10,
                                right: 10,
                                bottom: 5
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    color: '#ffffff',
                                    font: { size: fontSize.legend },
                                    padding: isMobile ? 8 : 12,
                                    boxWidth: isMobile ? 25 : 30,
                                    usePointStyle: true
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(42, 42, 42, 0.95)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#333333',
                                borderWidth: 1,
                                padding: isMobile ? 10 : 12,
                                titleFont: { size: isMobile ? 12 : 13 },
                                bodyFont: { size: isMobile ? 12 : 13 },
                                callbacks: {
                                    title: function(context) {
                                        const date = new Date(context[0].parsed.x);
                                        return date.toLocaleDateString();
                                    },
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.parsed.y}/10`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'day',
                                    displayFormats: {
                                        day: isMobile ? 'M/d' : 'MMM d'
                                    }
                                },
                                min: new Date(firstTimestamp - padding).toISOString(),
                                max: new Date(lastTimestamp + padding).toISOString(),
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: { size: fontSize.tick },
                                    maxTicksLimit: isMobile ? 5 : 8,
                                    maxRotation: isMobile ? 45 : 0,
                                    minRotation: isMobile ? 45 : 0
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                min: 0,
                                max: 10,
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: { size: fontSize.tick },
                                    stepSize: 2,
                                    callback: function(value) {
                                        return value;
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Score (1-10)',
                                    color: '#cccccc',
                                    font: { size: fontSize.title }
                                }
                            }
                        }
                    }
                });
            }

            updateTrtVialsList() {
                const vialsList = document.getElementById('trt-vials-list');
                if (!vialsList) return;

                vialsList.innerHTML = '';

                // Sort vials: Active first, then dry stock, then expired
                const sortedVials = [...this.data.trtVials].sort((a, b) => {
                    const priorityMap = { 'active': 1, 'dry_stock': 2, 'empty': 3, 'expired': 4 };
                    return priorityMap[a.status] - priorityMap[b.status];
                });

                if (sortedVials.length === 0) {
                    vialsList.innerHTML = '<div class="empty-state">No TRT vials in inventory. Add a vial to track your supply!</div>';
                    return;
                }

                sortedVials.forEach(vial => {
                    const vialItem = this.createTrtVialListItem(vial);
                    vialsList.appendChild(vialItem);
                });
            }

            createTrtVialListItem(vial) {
                const div = document.createElement('div');
                div.className = `vial-item status-${vial.status}`;
                div.setAttribute('data-item-id', vial.id);

                const statusBadges = {
                    'active': '<span class="status-badge active">Active</span>',
                    'dry_stock': '<span class="status-badge dry-stock">Dry Stock</span>',
                    'empty': '<span class="status-badge empty">Empty</span>',
                    'expired': '<span class="status-badge expired">Expired</span>'
                };

                div.innerHTML = `
                    <div class="vial-content">
                        <div class="vial-header">
                            <div class="vial-title">
                                ${vial.concentration_mg_ml}mg/ml - ${vial.volume_ml}ml
                                ${statusBadges[vial.status] || ''}
                            </div>
                            ${vial.lot_number ? `<div class="vial-lot">Lot: ${vial.lot_number}</div>` : ''}
                        </div>
                        <div class="vial-details">
                            ${vial.status === 'active' ? `<div>Remaining: ${vial.remaining_ml.toFixed(2)}ml</div>` : ''}
                            ${vial.status === 'active' && vial.opened_date ? `<div>Opened: ${this.formatDate(vial.opened_date)}</div>` : ''}
                            <div>Expires: ${this.formatDate(vial.expiry_date)}</div>
                            ${vial.notes ? `<div>Notes: ${vial.notes}</div>` : ''}
                        </div>
                    </div>
                    <div class="item-actions">
                        <button class="delete-btn" aria-label="Delete vial" title="Delete this vial">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                                <path d="M10 11v6M14 11v6"/>
                            </svg>
                        </button>
                    </div>
                    <div class="delete-action">Delete</div>
                `;

                // Add delete handler
                const deleteBtn = div.querySelector('.delete-btn');
                deleteBtn.addEventListener('click', async () => {
                    if (confirm('Delete this vial?')) {
                        await this.deleteTrtVial(vial.id);
                    }
                });

                return div;
            }

            updateTrtSupplyForecast() {
                const forecastEl = document.getElementById('trt-supply-forecast');
                if (!forecastEl) return;

                const forecast = this.calculateTrtSupplyForecast();

                forecastEl.innerHTML = `
                    <div class="forecast-summary">
                        <div class="forecast-item">
                            <div class="forecast-label">Total Supply</div>
                            <div class="forecast-value">${forecast.totalSupplyMg.toFixed(1)} mg</div>
                        </div>
                        <div class="forecast-item">
                            <div class="forecast-label">Active Weeks</div>
                            <div class="forecast-value">${forecast.activeWeeksRemaining}</div>
                        </div>
                        <div class="forecast-item">
                            <div class="forecast-label">Calendar Weeks</div>
                            <div class="forecast-value">${forecast.calendarWeeksRemaining}</div>
                        </div>
                        <div class="forecast-item">
                            <div class="forecast-label">Runs Out</div>
                            <div class="forecast-value">${forecast.runoutDate ? this.formatDate(forecast.runoutDate) : 'Unknown'}</div>
                        </div>
                    </div>
                `;
            }

            // ====================================
            // END TRT UI UPDATE FUNCTIONS
            // ====================================

            // ====================================
            // EVENT LISTENERS
            // ====================================

            setupEventListeners() {
                this.setupAppSwitcher();
                this.setupNavigation();
                this.setupModalHandlers();
                this.setupFormHandlers();
                this.setupEditHandlers();
            }

            // App Switcher between Reta and TRT
            setupAppSwitcher() {
                const switcherButtons = document.querySelectorAll('.app-switcher-btn');

                switcherButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const targetApp = btn.dataset.app;
                        if (targetApp === this.currentApp) return; // Already on this app

                        // Update UI
                        switcherButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        // Switch app mode
                        this.currentApp = targetApp;
                        localStorage.setItem('currentApp', targetApp);

                        // Update URL hash
                        window.location.hash = targetApp;

                        // Reload UI for new app
                        this.switchApp(targetApp);
                    });
                });

                // Restore app switcher state on load
                const activeBtn = document.querySelector(`.app-switcher-btn[data-app="${this.currentApp}"]`);
                if (activeBtn) {
                    switcherButtons.forEach(b => b.classList.remove('active'));
                    activeBtn.classList.add('active');
                }

                // Handle hash changes
                window.addEventListener('hashchange', () => {
                    const hash = window.location.hash.replace('#', '');
                    if (hash && (hash === 'reta' || hash === 'trt') && hash !== this.currentApp) {
                        const btn = document.querySelector(`.app-switcher-btn[data-app="${hash}"]`);
                        if (btn) btn.click();
                    }
                });

                // Initialize from hash on load
                const initialHash = window.location.hash.replace('#', '');
                if (initialHash === 'trt' || initialHash === 'reta') {
                    this.currentApp = initialHash;
                    localStorage.setItem('currentApp', initialHash);
                    const activeBtn = document.querySelector(`.app-switcher-btn[data-app="${initialHash}"]`);
                    if (activeBtn) {
                        switcherButtons.forEach(b => b.classList.remove('active'));
                        activeBtn.classList.add('active');
                    }
                }
            }

            switchApp(appMode) {
                console.log(`[APP-SWITCH] Switching to ${appMode}`);

                if (appMode === 'reta') {
                    // Show Reta navigation and content
                    this.showRetaApp();
                } else if (appMode === 'trt') {
                    // Show TRT navigation and content
                    this.showTrtApp();
                }

                // Reload UI
                this.updateUI();
            }

            showRetaApp() {
                const bottomNav = document.getElementById('bottom-nav');
                const addShotBtn = document.getElementById('add-shot-btn');

                // Show Reta tabs, hide TRT tabs
                document.querySelectorAll('.nav-btn[data-tab^="trt-"]').forEach(btn => {
                    btn.style.display = 'none';
                });
                document.querySelectorAll('.nav-btn:not([data-tab^="trt-"])').forEach(btn => {
                    btn.style.display = 'flex';
                });

                // Update add button text
                if (addShotBtn) addShotBtn.textContent = '+ Shot';

                // Show first Reta tab
                document.getElementById('summary-tab').style.display = 'block';
                document.querySelectorAll('.tab-content[id^="trt-"]').forEach(tab => {
                    tab.style.display = 'none';
                });
            }

            showTrtApp() {
                const bottomNav = document.getElementById('bottom-nav');
                const addShotBtn = document.getElementById('add-shot-btn');

                // Hide Reta tabs, show TRT tabs
                document.querySelectorAll('.nav-btn:not([data-tab^="trt-"])').forEach(btn => {
                    btn.style.display = 'none';
                });
                document.querySelectorAll('.nav-btn[data-tab^="trt-"]').forEach(btn => {
                    btn.style.display = 'flex';
                });

                // Update add button text
                if (addShotBtn) addShotBtn.textContent = '+ Shot';

                // Show first TRT tab
                const trtDashboard = document.getElementById('trt-dashboard-tab');
                if (trtDashboard) {
                    trtDashboard.style.display = 'block';
                }
                document.querySelectorAll('.tab-content:not([id^="trt-"])').forEach(tab => {
                    tab.style.display = 'none';
                });
            }

            setupNavigation() {
                const navButtons = document.querySelectorAll('.nav-btn');
                const tabContents = document.querySelectorAll('.tab-content');

                navButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const targetTab = btn.dataset.tab;

                        navButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        tabContents.forEach(tab => {
                            tab.style.display = 'none';
                        });
                        document.getElementById(targetTab + '-tab').style.display = 'block';

                        // Update Reta tabs
                        if (targetTab === 'summary') this.updateSupplyForecast();
                        if (targetTab === 'results') this.updateWeightChart();
                        if (targetTab === 'settings') this.updateSettingsTab();

                        // Update TRT tabs
                        if (targetTab === 'trt-dashboard') {
                            this.updateTrtDashboard();
                            this.updateTrtSupplyForecast();
                        }
                        if (targetTab === 'trt-shots') {
                            this.updateTrtInjectionsList();
                        }
                        if (targetTab === 'trt-inventory') {
                            this.updateTrtVialsList();
                        }
                        if (targetTab === 'trt-settings') {
                            this.updateTrtSettingsTab();
                        }
                    });
                });
            }

            hideLoadingScreen() {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('summary-tab').style.display = 'block';
                document.getElementById('current-date').textContent = new Date().toLocaleDateString();
            }

            // ====================================
            // PLACEHOLDER FUNCTIONS (TO BE IMPLEMENTED)
            // ====================================

            setupModalHandlers() {
                const overlay = document.getElementById('modal-overlay');
                const modals = document.querySelectorAll('.modal');

                // RETA Modal Handlers
                // Add Shot Button handler
                document.getElementById('add-shot-btn').addEventListener('click', () => {
                    if (this.currentApp === 'reta') {
                        this.openModal('add-shot-modal');
                    } else {
                        this.openModal('add-trt-injection-modal');
                    }
                });

                // Skip Week Button handler
                document.getElementById('skip-week-btn').addEventListener('click', () => {
                    if (this.currentApp === 'reta') {
                        this.showSkipWeekModal();
                    } else {
                        this.showSkipTrtInjectionModal();
                    }
                });

                // Add Vial Button handler
                document.getElementById('add-vial-btn').addEventListener('click', () => {
                    if (this.currentApp === 'reta') {
                        this.openModal('add-vial-modal');
                    } else {
                        this.openModal('add-trt-vial-modal');
                    }
                });

                // Activate Vial Button handler
                document.getElementById('activate-vial-btn').addEventListener('click', () => {
                    this.openModal('activate-vial-modal');
                });

                // TRT Modal Handlers (if TRT-specific buttons exist)
                const addTrtInjectionBtn = document.getElementById('add-trt-injection-btn');
                if (addTrtInjectionBtn) {
                    addTrtInjectionBtn.addEventListener('click', () => {
                        this.openModal('add-trt-injection-modal');
                    });
                }

                const addTrtVialBtn = document.getElementById('add-trt-vial-btn');
                if (addTrtVialBtn) {
                    addTrtVialBtn.addEventListener('click', () => {
                        this.openModal('add-trt-vial-modal');
                    });
                }

                const skipTrtWeekBtn = document.getElementById('skip-trt-week-btn');
                if (skipTrtWeekBtn) {
                    skipTrtWeekBtn.addEventListener('click', () => {
                        this.showSkipTrtInjectionModal();
                    });
                }

                // Close modal handlers
                document.querySelectorAll('.modal-close, [data-modal]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (btn.classList.contains('modal-close') || btn.textContent === 'Cancel') {
                            this.closeModal();
                        }
                    });
                });

                // Click outside modal to close
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        this.closeModal();
                    }
                });
            }

            setupFormHandlers() {
                // RETA Form Handlers
                // Add Shot Form
                document.getElementById('add-shot-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddShot();
                });

                // Live ml conversion for shot dose
                const shotDoseInput = document.getElementById('shot-dose');
                const shotVialSelect = document.getElementById('shot-vial');
                const updateDoseMlHelper = () => {
                    const helperEl = document.getElementById('dose-ml-helper');
                    const dose = parseFloat(shotDoseInput.value);
                    const vialId = shotVialSelect.value;

                    if (!dose || !vialId || dose <= 0) {
                        helperEl.textContent = '';
                        return;
                    }

                    const vial = this.findVialById(vialId);
                    if (!vial) {
                        helperEl.textContent = '';
                        return;
                    }

                    const concentration = vial.concentration_mg_ml || vial.concentration_mg_per_ml;
                    if (!concentration) {
                        helperEl.textContent = ' Vial concentration not set';
                        helperEl.style.color = 'var(--warning-color)';
                        return;
                    }

                    const volumeMl = dose / concentration;
                    const remainingMl = vial.current_volume_ml || vial.remaining_ml || 0;
                    const afterDrawMl = remainingMl - volumeMl;

                    if (afterDrawMl < 0) {
                        helperEl.innerHTML = ` <strong>${volumeMl.toFixed(2)}ml</strong> needed, but vial only has <strong>${remainingMl.toFixed(2)}ml</strong>`;
                        helperEl.style.color = 'var(--error-color)';
                    } else {
                        helperEl.innerHTML = ` Draw <strong>${volumeMl.toFixed(2)}ml</strong> from vial (${concentration.toFixed(1)}mg/ml). Vial will have ${afterDrawMl.toFixed(2)}ml remaining.`;
                        helperEl.style.color = 'var(--text-secondary)';
                    }
                };

                shotDoseInput.addEventListener('input', updateDoseMlHelper);
                shotVialSelect.addEventListener('change', updateDoseMlHelper);

                // Skip Shot Form
                document.getElementById('skip-shot-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleSkipShot();
                });

                // Add Vial Form
                document.getElementById('add-vial-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddVial();
                });

                // Edit Vial Form
                document.getElementById('edit-vial-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleEditVial();
                });

                // Activate Vial Form
                document.getElementById('activate-vial-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleActivateVial();
                });

                // Add Weight Form
                document.getElementById('add-weight-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddWeight();
                });

                // TRT Form Handlers
                // Add TRT Injection Form
                const addTrtInjectionForm = document.getElementById('add-trt-injection-form');
                if (addTrtInjectionForm) {
                    addTrtInjectionForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleAddTrtInjection();
                    });
                }

                // Live dose calculation for TRT injection
                const trtVolumeInput = document.getElementById('trt-injection-volume');
                const trtVialSelect = document.getElementById('trt-injection-vial');
                const trtFinishVialCheckbox = document.getElementById('trt-finish-vial-checkbox');
                const trtRemainingVolumeHint = document.getElementById('trt-remaining-volume-hint');
                const trtVialRemainingDisplay = document.getElementById('trt-vial-remaining-display');

                if (trtVolumeInput && trtVialSelect) {
                    const updateTrtDoseDisplay = () => {
                        const volumeMl = parseFloat(trtVolumeInput.value);
                        const vialId = trtVialSelect.value;
                        const doseDisplay = document.getElementById('trt-dose-display');
                        const calculatedDose = document.getElementById('trt-calculated-dose');
                        const concentrationDisplay = document.getElementById('trt-concentration-display');

                        if (!vialId) {
                            doseDisplay.style.display = 'none';
                            if (trtRemainingVolumeHint) trtRemainingVolumeHint.style.display = 'none';
                            return;
                        }

                        const vial = this.findTrtVialById(vialId);
                        if (!vial) {
                            doseDisplay.style.display = 'none';
                            if (trtRemainingVolumeHint) trtRemainingVolumeHint.style.display = 'none';
                            return;
                        }

                        // Show remaining volume hint
                        if (trtRemainingVolumeHint && trtVialRemainingDisplay) {
                            trtVialRemainingDisplay.textContent = (vial.remaining_ml || 0).toFixed(2);
                            trtRemainingVolumeHint.style.display = 'block';
                        }

                        // Show concentration
                        if (concentrationDisplay) {
                            concentrationDisplay.textContent = `${vial.concentration_mg_ml}mg/ml`;
                        }

                        if (!volumeMl || volumeMl <= 0) {
                            doseDisplay.style.display = 'none';
                            return;
                        }

                        const doseMg = volumeMl * vial.concentration_mg_ml;
                        calculatedDose.textContent = `${doseMg.toFixed(1)}mg`;
                        doseDisplay.style.display = 'block';
                    };

                    trtVolumeInput.addEventListener('input', updateTrtDoseDisplay);
                    trtVialSelect.addEventListener('change', updateTrtDoseDisplay);

                    // Handle "Finish Vial" checkbox
                    if (trtFinishVialCheckbox) {
                        trtFinishVialCheckbox.addEventListener('change', (e) => {
                            const vialId = trtVialSelect.value;

                            if (e.target.checked) {
                                // Checkbox is checked - auto-fill with remaining volume
                                if (vialId) {
                                    const vial = this.findTrtVialById(vialId);
                                    if (vial && vial.remaining_ml > 0) {
                                        trtVolumeInput.value = vial.remaining_ml.toFixed(2);
                                        trtVolumeInput.disabled = true;
                                        trtVolumeInput.style.opacity = '0.6';
                                        updateTrtDoseDisplay();
                                    }
                                } else {
                                    alert('Please select a vial first');
                                    e.target.checked = false;
                                }
                            } else {
                                // Checkbox is unchecked - re-enable manual input
                                trtVolumeInput.disabled = false;
                                trtVolumeInput.style.opacity = '1';
                                trtVolumeInput.value = '';
                                updateTrtDoseDisplay();
                            }
                        });

                        // Also handle vial selection change when checkbox is checked
                        trtVialSelect.addEventListener('change', () => {
                            if (trtFinishVialCheckbox.checked) {
                                const vialId = trtVialSelect.value;
                                if (vialId) {
                                    const vial = this.findTrtVialById(vialId);
                                    if (vial && vial.remaining_ml > 0) {
                                        trtVolumeInput.value = vial.remaining_ml.toFixed(2);
                                        updateTrtDoseDisplay();
                                    }
                                }
                            }
                        });
                    }
                }

                // Add TRT Vial Form
                const addTrtVialForm = document.getElementById('add-trt-vial-form');
                if (addTrtVialForm) {
                    addTrtVialForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleAddTrtVial();
                    });
                }

                // TRT Vial status change handler (show/hide opened date and remaining volume)
                const trtVialStatus = document.getElementById('trt-vial-status');
                const trtOpenedDateGroup = document.getElementById('trt-vial-opened-group');
                const trtRemainingVolumeGroup = document.getElementById('trt-vial-remaining-group');
                if (trtVialStatus) {
                    trtVialStatus.addEventListener('change', (e) => {
                        if (e.target.value === 'active') {
                            if (trtOpenedDateGroup) trtOpenedDateGroup.style.display = 'block';
                            if (trtRemainingVolumeGroup) trtRemainingVolumeGroup.style.display = 'block';
                        } else {
                            if (trtOpenedDateGroup) trtOpenedDateGroup.style.display = 'none';
                            if (trtRemainingVolumeGroup) trtRemainingVolumeGroup.style.display = 'none';
                        }
                    });
                }

                // Skip TRT Injection Form
                const skipTrtInjectionForm = document.getElementById('skip-trt-injection-form');
                if (skipTrtInjectionForm) {
                    skipTrtInjectionForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleSkipTrtInjection();
                    });
                }

                // TRT Symptom tracking - slider value updates
                const symptomSliders = [
                    { slider: 'trt-energy', display: 'trt-energy-value' },
                    { slider: 'trt-mood', display: 'trt-mood-value' },
                    { slider: 'trt-libido', display: 'trt-libido-value' },
                    { slider: 'trt-sleep', display: 'trt-sleep-value' }
                ];

                symptomSliders.forEach(({ slider, display }) => {
                    const sliderEl = document.getElementById(slider);
                    const displayEl = document.getElementById(display);
                    if (sliderEl && displayEl) {
                        sliderEl.addEventListener('input', (e) => {
                            displayEl.textContent = e.target.value;
                        });
                    }
                });

                // TRT Symptom save button
                const saveTrtSymptomBtn = document.getElementById('trt-save-symptom-btn');
                if (saveTrtSymptomBtn) {
                    saveTrtSymptomBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.handleAddTrtSymptom();
                    });
                }

                // TRT Settings save button
                const saveTrtSettingsBtn = document.getElementById('trt-save-settings-btn');
                if (saveTrtSettingsBtn) {
                    saveTrtSettingsBtn.addEventListener('click', async (e) => {
                        e.preventDefault();
                        await this.handleSaveTrtSettings();
                    });
                }

                // Settings form handlers
                document.getElementById('injection-frequency').addEventListener('change', (e) => {
                    this.data.settings.injectionFrequency = parseInt(e.target.value);
                    this.saveData();
                    this.updateUI();
                    this.showSettingSaveIndicator(e.target);
                });

                // Default dose handler
                document.getElementById('default-dose').addEventListener('change', async (e) => {
                    this.data.settings.defaultDose = parseFloat(e.target.value);
                    this.saveData();
                    this.updateUI();
                    this.showSettingSaveIndicator(e.target);
                    await this.syncSettingsToCloud();
                });

                // Pre-fill dose from handler
                document.getElementById('prefill-dose-from').addEventListener('change', (e) => {
                    this.data.settings.prefillDoseFrom = e.target.value;
                    this.saveData();
                    this.showSettingSaveIndicator(e.target);
                });

                // Height handler
                document.getElementById('user-height').addEventListener('change', async (e) => {
                    this.data.settings.heightCm = parseFloat(e.target.value);
                    this.saveData();
                    this.updateBMI();
                    this.showSettingSaveIndicator(e.target);
                    await this.syncSettingsToCloud();
                });

                // Goal weight handler
                document.getElementById('goal-weight').addEventListener('change', async (e) => {
                    this.data.settings.goalWeightKg = parseFloat(e.target.value);
                    this.saveData();
                    this.updateGoalProgress();
                    this.showSettingSaveIndicator(e.target);
                    await this.syncSettingsToCloud();
                });

                // Export data
                document.getElementById('export-data-btn').addEventListener('click', () => {
                    this.exportData();
                });

                // Planned dose change listener
                const plannedDoseInput = document.getElementById('planned-dose');
                if (plannedDoseInput) {
                    plannedDoseInput.addEventListener('input', () => {
                        this.updateSupplyForecast();
                    });
                }

                // Import data
                document.getElementById('import-data-btn').addEventListener('click', () => {
                    this.importData();
                });

                // Cloud backup
                document.getElementById('create-cloud-backup-btn').addEventListener('click', () => {
                    this.createCloudBackup();
                });

                // Reset local data and sync from cloud
                document.getElementById('reset-local-data-btn').addEventListener('click', async () => {
                    await this.resetLocalDataAndSync();
                });

                // Nuclear Reset
                document.getElementById('nuclear-reset-btn').addEventListener('click', () => {
                    this.performNuclearReset();
                });
            }

            setupEditHandlers() {
                // Use event delegation for edit buttons (since they're dynamically created)
                document.addEventListener('click', (e) => {
                    const editBtn = e.target.closest('.edit-btn');
                    if (!editBtn) return;

                    const entityType = editBtn.dataset.entityType;
                    const entityId = editBtn.dataset.entityId;

                    if (entityType === 'injection') {
                        this.showEditInjectionModal(entityId);
                    } else if (entityType === 'weight') {
                        this.showEditWeightModal(entityId);
                    } else if (entityType === 'vial') {
                        this.showEditVialModal(entityId);
                    }
                });
            }

            // ====================================
            // DATA EXPORT/IMPORT
            // ====================================

            exportData() {
                const dataStr = JSON.stringify(this.data, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `injection_data_${new Date().toISOString().split('T')[0]}.json`;
                link.click();

                URL.revokeObjectURL(url);

                // Also generate CSV for injections
                this.exportInjectionsCSV();
            }

            exportInjectionsCSV() {
                if (this.data.injections.length === 0) {
                    alert('No injection data to export');
                    return;
                }

                const headers = ['Date', 'Time', 'Dose (mg)', 'Site', 'Notes'];
                const rows = this.data.injections.map(inj => {
                    const date = new Date(inj.timestamp);
                    return [
                        date.toLocaleDateString(),
                        date.toLocaleTimeString(),
                        inj.dose_mg,
                        inj.injection_site,
                        inj.notes || ''
                    ];
                });

                let csv = headers.join(',') + '\n';
                rows.forEach(row => {
                    csv += row.map(cell => `"${cell}"`).join(',') + '\n';
                });

                const blob = new Blob([csv], {type: 'text/csv'});
                const url = URL.createObjectURL(blob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `injection_log_${new Date().toISOString().split('T')[0]}.csv`;
                link.click();

                URL.revokeObjectURL(url);
            }

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const text = await file.text();
                        const importedData = JSON.parse(text);

                        if (confirm('This will replace all your current data. Are you sure?')) {
                            this.data = importedData;
                            await this.saveData();
                            this.updateUI();
                            const issues = this.validateDataIntegrity();
                            if (issues.length > 0) {
                                alert('Data imported successfully!\n\nNote: Some data integrity issues were found. Check the console for details.');
                            } else {
                                alert('Data imported successfully!');
                            }
                        }
                    } catch (error) {
                        alert('Error importing data: ' + error.message);
                    }
                };

                input.click();
            }

            async performNuclearReset() {
                const confirmed = confirm(
                    ' NUCLEAR RESET WARNING \n\n' +
                    'This will PERMANENTLY DELETE:\n' +
                    ' All localStorage data\n' +
                    ' All IndexedDB databases\n' +
                    ' All cached data\n' +
                    ' Service workers\n\n' +
                    'The page will reload and you will need to log in again.\n\n' +
                    'Are you absolutely sure you want to continue?'
                );

                if (!confirmed) return;

                const doubleConfirm = confirm('This action CANNOT be undone. Continue?');
                if (!doubleConfirm) return;

                console.log('=== NUCLEAR RESET STARTING ===');

                try {
                    // Step 1: Close database connections
                    console.log('Step 1: Closing database connections...');
                    if (this.backupManager && this.backupManager.db) {
                        this.backupManager.db.close();
                        this.backupManager.db = null;
                        console.log('   Closed database connection');
                    }

                    // Give connections time to close
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Step 2: Delete IndexedDB databases
                    console.log('Step 2: Deleting IndexedDB databases...');
                    const databases = await indexedDB.databases();
                    console.log(`  Found ${databases.length} databases:`, databases.map(db => db.name));

                    for (const db of databases) {
                        await new Promise((resolve) => {
                            const req = indexedDB.deleteDatabase(db.name);
                            req.onsuccess = () => {
                                console.log(`   Deleted ${db.name}`);
                                resolve();
                            };
                            req.onerror = () => {
                                console.log(`   Failed to delete ${db.name}`);
                                resolve(); // Continue anyway
                            };
                            req.onblocked = () => {
                                console.log(`   Deletion blocked for ${db.name}`);
                                setTimeout(resolve, 1000); // Wait and continue
                            };
                        });
                    }

                    // Step 3: Clear localStorage
                    console.log('Step 3: Clearing localStorage...');
                    const lsKeys = Object.keys(localStorage);
                    console.log(`  Found ${lsKeys.length} keys:`, lsKeys);
                    localStorage.clear();
                    console.log('   localStorage cleared');

                    // Step 4: Set flags AFTER clearing (so they survive the reload)
                    console.log('Step 4: Setting no-restore flags...');
                    localStorage.setItem('__nuclear_reset_in_progress__', 'true');
                    localStorage.setItem('__skip_sample_data__', 'true');
                    console.log('   Flags set in localStorage');

                    // Step 5: Clear Cache Storage
                    console.log('Step 5: Clearing Cache Storage...');
                    const cacheNames = await caches.keys();
                    console.log(`  Found ${cacheNames.length} caches`);
                    for (const name of cacheNames) {
                        await caches.delete(name);
                        console.log(`   Deleted cache: ${name}`);
                    }

                    // Step 6: Unregister Service Workers
                    console.log('Step 6: Unregistering Service Workers...');
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    console.log(`  Found ${registrations.length} service workers`);
                    for (const registration of registrations) {
                        await registration.unregister();
                        console.log(`   Unregistered: ${registration.scope}`);
                    }

                    console.log('=== NUCLEAR RESET COMPLETE ===');
                    console.log('Reloading page in 2 seconds...');

                    // Force a hard reload
                    setTimeout(() => {
                        window.location.href = window.location.href + '?nocache=' + Date.now();
                    }, 2000);

                } catch (error) {
                    console.error('ERROR during nuclear reset:', error);
                    alert('Error during reset: ' + error.message + '\n\nCheck console for details.');
                }
            }

            async importHistoricalData() {
                // Check Firebase auth directly
                const currentUser = firebase.auth().currentUser;
                if (!currentUser) {
                    throw new Error('Please sign in first');
                }

                const token = await currentUser.getIdToken();
                const API_BASE = 'https://5is9pmy9be.execute-api.eu-west-1.amazonaws.com/v1';

                const injections = [
                    { timestamp: '2025-08-06T09:00:00.000Z', doseMg: 0.25, site: 'abdomen', notes: 'Right abdomen. First micro-dose (2.5 units) to start titration.', vialId: null },
                    { timestamp: '2025-08-12T09:00:00.000Z', doseMg: 0.5, site: 'abdomen', notes: 'Right abdomen. Second dose (5 units). No major side effects.', vialId: null },
                    { timestamp: '2025-08-19T09:00:00.000Z', doseMg: 1, site: 'abdomen', notes: 'Right abdomen. First 1.0 mg (10 units). Mild nausea only.', vialId: null },
                    { timestamp: '2025-08-30T10:12:00.000Z', doseMg: 2, site: 'abdomen', notes: 'Right abdomen. First 2.0 mg dose (20 units). Mild appetite suppression.', vialId: null },
                    { timestamp: '2025-09-06T09:00:00.000Z', doseMg: 3, site: 'abdomen', notes: 'Right abdomen. 3.0 mg (30 units). Tolerated well, little nausea.', vialId: null },
                    { timestamp: '2025-09-13T09:00:00.000Z', doseMg: 4, site: 'abdomen', notes: 'Right abdomen. New vial reconstituted (10 mg + 1 mL BAC). First 4.0 mg dose (40 units).', vialId: 'vial-1' },
                    { timestamp: '2025-09-20T09:00:00.000Z', doseMg: 4, site: 'abdomen', notes: 'Right abdomen. Second 4.0 mg dose. Mild suppression noticed.', vialId: 'vial-1' },
                    { timestamp: '2025-09-27T10:51:00.000Z', doseMg: 4.2, site: 'abdomen', notes: 'Right abdomen. Only 42 units left in vial. Finished it. Suppression moderate.', vialId: 'vial-1' }
                ];

                const weights = [
                    { timestamp: '2025-08-06T09:00:00.000Z', weightKg: 95, notes: '' },
                    { timestamp: '2025-08-19T09:00:00.000Z', weightKg: 96, notes: '' },
                    { timestamp: '2025-08-30T10:12:00.000Z', weightKg: 93.6, notes: '' },
                    { timestamp: '2025-09-06T09:00:00.000Z', weightKg: 93, notes: '' },
                    { timestamp: '2025-09-20T09:00:00.000Z', weightKg: 90.9, notes: '' },
                    { timestamp: '2025-09-27T10:51:00.000Z', weightKg: 89.7, notes: '' }
                ];

                const vialData = {
                    startDate: '2025-09-13',
                    initialVolumeMl: 1,
                    concentrationMgPerMl: 10,
                    currentVolumeMl: 0,
                    usedVolumeMl: 1,
                    status: 'finished',
                    source: '',
                    notes: 'Reconstituted 10mg with 1mL BAC water'
                };

                // Import vial first (so injections can reference it)
                const vialRes = await fetch(`${API_BASE}/vials`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(vialData)
                });
                if (!vialRes.ok) {
                    const errorText = await vialRes.text();
                    throw new Error(`Failed to import vial: ${vialRes.status} - ${errorText}`);
                }
                const vialResult = await vialRes.json();
                const vialId = vialResult.data.id;

                // Update injection vialIds with the actual created vial ID
                const updatedInjections = injections.map(inj => ({
                    ...inj,
                    vialId: inj.vialId === 'vial-1' ? vialId : null
                }));

                // Import injections
                for (const inj of updatedInjections) {
                    const res = await fetch(`${API_BASE}/injections`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(inj)
                    });
                    if (!res.ok) {
                        const errorText = await res.text();
                        throw new Error(`Failed to import injection: ${res.status} - ${errorText}`);
                    }
                }

                // Import weights
                for (const wt of weights) {
                    const res = await fetch(`${API_BASE}/weights`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(wt)
                    });
                    if (!res.ok) {
                        const errorText = await res.text();
                        throw new Error(`Failed to import weight: ${res.status} - ${errorText}`);
                    }
                }
            }


            async createCloudBackup() {
                try {
                    // Check if authenticated
                    if (!authManager.isAuthenticated()) {
                        alert('Please sign in to use cloud backup.\n\nGo to Settings  Cloud Sync section.');
                        return;
                    }

                    // Show loading state
                    const button = document.getElementById('create-cloud-backup-btn');
                    const originalText = button.textContent;
                    button.textContent = 'Creating backup...';
                    button.disabled = true;

                    // Call API to create backup with local data
                    const result = await apiClient.createBackup(this.data);

                    // Update UI with success
                    const timestamp = new Date(result.timestamp).toLocaleString();
                    const counts = result.counts;

                    alert(
                        ` Cloud Backup Created Successfully!\n\n` +
                        `Timestamp: ${timestamp}\n` +
                        `Injections: ${counts.injections}\n` +
                        `Vials: ${counts.vials}\n` +
                        `Weights: ${counts.weights}\n\n` +
                        `Your data is now safely stored in AWS S3.\n` +
                        `Only the 4 most recent backups are kept.`
                    );

                    // Store last backup info in localStorage
                    localStorage.setItem('lastCloudBackup', JSON.stringify({
                        timestamp: result.timestamp,
                        key: result.key
                    }));

                    // Update cloud backup status
                    this.updateCloudBackupStatus();

                    // Reset button
                    button.textContent = originalText;
                    button.disabled = false;

                } catch (error) {
                    console.error('Failed to create cloud backup:', error);

                    // Reset button
                    const button = document.getElementById('create-cloud-backup-btn');
                    button.textContent = 'Backup to Cloud';
                    button.disabled = false;

                    alert(
                        ' Cloud Backup Failed\n\n' +
                        error.message + '\n\n' +
                        'Please check your internet connection and try again.'
                    );
                }
            }

            /**
             * Reset local data and sync fresh from cloud
             * Use this to fix duplicate records or data inconsistencies
             */
            async resetLocalDataAndSync() {
                try {
                    // Check if authenticated
                    if (!authManager.isAuthenticated()) {
                        alert('Please sign in first before resetting local data.\n\nGo to Settings  Cloud Sync section.');
                        return;
                    }

                    // Confirm with user
                    const confirmed = confirm(
                        ' Reset Local Data\n\n' +
                        'This will:\n' +
                        ' Delete ALL local data (localStorage)\n' +
                        ' Pull fresh data from cloud (DynamoDB)\n\n' +
                        'Make sure your important data is backed up to cloud first!\n\n' +
                        'Continue?'
                    );

                    if (!confirmed) {
                        return;
                    }

                    // Show loading state
                    const button = document.getElementById('reset-local-data-btn');
                    const originalText = button.textContent;
                    button.textContent = ' Resetting...';
                    button.disabled = true;

                    console.log(' Nuking localStorage...');

                    // Step 1: Clear ALL localStorage (nuclear option)
                    localStorage.clear();
                    console.log(' localStorage cleared');

                    // Step 2: Clear IndexedDB (browser backup system)
                    try {
                        const dbRequest = indexedDB.deleteDatabase('InjectionTrackerDB');
                        await new Promise((resolve, reject) => {
                            dbRequest.onsuccess = resolve;
                            dbRequest.onerror = reject;
                        });
                        console.log(' IndexedDB cleared');
                    } catch (e) {
                        console.warn('IndexedDB clear failed (may not exist):', e);
                    }

                    // Step 3: Reset in-memory data to empty state
                    this.data = {
                        injections: [],
                        weights: [],
                        vials: [],
                        settings: {
                            defaultDose: 2.0,
                            prefillDoseFrom: 'last',
                            injectionFrequency: 7,
                            heightCm: 175,
                            goalWeightKg: 80
                        }
                    };
                    console.log(' In-memory data reset');

                    // Step 4: Fetch fresh data from cloud (NO MERGE - direct replace)
                    console.log(' Fetching fresh data from cloud (direct replace)...');

                    try {
                        // Fetch all data from API (no merge, direct replacement)
                        const [injectionsAPI, weightsAPI, vialsAPI] = await Promise.all([
                            apiClient.getInjections(),
                            apiClient.getWeights(),
                            apiClient.getVials()
                        ]);

                        console.log(`Fetched from cloud: ${injectionsAPI.length} injections, ${weightsAPI.length} weights, ${vialsAPI.length} vials`);

                        // DIRECT REPLACEMENT (no merge)
                        this.data.injections = injectionsAPI.map(inj => ({
                            id: inj.id,
                            timestamp: inj.timestamp,
                            dose_mg: inj.doseMg,
                            injection_site: inj.site,
                            vial_id: inj.vialId,
                            notes: inj.notes || ''
                        }));

                        this.data.weights = weightsAPI.map(wt => ({
                            id: wt.id,
                            timestamp: wt.timestamp,
                            weight_kg: wt.weightKg,
                            notes: wt.notes || ''
                        }));

                        this.data.vials = vialsAPI.map(vial => ({
                            vial_id: vial.vial_id,
                            order_date: vial.order_date,
                            reconstitution_date: vial.reconstitution_date,
                            expiration_date: vial.expiration_date,
                            total_mg: vial.total_mg,
                            bac_water_ml: vial.bac_water_ml,
                            concentration_mg_ml: vial.concentration_mg_ml,
                            current_volume_ml: vial.current_volume_ml,
                            remaining_ml: vial.current_volume_ml,
                            status: vial.status,
                            supplier: vial.supplier || '',
                            lot_number: vial.lot_number || '',
                            doses_used: vial.doses_used || 0,
                            notes: vial.notes || '',
                            used_volume_ml: vial.used_volume_ml
                        }));

                        // Fetch settings
                        const settingsAPI = await apiClient.getSettings();
                        if (settingsAPI && Object.keys(settingsAPI).length > 0) {
                            this.data.settings = { ...this.data.settings, ...settingsAPI };
                        }

                        console.log(' Cloud data fetched and replaced');
                    } catch (error) {
                        console.error('Failed to fetch from cloud:', error);
                        throw new Error(`Cloud sync failed: ${error.message}`);
                    }

                    // Step 5: Update UI
                    this.updateUI();

                    // Reset button
                    button.textContent = originalText;
                    button.disabled = false;

                    // Show success message
                    alert(
                        ' Local Data Reset Complete!\n\n' +
                        `Injections: ${this.data.injections.length}\n` +
                        `Vials: ${this.data.vials.length}\n` +
                        `Weights: ${this.data.weights.length}\n\n` +
                        'Your app now shows fresh data from cloud.'
                    );

                    console.log(' Reset complete!');

                } catch (error) {
                    console.error('Failed to reset local data:', error);

                    // Reset button
                    const button = document.getElementById('reset-local-data-btn');
                    button.textContent = ' Reset Local Data & Sync from Cloud';
                    button.disabled = false;

                    alert(
                        ' Reset Failed\n\n' +
                        error.message + '\n\n' +
                        'Please check your internet connection and try again.'
                    );
                }
            }

            updateCloudBackupStatus() {
                const statusEl = document.getElementById('cloud-backup-status');
                const timestampEl = document.getElementById('cloud-backup-timestamp');
                const lastDiv = document.getElementById('cloud-backup-last');
                const nextBackupEl = document.getElementById('next-backup-date');

                if (authManager.isAuthenticated()) {
                    statusEl.textContent = ' Ready';
                    statusEl.style.color = 'var(--success-color)';

                    // Check for last backup
                    const lastBackup = localStorage.getItem('lastCloudBackup');
                    if (lastBackup) {
                        const backup = JSON.parse(lastBackup);
                        timestampEl.textContent = new Date(backup.timestamp).toLocaleString();
                        lastDiv.style.display = 'flex';
                    }

                    // Calculate next scheduled backup (next Monday at 9 AM)
                    const nextMonday = this.getNextMonday();
                    if (nextBackupEl) {
                        nextBackupEl.textContent = nextMonday.toLocaleString('en-US', {
                            weekday: 'long',
                            month: 'short',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                    }
                } else {
                    statusEl.textContent = 'Not authenticated';
                    statusEl.style.color = 'var(--text-muted)';
                    lastDiv.style.display = 'none';
                }
            }

            getNextMonday() {
                const now = new Date();
                const dayOfWeek = now.getDay();
                const daysUntilMonday = dayOfWeek === 0 ? 1 : (8 - dayOfWeek);

                const nextMonday = new Date(now);
                nextMonday.setDate(now.getDate() + daysUntilMonday);
                nextMonday.setHours(9, 0, 0, 0);

                return nextMonday;
            }

            async checkAutoBackup() {
                // Only run if authenticated
                if (!authManager.isAuthenticated()) {
                    return;
                }

                const lastBackup = localStorage.getItem('lastCloudBackup');
                const now = new Date();

                // Check if it's Monday and between 9 AM and 10 AM
                const dayOfWeek = now.getDay();
                const hour = now.getHours();

                if (dayOfWeek !== 1 || hour !== 9) {
                    // Not Monday morning, skip
                    return;
                }

                // If we have a last backup, check if it was within the last 7 days
                if (lastBackup) {
                    const backup = JSON.parse(lastBackup);
                    const lastBackupDate = new Date(backup.timestamp);
                    const daysSinceLastBackup = (now - lastBackupDate) / (1000 * 60 * 60 * 24);

                    if (daysSinceLastBackup < 7) {
                        console.log('Auto-backup skipped: Recent backup exists');
                        return;
                    }
                }

                // Check if we already did an auto-backup today
                const lastAutoBackup = localStorage.getItem('lastAutoBackupDate');
                if (lastAutoBackup) {
                    const lastAutoDate = new Date(lastAutoBackup);
                    if (lastAutoDate.toDateString() === now.toDateString()) {
                        console.log('Auto-backup already done today');
                        return;
                    }
                }

                console.log('Performing automatic weekly backup...');

                // Create backup silently
                try {
                    const result = await apiClient.createBackup();

                    // Store last backup info
                    localStorage.setItem('lastCloudBackup', JSON.stringify({
                        timestamp: result.timestamp,
                        key: result.key
                    }));

                    // Mark that we did an auto-backup today
                    localStorage.setItem('lastAutoBackupDate', now.toISOString());

                    // Update UI
                    this.updateCloudBackupStatus();

                    console.log('Auto-backup completed successfully');
                } catch (error) {
                    console.error('Auto-backup failed:', error);
                }
            }

            openModal(modalId) {
                const overlay = document.getElementById('modal-overlay');
                const modal = document.getElementById(modalId);

                // Trigger haptic feedback
                this.triggerHaptic('light');

                // Set current date/time for date inputs with smart defaults
                const now = new Date();
                const localDateTime = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);

                if (modalId === 'add-shot-modal') {
                    // Smart default: Use last injection time + frequency
                    const lastInjection = this.data.injections[0];
                    if (lastInjection) {
                        const lastDate = new Date(lastInjection.timestamp);
                        const nextDate = new Date(lastDate.getTime() + this.data.settings.injectionFrequency * 24 * 60 * 60 * 1000);

                        // If next date is in the past or more than a week in future, use current time
                        if (nextDate <= now && nextDate >= new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)) {
                            const nextDateTime = new Date(nextDate.getTime() - nextDate.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                            document.getElementById('shot-date').value = nextDateTime;
                        } else {
                            document.getElementById('shot-date').value = localDateTime;
                        }
                    } else {
                        document.getElementById('shot-date').value = localDateTime;
                    }

                    // Pre-fill dose based on user preference
                    const shotDoseInput = document.getElementById('shot-dose');
                    const prefillFrom = this.data.settings.prefillDoseFrom || 'last';

                    if (shotDoseInput) {
                        if (prefillFrom === 'default') {
                            // Always use default dose
                            shotDoseInput.value = this.data.settings.defaultDose || 2.0;
                        } else if (prefillFrom === 'last' && lastInjection && lastInjection.dose_mg) {
                            // Use last injection's dose if available
                            shotDoseInput.value = lastInjection.dose_mg;
                        } else {
                            // Fallback to default dose if no last injection
                            shotDoseInput.value = this.data.settings.defaultDose || 2.0;
                        }
                    }

                    this.populateVialSelect();
                } else if (modalId === 'add-vial-modal') {
                    document.getElementById('vial-order-date').value = now.toISOString().split('T')[0];
                } else if (modalId === 'activate-vial-modal') {
                    document.getElementById('activate-reconstitution-date').value = localDateTime;
                    this.populateActivateVialDropdown();
                } else if (modalId === 'add-weight-modal') {
                    document.getElementById('weight-date').value = localDateTime;
                } else if (modalId === 'add-trt-injection-modal') {
                    // Set default date/time
                    document.getElementById('trt-injection-date').value = localDateTime;
                    // Populate TRT vial dropdown
                    this.populateTrtVialSelect();
                    // Reset finish vial checkbox and volume input
                    const finishVialCheckbox = document.getElementById('trt-finish-vial-checkbox');
                    const volumeInput = document.getElementById('trt-injection-volume');
                    if (finishVialCheckbox) {
                        finishVialCheckbox.checked = false;
                    }
                    if (volumeInput) {
                        volumeInput.disabled = false;
                        volumeInput.style.opacity = '1';
                        volumeInput.value = '';
                    }
                } else if (modalId === 'add-trt-vial-modal') {
                    // Set default expiry date (1 year from now)
                    const oneYearFromNow = new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000);
                    document.getElementById('trt-vial-expiry').value = oneYearFromNow.toISOString().split('T')[0];
                    // Hide opened date and remaining volume groups by default
                    const openedDateGroup = document.getElementById('trt-vial-opened-group');
                    const remainingVolumeGroup = document.getElementById('trt-vial-remaining-group');
                    if (openedDateGroup) {
                        openedDateGroup.style.display = 'none';
                    }
                    if (remainingVolumeGroup) {
                        remainingVolumeGroup.style.display = 'none';
                    }
                } else if (modalId === 'skip-trt-injection-modal') {
                    document.getElementById('skip-trt-injection-date').value = now.toISOString().split('T')[0];
                }

                overlay.style.display = 'flex';
                modal.style.display = 'block';
                document.body.style.overflow = 'hidden';
            }

            populateActivateVialDropdown() {
                const select = document.getElementById('activate-vial-id');
                select.innerHTML = '<option value="">Select a vial to activate...</option>';

                const dryStockVials = this.data.vials.filter(v => v.status === 'dry_stock');
                dryStockVials.forEach(vial => {
                    const option = document.createElement('option');
                    option.value = vial.vial_id;
                    option.textContent = `${vial.total_mg}mg from ${vial.supplier || 'Unknown'} (${new Date(vial.order_date).toLocaleDateString()})`;
                    select.appendChild(option);
                });
            }

            populateTrtVialSelect() {
                const select = document.getElementById('trt-injection-vial');
                if (!select) return;

                select.innerHTML = '<option value="">Select a vial...</option>';

                // Filter active TRT vials only
                const activeVials = this.data.trtVials.filter(v => v.status === 'active' && v.remaining_ml > 0);

                activeVials.forEach(vial => {
                    const option = document.createElement('option');
                    option.value = vial.id;
                    option.textContent = `${vial.concentration_mg_ml}mg/ml - ${vial.remaining_ml.toFixed(2)}ml remaining`;
                    if (vial.lot_number) {
                        option.textContent += ` (Lot: ${vial.lot_number})`;
                    }
                    select.appendChild(option);
                });

                if (activeVials.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No active vials available - add one first';
                    option.disabled = true;
                    select.appendChild(option);
                }
            }

            closeModal() {
                const overlay = document.getElementById('modal-overlay');
                const modals = document.querySelectorAll('.modal');

                overlay.style.display = 'none';
                modals.forEach(modal => modal.style.display = 'none');
                document.body.style.overflow = '';

                // Reset edit mode state
                this.editMode.active = false;
                this.editMode.entityType = null;
                this.editMode.entityId = null;
                this.editMode.originalData = null;

                // Reset modal titles and button text
                document.getElementById('add-shot-modal-title').textContent = 'Add New Shot';
                document.getElementById('shot-submit-btn').textContent = 'Add Shot';
                document.getElementById('add-weight-modal-title').textContent = 'Add Weight Entry';
                document.getElementById('weight-submit-btn').textContent = 'Add Weight';

                // Reset forms
                document.querySelectorAll('form').forEach(form => form.reset());
            }

            showEditInjectionModal(injectionId) {
                // Find injection by ID
                const injection = this.data.injections.find(inj => inj.id === injectionId);
                if (!injection) {
                    console.error('Injection not found:', injectionId);
                    return;
                }

                // Set edit mode state
                this.editMode.active = true;
                this.editMode.entityType = 'injection';
                this.editMode.entityId = injectionId;
                this.editMode.originalData = { ...injection };

                // Update modal title and button
                document.getElementById('add-shot-modal-title').textContent = 'Edit Shot';
                document.getElementById('shot-submit-btn').textContent = 'Save Changes';

                // Re-populate vial dropdown to ensure current active vials are shown
                this.populateVialSelect();

                // Pre-fill form with existing data
                document.getElementById('shot-date').value = new Date(injection.timestamp).toISOString().slice(0, 16);
                document.getElementById('shot-dose').value = injection.dose_mg;
                document.getElementById('shot-site').value = injection.injection_site;
                document.getElementById('shot-vial').value = injection.vial_id || '';
                document.getElementById('shot-notes').value = injection.notes || '';

                // Show modal
                document.getElementById('modal-overlay').style.display = 'block';
                document.getElementById('add-shot-modal').style.display = 'block';
                document.body.style.overflow = 'hidden';
            }

            showEditWeightModal(weightId) {
                // Find weight by ID
                const weight = this.data.weights.find(w => (w.id || w.timestamp) === weightId);
                if (!weight) {
                    console.error('Weight entry not found:', weightId);
                    return;
                }

                // Set edit mode state
                this.editMode.active = true;
                this.editMode.entityType = 'weight';
                this.editMode.entityId = weightId;
                this.editMode.originalData = { ...weight };

                // Update modal title and button
                document.getElementById('add-weight-modal-title').textContent = 'Edit Weight Entry';
                document.getElementById('weight-submit-btn').textContent = 'Save Changes';

                // Pre-fill form with existing data
                document.getElementById('weight-date').value = new Date(weight.timestamp).toISOString().slice(0, 16);
                document.getElementById('weight-kg').value = weight.weight_kg;
                document.getElementById('weight-body-fat').value = weight.body_fat_percentage || '';

                // Show modal
                document.getElementById('modal-overlay').style.display = 'block';
                document.getElementById('add-weight-modal').style.display = 'block';
                document.body.style.overflow = 'hidden';
            }

            showEditVialModal(vialId) {
                // Find vial by ID
                const vial = this.data.vials.find(v => v.id === vialId);
                if (!vial) {
                    console.error('Vial not found:', vialId);
                    return;
                }

                // Set edit mode state
                this.editMode.active = true;
                this.editMode.entityType = 'vial';
                this.editMode.entityId = vialId;
                this.editMode.originalData = { ...vial };

                // Update modal title and button
                document.getElementById('add-vial-modal-title').textContent = 'Edit Vial';
                document.getElementById('vial-submit-btn').textContent = 'Save Changes';

                // Pre-fill form with existing data
                document.getElementById('vial-order-date').value = vial.order_date ? new Date(vial.order_date).toISOString().slice(0, 10) : '';
                document.getElementById('vial-supplier').value = vial.supplier || '';
                document.getElementById('vial-mg').value = vial.total_mg || '';
                document.getElementById('vial-quantity').value = vial.quantity || 1;

                // Show modal
                document.getElementById('modal-overlay').style.display = 'block';
                document.getElementById('add-vial-modal').style.display = 'block';
                document.body.style.overflow = 'hidden';
            }

            showAddInjectionModal() {
                this.openModal('add-shot-modal');
            }

            showSkipWeekModal() {
                // Trigger haptic feedback
                this.triggerHaptic('light');

                // Calculate next expected shot date
                const now = new Date();
                const lastInjection = this.data.injections[0];
                let nextDate = now;

                if (lastInjection) {
                    const lastDate = new Date(lastInjection.timestamp);
                    nextDate = new Date(lastDate.getTime() + this.data.settings.injectionFrequency * 24 * 60 * 60 * 1000);

                    // If next date is more than a week in the future or past, use current time
                    if (nextDate > new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000) ||
                        nextDate < new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)) {
                        nextDate = now;
                    }
                }

                // Pre-fill form
                const nextDateTime = new Date(nextDate.getTime() - nextDate.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                document.getElementById('skip-shot-date').value = nextDateTime;

                // Pre-fill planned dose
                const prefillFrom = this.data.settings.prefillDoseFrom || 'last';
                let plannedDose = this.data.settings.defaultDose || 2.0;

                if (prefillFrom === 'last' && lastInjection && lastInjection.dose_mg) {
                    plannedDose = lastInjection.dose_mg;
                }

                document.getElementById('skip-planned-dose').value = plannedDose;

                // Show modal
                document.getElementById('modal-overlay').style.display = 'flex';
                document.getElementById('skip-shot-modal').style.display = 'block';
                document.body.style.overflow = 'hidden';
            }

            populateVialSelect() {
                const select = document.getElementById('shot-vial');
                select.innerHTML = '<option value="">Select vial</option>';

                // Filter for active vials with remaining volume
                const activeVials = this.data.vials.filter(v => {
                    // Support both 'active' and 'activated' status
                    const isActive = v.status === 'active' || v.status === 'activated';
                    // Check both property names for backwards compatibility (Hotfix)
                    const hasVolume = (v.current_volume_ml || v.remaining_ml || 0) > 0;

                    return isActive && hasVolume;
                });

                activeVials.forEach(vial => {
                    const option = document.createElement('option');
                    option.value = vial.vial_id;
                    const concentration = vial.concentration_mg_per_ml || vial.concentration_mg_ml || 0;
                    const remaining = vial.current_volume_ml || vial.remaining_ml || 0;
                    option.textContent = `${vial.total_mg}mg (${concentration.toFixed(1)} mg/ml) - ${remaining.toFixed(2)}ml left`;
                    select.appendChild(option);
                });

                if (activeVials.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No active vials available';
                    option.disabled = true;
                    select.appendChild(option);
                }
            }

            async handleAddShot() {
                try {
                    const form = document.getElementById('add-shot-form');

                    // Validate form before processing
                    if (!form.checkValidity()) {
                        form.reportValidity();
                        return;
                    }

                    // Get and validate dose
                    const doseMg = parseFloat(document.getElementById('shot-dose').value);
                    if (isNaN(doseMg) || doseMg <= 0 || doseMg > 50) {
                        alert('Please enter a valid dose between 0 and 50 mg');
                        return;
                    }

                    // Validate vial selection
                    const vialId = document.getElementById('shot-vial').value;
                    if (!vialId) {
                        alert('Please select a vial');
                        return;
                    }

                    const injection = {
                        timestamp: new Date(document.getElementById('shot-date').value).toISOString(),
                        dose_mg: doseMg,
                        injection_site: document.getElementById('shot-site').value,
                        vial_id: vialId,
                        notes: document.getElementById('shot-notes').value
                    };

                    // Check if in edit mode
                    if (this.editMode.active && this.editMode.entityType === 'injection') {
                        await this.updateInjection(this.editMode.entityId, injection);
                    } else {
                        await this.addInjection(injection);
                    }

                    // Reset form after successful submission
                    form.reset();

                } catch (error) {
                    console.error('Error adding shot:', error);
                    alert('Shot saved locally. Cloud sync will retry automatically.');
                } finally {
                    // Always close modal, even on error
                    setTimeout(() => {
                        this.closeModal();
                    }, 300);
                }
            }

            async handleSkipShot() {
                try {
                    const form = document.getElementById('skip-shot-form');

                    // Validate form before processing
                    if (!form.checkValidity()) {
                        form.reportValidity();
                        return;
                    }

                    const plannedDose = parseFloat(document.getElementById('skip-planned-dose').value);

                    // Create skipped injection record
                    const injection = {
                        timestamp: new Date(document.getElementById('skip-shot-date').value).toISOString(),
                        dose_mg: 0,
                        injection_site: null,
                        vial_id: null,
                        notes: document.getElementById('skip-reason').value || 'Skipped',
                        skipped: true,
                        planned_dose_mg: plannedDose
                    };

                    await this.addInjection(injection);

                    // Reset form after successful submission
                    form.reset();

                } catch (error) {
                    console.error('Error recording skipped shot:', error);
                    alert('Skip recorded locally. Cloud sync will retry automatically.');
                } finally {
                    // Always close modal, even on error
                    setTimeout(() => {
                        this.closeModal();
                    }, 300);
                }
            }

            async handleAddVial() {
                const orderDate = document.getElementById('vial-order-date').value;
                const supplier = document.getElementById('vial-supplier').value;
                const totalMg = parseFloat(document.getElementById('vial-mg').value);
                const quantity = parseInt(document.getElementById('vial-quantity').value) || 1;

                if (!orderDate || !totalMg || !quantity) {
                    alert('Please fill in all required fields');
                    return;
                }

                // Check if this is an edit operation
                if (this.editMode.active && this.editMode.entityType === 'vial') {
                    // Update existing vial
                    const vial = {
                        order_date: orderDate,
                        supplier: supplier,
                        total_mg: totalMg,
                        quantity: quantity
                    };

                    try {
                        await this.updateVial(this.editMode.entityId, vial);
                        this.closeModal();
                    } catch (error) {
                        console.error('Failed to update vial:', error);
                        alert('Failed to update vial: ' + error.message);
                    }
                    return;
                }

                // Add multiple vials to dry stock
                const newVials = [];
                for (let i = 0; i < quantity; i++) {
                    const vial = {
                        vial_id: this.generateId(),
                        order_date: orderDate,
                        supplier: supplier || '',
                        total_mg: totalMg,
                        bac_water_ml: null,
                        concentration_mg_ml: null,
                        reconstitution_date: null,
                        expiration_date: this.calculateExpirationDate(null, orderDate),
                        remaining_ml: 0,
                        doses_used: 0,
                        status: 'dry_stock'
                    };

                    this.data.vials.push(vial);
                    newVials.push(vial);
                }

                this.data.vials.sort((a, b) => new Date(b.order_date) - new Date(a.order_date));
                this.saveData();
                this.updateUI();

                // Push all new vials to sync queue (Phase 1B: Reliable sync with retry)
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    for (const vial of newVials) {
                        this.syncQueue.add({
                            type: 'create',
                            entity: 'vial',
                            localId: vial.vial_id,
                            data: {
                                id: vial.vial_id,
                                orderDate: vial.order_date,
                                totalMg: totalMg,
                                supplier: vial.supplier || '',
                                status: vial.status,
                                currentVolumeMl: 0,
                                usedVolumeMl: 0,
                                remainingMl: 0,
                                dosesUsed: 0,
                                notes: `${totalMg}mg dry stock`
                            }
                        });
                        console.log(`Vial ${vial.vial_id} (${totalMg}mg dry_stock) added to sync queue`);
                    }
                }

                // Delay modal close to show save indicator
                setTimeout(() => {
                    this.closeModal();
                }, 300);
            }

            openEditVialModal(vialId) {
                const vial = this.findVialById(vialId);
                if (!vial) {
                    alert('Vial not found');
                    return;
                }

                // Populate the form with vial data
                document.getElementById('edit-vial-id').value = vial.vial_id;
                document.getElementById('edit-vial-order-date').value = new Date(vial.order_date).toISOString().split('T')[0];
                document.getElementById('edit-vial-supplier').value = vial.supplier || '';
                document.getElementById('edit-vial-mg').value = vial.total_mg;

                // Show volume field for active vials
                const volumeGroup = document.getElementById('edit-vial-volume-group');
                const volumeInput = document.getElementById('edit-vial-current-volume');
                if (vial.status === 'active' || vial.status === 'insufficient' || vial.status === 'expiring') {
                    volumeGroup.style.display = 'block';
                    const currentVol = vial.current_volume_ml || vial.remaining_ml || 0;
                    volumeInput.value = currentVol.toFixed(2);
                } else {
                    volumeGroup.style.display = 'none';
                    volumeInput.value = '';
                }

                // Open the modal
                this.openModal('edit-vial-modal');
            }

            async handleEditVial() {
                const vialId = document.getElementById('edit-vial-id').value;
                const orderDate = document.getElementById('edit-vial-order-date').value;
                const supplier = document.getElementById('edit-vial-supplier').value;
                const totalMg = parseFloat(document.getElementById('edit-vial-mg').value);
                const currentVolumeInput = document.getElementById('edit-vial-current-volume');
                const newVolume = currentVolumeInput.value ? parseFloat(currentVolumeInput.value) : null;

                if (!vialId || !orderDate || !totalMg) {
                    alert('Please fill in all required fields');
                    return;
                }

                const vial = this.findVialById(vialId);
                if (!vial) {
                    alert('Vial not found');
                    return;
                }

                // Update vial properties
                vial.order_date = orderDate;
                vial.supplier = supplier || '';
                vial.total_mg = totalMg;

                // Update current volume if provided (active vials only)
                if (newVolume !== null && (vial.status === 'active' || vial.status === 'insufficient' || vial.status === 'expiring')) {
                    vial.current_volume_ml = newVolume;
                    vial.remaining_ml = newVolume;
                    vial.used_volume_ml = vial.bac_water_ml ? (vial.bac_water_ml - newVolume) : 0;

                    // Update status based on new volume
                    if (newVolume <= 0) {
                        vial.status = 'empty';
                    } else if (vial.status === 'empty' || vial.status === 'insufficient') {
                        vial.status = 'active';
                    }

                    console.log(`Manually adjusted vial ${vialId} volume to ${newVolume.toFixed(2)}ml`);
                }

                // If vial is activated, update concentration
                if (vial.bac_water_ml && vial.bac_water_ml > 0) {
                    vial.concentration_mg_ml = totalMg / vial.bac_water_ml;
                }

                // Update expiration date if vial hasn't been activated
                if (vial.status === 'dry_stock') {
                    vial.expiration_date = this.calculateExpirationDate(null, orderDate);
                }

                this.data.vials.sort((a, b) => new Date(b.order_date) - new Date(a.order_date));
                this.saveData();
                this.updateUI();

                // Push update to sync queue (use correct property names for PATCH)
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'update',
                        entity: 'vial',
                        localId: vial.vial_id,
                        data: {
                            id: vial.vial_id,
                            currentVolumeMl: vial.current_volume_ml || vial.remaining_ml || 0,
                            usedVolumeMl: vial.used_volume_ml || 0,
                            status: vial.status,
                            notes: vial.notes || `${totalMg}mg vial`
                        }
                    });
                    console.log(`Vial ${vial.vial_id} update added to sync queue`);
                }

                // Delay modal close to show save indicator
                setTimeout(() => {
                    this.closeModal();
                }, 300);
            }

            async handleActivateVial() {
                const vialId = document.getElementById('activate-vial-id').value;
                const bacWaterMl = parseFloat(document.getElementById('activate-bac-water').value);
                const reconstitutionDateRaw = document.getElementById('activate-reconstitution-date').value;

                if (!vialId || !bacWaterMl || !reconstitutionDateRaw) {
                    alert('Please fill in all required fields');
                    return;
                }

                const vial = this.findVialById(vialId);
                if (!vial || vial.status !== 'dry_stock') {
                    alert('Invalid vial selected');
                    return;
                }

                // Convert to ISO string
                const reconstitutionDate = new Date(reconstitutionDateRaw).toISOString();

                // Calculate concentration and expiration
                const concentrationMgMl = vial.total_mg / bacWaterMl;
                const expirationDate = this.calculateExpirationDate(reconstitutionDate, null);

                // Update vial to active status
                vial.bac_water_ml = bacWaterMl;
                vial.concentration_mg_ml = concentrationMgMl;
                vial.reconstitution_date = reconstitutionDate;
                vial.expiration_date = expirationDate;
                vial.remaining_ml = bacWaterMl; // Start with full volume
                vial.current_volume_ml = bacWaterMl; // Sync property for consistency (Hotfix)
                vial.status = 'active';

                this.saveData();
                this.updateUI();

                // Push activated vial to sync queue - use 'update' since vial already exists
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'update',  // PATCH endpoint - vial already exists as dry_stock
                        entity: 'vial',
                        localId: vial.vial_id,
                        data: {
                            id: vial.vial_id,
                            reconstitutionDate: reconstitutionDate,
                            expirationDate: expirationDate,
                            bacWaterMl: bacWaterMl,
                            concentrationMgMl: concentrationMgMl,
                            currentVolumeMl: bacWaterMl,
                            usedVolumeMl: 0,
                            status: 'active',
                            notes: vial.notes || `Activated with ${bacWaterMl}ml BAC water`
                        }
                    });
                    console.log(`Vial ${vial.vial_id} activation (${concentrationMgMl.toFixed(1)}mg/ml) added to sync queue`);
                }

                // Delay modal close to show save indicator
                setTimeout(() => {
                    this.closeModal();
                }, 300);
            }

            async handleAddWeight() {
                try {
                    const weight = {
                        timestamp: new Date(document.getElementById('weight-date').value).toISOString(),
                        weight_kg: parseFloat(document.getElementById('weight-kg').value),
                        body_fat_percentage: document.getElementById('weight-body-fat').value ?
                            parseFloat(document.getElementById('weight-body-fat').value) : null,
                        source: 'manual'
                    };

                    // Check if in edit mode
                    if (this.editMode.active && this.editMode.entityType === 'weight') {
                        await this.updateWeight(this.editMode.entityId, weight);
                    } else {
                        await this.addWeight(weight);
                    }
                } catch (error) {
                    console.error('Error adding weight:', error);
                    alert('Weight saved locally. Cloud sync will retry automatically.');
                } finally {
                    // Always close modal, even on error
                    setTimeout(() => {
                        this.closeModal();
                    }, 300);
                }
            }

            // ====================================
            // TRT FORM HANDLERS
            // ====================================

            async handleAddTrtInjection() {
                try {
                    const form = document.getElementById('add-trt-injection-form');

                    // Validate form before processing
                    if (!form.checkValidity()) {
                        form.reportValidity();
                        return;
                    }

                    const volumeMl = parseFloat(document.getElementById('trt-injection-volume').value);
                    const vialId = document.getElementById('trt-injection-vial').value;

                    if (isNaN(volumeMl) || volumeMl <= 0) {
                        alert('Please enter a valid volume');
                        return;
                    }

                    if (!vialId) {
                        alert('Please select a vial');
                        return;
                    }

                    const vial = this.findTrtVialById(vialId);
                    if (!vial) {
                        alert('Vial not found');
                        return;
                    }

                    // Check if trying to use more than remaining volume
                    if (volumeMl > vial.remaining_ml) {
                        alert(`Cannot use ${volumeMl}ml - only ${vial.remaining_ml.toFixed(2)}ml remaining in this vial`);
                        return;
                    }

                    const injection = {
                        timestamp: new Date(document.getElementById('trt-injection-date').value).toISOString(),
                        volume_ml: volumeMl,
                        concentration_mg_ml: vial.concentration_mg_ml,
                        injection_site: document.getElementById('trt-injection-site').value,
                        time_of_day: document.getElementById('trt-injection-time-of-day').value || null,
                        technique_notes: document.getElementById('trt-injection-technique').value || '',
                        notes: document.getElementById('trt-injection-notes').value || '',
                        vial_id: vialId,
                        skipped: false
                    };

                    await this.addTrtInjection(injection);

                    // Reset form after successful submission
                    form.reset();

                    // Also reset the volume input state (in case it was disabled)
                    const volumeInput = document.getElementById('trt-injection-volume');
                    if (volumeInput) {
                        volumeInput.disabled = false;
                        volumeInput.style.opacity = '1';
                    }

                } catch (error) {
                    console.error('Error adding TRT injection:', error);
                    alert('TRT injection saved locally. Cloud sync will retry automatically.');
                } finally {
                    // Always close modal, even on error
                    setTimeout(() => {
                        this.closeModal();
                    }, 300);
                }
            }

            async handleAddTrtVial() {
                try {
                    const form = document.getElementById('add-trt-vial-form');

                    // Validate form before processing
                    if (!form.checkValidity()) {
                        form.reportValidity();
                        return;
                    }

                    const concentrationMgMl = parseFloat(document.getElementById('trt-vial-concentration').value);
                    const volumeMl = parseFloat(document.getElementById('trt-vial-volume').value);
                    const expiryDate = document.getElementById('trt-vial-expiry').value;
                    const status = document.getElementById('trt-vial-status').value;

                    if (isNaN(concentrationMgMl) || concentrationMgMl <= 0) {
                        alert('Please enter a valid concentration');
                        return;
                    }

                    if (isNaN(volumeMl) || volumeMl <= 0) {
                        alert('Please enter a valid volume');
                        return;
                    }

                    if (!expiryDate) {
                        alert('Please enter an expiry date');
                        return;
                    }

                    const vial = {
                        concentration_mg_ml: concentrationMgMl,
                        volume_ml: volumeMl,
                        lot_number: document.getElementById('trt-vial-lot').value || '',
                        expiry_date: new Date(expiryDate).toISOString(),
                        status: status,
                        notes: document.getElementById('trt-vial-notes').value || ''
                    };

                    // Add opened date and remaining volume if status is active
                    if (status === 'active') {
                        const openedDate = document.getElementById('trt-vial-opened').value;
                        if (openedDate) {
                            vial.opened_date = new Date(openedDate).toISOString();
                        }

                        // Add remaining volume if specified
                        const remainingMl = document.getElementById('trt-vial-remaining').value;
                        if (remainingMl && parseFloat(remainingMl) > 0) {
                            vial.remaining_ml = parseFloat(remainingMl);

                            // Validate that remaining doesn't exceed total
                            if (vial.remaining_ml > volumeMl) {
                                alert(`Remaining volume (${vial.remaining_ml}ml) cannot exceed total volume (${volumeMl}ml)`);
                                return;
                            }
                        }
                    }

                    await this.addTrtVial(vial);

                    // Reset form after successful submission
                    form.reset();

                } catch (error) {
                    console.error('Error adding TRT vial:', error);
                    alert('TRT vial saved locally. Cloud sync will retry automatically.');
                } finally {
                    // Always close modal, even on error
                    setTimeout(() => {
                        this.closeModal();
                    }, 300);
                }
            }

            async handleAddTrtSymptom() {
                try {
                    // Get form values
                    const energyLevel = parseInt(document.getElementById('trt-energy').value);
                    const mood = parseInt(document.getElementById('trt-mood').value);
                    const libido = parseInt(document.getElementById('trt-libido').value);
                    const sleepQuality = parseInt(document.getElementById('trt-sleep').value);
                    const notes = document.getElementById('trt-symptom-notes').value || '';

                    // Create symptom entry
                    const symptom = {
                        timestamp: new Date().toISOString(),
                        energyLevel: energyLevel,
                        mood: mood,
                        libido: libido,
                        sleepQuality: sleepQuality,
                        notes: notes
                    };

                    await this.addTrtSymptom(symptom);

                    // Show success notification
                    if (window.deleteManager && window.deleteManager.notificationManager) {
                        window.deleteManager.notificationManager.show('success', 'Symptom check-in saved successfully');
                    }

                    // Reset form to default values
                    document.getElementById('trt-energy').value = 5;
                    document.getElementById('trt-energy-value').textContent = '5';
                    document.getElementById('trt-mood').value = 5;
                    document.getElementById('trt-mood-value').textContent = '5';
                    document.getElementById('trt-libido').value = 5;
                    document.getElementById('trt-libido-value').textContent = '5';
                    document.getElementById('trt-sleep').value = 5;
                    document.getElementById('trt-sleep-value').textContent = '5';
                    document.getElementById('trt-symptom-notes').value = '';

                } catch (error) {
                    console.error('Error adding TRT symptom:', error);
                    if (window.deleteManager && window.deleteManager.notificationManager) {
                        window.deleteManager.notificationManager.show('error', 'Failed to save symptom check-in');
                    }
                }
            }

            async handleSaveTrtSettings() {
                try {
                    // Get values from form
                    const injectionFrequency = parseFloat(document.getElementById('trt-injection-frequency').value);
                    const defaultDoseMg = parseFloat(document.getElementById('trt-default-dose-mg').value);
                    const defaultDoseMl = parseFloat(document.getElementById('trt-default-dose-ml').value);
                    const concentration = parseFloat(document.getElementById('trt-concentration').value);

                    // Validate inputs
                    if (!injectionFrequency || !defaultDoseMg || !defaultDoseMl || !concentration) {
                        if (window.deleteManager && window.deleteManager.notificationManager) {
                            window.deleteManager.notificationManager.show('error', 'Please fill in all TRT settings fields');
                        }
                        return;
                    }

                    // Update local data
                    this.data.trtSettings.injectionFrequency = injectionFrequency;
                    this.data.trtSettings.defaultDoseMg = defaultDoseMg;
                    this.data.trtSettings.defaultDoseMl = defaultDoseMl;
                    this.data.trtSettings.concentrationMgMl = concentration;

                    // Save to localStorage
                    this.saveData();

                    // Sync to cloud
                    await this.syncSettingsToCloud();

                    // Show success notification
                    if (window.deleteManager && window.deleteManager.notificationManager) {
                        window.deleteManager.notificationManager.show('success', 'TRT settings saved successfully');
                    }

                } catch (error) {
                    console.error('Error saving TRT settings:', error);
                    if (window.deleteManager && window.deleteManager.notificationManager) {
                        window.deleteManager.notificationManager.show('error', 'Failed to save TRT settings');
                    }
                }
            }

            async handleSkipTrtInjection() {
                try {
                    const form = document.getElementById('skip-trt-injection-form');

                    // Validate form before processing
                    if (!form.checkValidity()) {
                        form.reportValidity();
                        return;
                    }

                    const scheduledDate = document.getElementById('skip-trt-injection-date').value;
                    const reason = document.getElementById('skip-trt-injection-reason').value;

                    // Get user's typical dose to show what was skipped
                    const weeklyDose = this.calculateTrtWeeklyDose();

                    const injection = {
                        timestamp: new Date(scheduledDate).toISOString(),
                        volume_ml: 0,
                        concentration_mg_ml: 0,
                        injection_site: null,
                        vial_id: null,
                        notes: reason || 'Skipped injection',
                        skipped: true,
                        planned_dose_mg: weeklyDose // Store what was planned
                    };

                    await this.addTrtInjection(injection);

                    // Reset form after successful submission
                    form.reset();

                } catch (error) {
                    console.error('Error recording skipped TRT injection:', error);
                    alert('Skip recorded locally. Cloud sync will retry automatically.');
                } finally {
                    // Always close modal, even on error
                    setTimeout(() => {
                        this.closeModal();
                    }, 300);
                }
            }

            showSkipTrtInjectionModal() {
                // Populate planned dose
                const weeklyDose = this.calculateTrtWeeklyDose();
                const plannedDoseEl = document.getElementById('skip-trt-planned-dose');
                if (plannedDoseEl) {
                    plannedDoseEl.value = weeklyDose.toFixed(1);
                }

                // Set default date to today
                const dateInput = document.getElementById('skip-trt-injection-date');
                if (dateInput && !dateInput.value) {
                    dateInput.value = new Date().toISOString().split('T')[0];
                }

                this.openModal('skip-trt-injection-modal');
            }

            findTrtVialById(vialId) {
                return this.data.trtVials.find(v => v.id === vialId);
            }

            // ====================================
            // END TRT FORM HANDLERS
            // ====================================

            createShotListItem(injection) {
                const div = document.createElement('div');
                div.className = injection.skipped ? 'shot-item skipped' : 'shot-item';
                div.setAttribute('data-item-id', injection.id);
                div.setAttribute('data-timestamp', injection.timestamp);

                if (injection.skipped) {
                    // Skipped injection display
                    const plannedDose = injection.planned_dose_mg || injection.dose_mg || 0;
                    div.innerHTML = `
                        <div class="shot-content">
                            <div class="shot-header">
                                <div class="shot-dose">
                                    ${plannedDose} mg
                                    <span class="skipped-badge">SKIPPED</span>
                                </div>
                                <div class="shot-date">${this.formatDate(injection.timestamp)}</div>
                            </div>
                            <div class="shot-details">
                                <div>Reason: ${injection.notes || 'Not specified'}</div>
                            </div>
                        </div>
                        <div class="item-actions">
                            <button class="delete-btn" aria-label="Delete skipped entry" title="Delete this skipped entry">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                                    <path d="M10 11v6M14 11v6"/>
                                </svg>
                            </button>
                        </div>
                        <div class="delete-action">Delete</div>
                    `;
                } else {
                    // Normal injection display
                    div.innerHTML = `
                        <div class="shot-content">
                            <div class="shot-header">
                                <div class="shot-dose">${injection.dose_mg} mg</div>
                                <div class="shot-date">${this.formatDate(injection.timestamp)}</div>
                            </div>
                            <div class="shot-details">
                                <div>Site: ${this.formatInjectionSite(injection.injection_site)}</div>
                            </div>
                        </div>
                        <div class="item-actions">
                        <button class="edit-btn" data-entity-type="injection" data-entity-id="${injection.id}" aria-label="Edit injection" title="Edit this injection">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                        <button class="delete-btn" aria-label="Delete injection" title="Delete this injection">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                                <path d="M10 11v6M14 11v6"/>
                            </svg>
                        </button>
                        </div>
                        <div class="delete-action">Delete</div>
                    `;
                }

                // Add swipe to delete handlers
                this.addSwipeToDeleteHandlers(div);

                return div;
            }

            createVialListItem(vial) {
                const div = document.createElement('div');
                div.className = `vial-item ${vial.status}`;
                div.setAttribute('data-item-id', vial.vial_id);
                div.setAttribute('data-timestamp', vial.order_date);

                if (vial.status === 'dry_stock') {
                    div.innerHTML = `
                        <div class="vial-content">
                            <div class="vial-header">
                                <div class="vial-info">
                                    <div class="vial-title">${vial.total_mg}mg Vial</div>
                                    <div class="vial-subtitle">${vial.supplier || 'Unknown Supplier'}</div>
                                    <div class="vial-subtitle">Ordered: ${this.formatDate(vial.order_date)}</div>
                                </div>
                                <div class="vial-status dry_stock">Dry Stock</div>
                            </div>
                            <div class="vial-details">
                                <div class="vial-detail-row">
                                    <span>Status:</span>
                                    <span>Ready for activation with BAC water</span>
                                </div>
                                <div class="vial-detail-row">
                                    <span>Powder Expires:</span>
                                    <span>${vial.expiration_date ? this.formatDate(vial.expiration_date) : 'Not set'}</span>
                                </div>
                            </div>
                        </div>
                        <button class="edit-btn" aria-label="Edit vial" title="Edit this vial">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                        <button class="delete-btn" aria-label="Delete vial" title="Delete this vial">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                                <path d="M10 11v6M14 11v6"/>
                            </svg>
                        </button>
                    `;
                    return div;
                }

                // Handle active and other statuses
                const now = new Date();
                const expirationDate = new Date(vial.expiration_date);
                const isExpired = expirationDate < now;
                const daysUntilExpiry = Math.ceil((expirationDate - now) / (1000 * 60 * 60 * 24));

                let status = vial.status;
                let statusText = vial.status === 'active' ? 'Active' : vial.status;

                if (vial.status === 'active') {
                    const currentVolume = vial.remaining_ml || vial.current_volume_ml || 0;
                    if (isExpired) {
                        status = 'expired';
                        statusText = 'Expired';
                    } else if (daysUntilExpiry <= 3) {
                        status = 'expiring';
                        statusText = `${daysUntilExpiry}d left`;
                    } else if (currentVolume <= 0) {
                        status = 'empty';
                        statusText = 'Empty';
                    }
                }

                // Calculate remaining doses based on default dose from settings
                const defaultDose = this.data.settings.defaultDose || 2.0;
                const remainingMl = vial.remaining_ml || vial.current_volume_ml || 0;
                const remainingDoses = vial.concentration_mg_ml ? ((remainingMl * vial.concentration_mg_ml) / defaultDose).toFixed(1) : 0;

                // Calculate actual doses used by counting injections from this vial
                const vialId = this.getVialId(vial);
                const actualDosesUsed = this.data.injections.filter(inj => inj.vial_id === vialId).length;

                div.innerHTML = `
                    <div class="vial-content">
                        <div class="vial-header">
                            <div class="vial-info">
                                <div class="vial-title">${vial.total_mg || 0}mg Vial</div>
                                <div class="vial-subtitle">${vial.supplier || 'Unknown Supplier'}</div>
                                <div class="vial-subtitle">Ordered: ${this.formatDate(vial.order_date)}</div>
                            </div>
                            <div class="vial-status ${status}">${statusText}</div>
                        </div>
                        <div class="vial-details">
                            ${vial.concentration_mg_ml ? `
                            <div class="vial-detail-row">
                                <span>Concentration:</span>
                                <span>${vial.concentration_mg_ml.toFixed(1)} mg/ml</span>
                            </div>
                            <div class="vial-detail-row">
                                <span>Remaining:</span>
                                <span>${remainingMl.toFixed(2)} ml (${remainingDoses} doses)</span>
                            </div>
                            <div class="vial-detail-row">
                                <span>Reconstituted:</span>
                                <span>${this.formatDate(vial.reconstitution_date)}</span>
                            </div>
                            ` : `
                            <div class="vial-detail-row">
                                <span>Status:</span>
                                <span>Ready for activation with BAC water</span>
                            </div>
                            `}
                            <div class="vial-detail-row">
                                <span>Expires:</span>
                                <span>${vial.expiration_date ? this.formatDate(vial.expiration_date) : 'Not set'}</span>
                            </div>
                            ${vial.concentration_mg_ml ? `
                            <div class="vial-detail-row">
                                <span>Doses Used:</span>
                                <span>${actualDosesUsed}</span>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    <div class="item-actions">
                        <button class="edit-btn" data-entity-type="vial" data-entity-id="${vial.id}" aria-label="Edit vial" title="Edit this vial">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                        <button class="delete-btn" aria-label="Delete vial" title="Delete this vial">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                                <path d="M10 11v6M14 11v6"/>
                            </svg>
                        </button>
                    </div>
                `;
                return div;
            }

            // Calculate skip rate from historical injection data
            calculateSkipRate() {
                const injections = this.data.injections || [];
                if (injections.length < 2) {
                    return { skipRate: 0, totalWeeks: 0, skippedWeeks: 0 };
                }

                // Sort by date
                const sorted = [...injections].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const firstDate = new Date(sorted[0].timestamp);
                const lastDate = new Date(sorted[sorted.length - 1].timestamp);

                // Calculate total calendar weeks tracked
                const daysDiff = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
                const totalWeeks = daysDiff / 7;

                // Count skipped injections
                const skippedCount = injections.filter(inj => inj.skipped === true).length;

                // Calculate skip rate (what percentage of weeks are skipped)
                const skipRate = totalWeeks > 0 ? skippedCount / totalWeeks : 0;

                console.log(`[SkipRate] ${skippedCount} skips over ${totalWeeks.toFixed(1)} weeks = ${(skipRate * 100).toFixed(1)}% skip rate`);

                return {
                    skipRate,
                    totalWeeks,
                    skippedWeeks: skippedCount
                };
            }

            // Phase 2: Extract calculation logic with validation
            calculateSupplyForecast(plannedWeeklyDose = 4.0) {
                // Validate input data
                const vials = this.data.vials || [];
                if (vials.length === 0) {
                    return {
                        success: false,
                        error: 'No vial data available',
                        totalSupplyMg: 0,
                        weeksRemaining: 0,
                        daysRemaining: 0,
                        activeVialCount: 0,
                        dryStockCount: 0
                    };
                }

                // Validate planned dose
                const dose = parseFloat(plannedWeeklyDose);
                if (isNaN(dose) || dose <= 0) {
                    return {
                        success: false,
                        error: 'Invalid planned dose (must be > 0)',
                        totalSupplyMg: 0
                    };
                }

                let totalSupplyMg = 0;
                let validActiveCount = 0;
                let invalidActiveCount = 0;
                let validDryStockCount = 0;
                let invalidDryStockCount = 0;

                // Process active vials
                const activeVials = vials.filter(v => {
                    const isActive = v.status === 'active' || v.status === 'activated';
                    const isNotEmpty = v.status !== 'empty' && v.status !== 'finished';
                    return isActive && isNotEmpty;
                });

                activeVials.forEach(vial => {
                    const concentration = vial.concentration_mg_ml || vial.concentrationMgMl || vial.concentration_mg_per_ml;
                    const volume = vial.current_volume_ml || vial.currentVolumeMl || vial.remaining_ml;

                    // Phase 2: Validate vial data
                    if (!concentration || concentration <= 0) {
                        console.warn('[SupplyForecast] Invalid concentration for vial:', vial.vial_id || vial.id);
                        invalidActiveCount++;
                        return;
                    }

                    if (!volume || volume <= 0) {
                        console.warn('[SupplyForecast] Invalid volume for vial:', vial.vial_id || vial.id);
                        invalidActiveCount++;
                        return;
                    }

                    const remainingMg = volume * concentration;
                    totalSupplyMg += remainingMg;
                    validActiveCount++;
                    console.log(`Vial ${vial.vial_id || vial.id} (active): ${remainingMg.toFixed(1)}mg remaining (${volume.toFixed(2)}ml @ ${concentration}mg/ml)`);
                });

                // Process dry stock vials
                const dryStockVials = vials.filter(v => v.status === 'dry_stock');

                dryStockVials.forEach(vial => {
                    // Handle property name variations (cloud sync compatibility)
                    const totalMg = vial.total_mg || vial.totalMg;

                    // Phase 2: Validate dry stock data
                    if (!totalMg || totalMg <= 0) {
                        console.warn('[SupplyForecast] Invalid total_mg for dry stock vial:', vial.vial_id || vial.id);
                        invalidDryStockCount++;
                        return;
                    }

                    totalSupplyMg += totalMg;
                    validDryStockCount++;
                    console.log(`Vial ${vial.vial_id || vial.id} (dry_stock): ${totalMg}mg available`);
                });

                console.log(`Total remaining supply: ${totalSupplyMg.toFixed(1)}mg (${validActiveCount} active + ${validDryStockCount} dry stock)`);

                // Calculate active weeks (doses needed)
                const activeWeeksRemaining = dose > 0 ? Math.floor(totalSupplyMg / dose) : 0;

                // Count skipped weeks for direct 1:1 extension
                const skipData = this.calculateSkipRate();
                const skippedWeeks = skipData.skippedWeeks;

                // Direct 1:1 formula: calendar weeks = active weeks + skipped weeks
                // If you skip 1 week, you get 1 extra week of calendar time
                const calendarWeeksRemaining = activeWeeksRemaining + skippedWeeks;
                const calendarDaysRemaining = Math.floor(calendarWeeksRemaining * 7);

                console.log(`[SupplyForecast] ${activeWeeksRemaining} active weeks + ${skippedWeeks} skipped weeks = ${calendarWeeksRemaining} calendar weeks (direct 1:1)`);

                // Return structured result
                return {
                    success: true,
                    totalSupplyMg,
                    weeksRemaining: calendarWeeksRemaining,
                    daysRemaining: calendarDaysRemaining,
                    activeWeeksRemaining,
                    skippedWeeks,
                    skipRate: skipData.skipRate,
                    activeVialCount: validActiveCount,
                    dryStockCount: validDryStockCount,
                    invalidActiveCount,
                    invalidDryStockCount,
                    warning: (invalidActiveCount + invalidDryStockCount) > 0
                        ? `${invalidActiveCount + invalidDryStockCount} vial(s) skipped due to invalid data`
                        : null
                };
            }

            updateSupplyForecast() {
                // Get planned dose from input
                const plannedDoseInput = document.getElementById('planned-dose');
                const plannedWeeklyDose = parseFloat(plannedDoseInput?.value || 4.0);

                // Phase 2: Use validated calculation
                const forecast = this.calculateSupplyForecast(plannedWeeklyDose);

                if (!forecast.success) {
                    console.error('[SupplyForecast] Calculation failed:', forecast.error);
                    document.getElementById('total-supply').textContent = '0 mg';
                    document.getElementById('supply-duration').textContent = 'No data';
                    document.getElementById('run-out-date').textContent = 'No supply';
                    document.getElementById('reorder-days').textContent = 'N/A';

                    // Phase 3: Add validation indicators for error state
                    const errorIndicator = `
                        <span class="validation-indicator validation-error validation-tooltip">
                            <span class="validation-icon"></span>
                            <span class="tooltip-content">${forecast.error}</span>
                        </span>
                    `;
                    document.getElementById('supply-duration-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('run-out-date-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('reorder-days-validation-indicator').innerHTML = errorIndicator;
                    return;
                }

                const { totalSupplyMg, weeksRemaining, daysRemaining } = forecast;

                // Calculate run out date
                const runOutDate = new Date();
                runOutDate.setDate(runOutDate.getDate() + daysRemaining);

                // Calculate reorder date (2 weeks before running out)
                const reorderDays = Math.max(0, daysRemaining - 14);

                // Update display
                document.getElementById('total-supply').textContent = `${totalSupplyMg.toFixed(1)} mg`;

                // Show breakdown: active weeks + skipped weeks = calendar weeks
                const activeWeeks = forecast.activeWeeksRemaining || 0;
                const skippedWeeks = forecast.skippedWeeks || 0;
                const breakdownText = skippedWeeks > 0
                    ? `${weeksRemaining} weeks (${activeWeeks} active + ${skippedWeeks} skipped)`
                    : `${weeksRemaining} weeks`;
                document.getElementById('supply-duration').textContent = breakdownText;

                document.getElementById('run-out-date').textContent = daysRemaining > 0 ? runOutDate.toLocaleDateString() : 'No supply';
                document.getElementById('reorder-days').textContent = reorderDays > 0 ? `${reorderDays} days` : 'Order now!';

                // Phase 3: Determine validation status
                const hasWarning = forecast.warning;
                const validationHTML = hasWarning
                    ? `<span class="validation-indicator validation-warning validation-tooltip">
                           <span class="validation-icon"></span>
                           <span class="tooltip-content">${forecast.warning}</span>
                       </span>`
                    : `<span class="validation-indicator validation-success">
                           <span class="validation-icon"></span>
                       </span>`;

                document.getElementById('supply-duration-validation-indicator').innerHTML = validationHTML;
                document.getElementById('run-out-date-validation-indicator').innerHTML = validationHTML;
                document.getElementById('reorder-days-validation-indicator').innerHTML = validationHTML;

                // Update colors based on supply levels
                const supplyDurationElement = document.getElementById('supply-duration');
                const runOutElement = document.getElementById('run-out-date');
                const reorderElement = document.getElementById('reorder-days');

                if (daysRemaining < 7) {
                    supplyDurationElement.style.color = '#FF3B30'; // Red
                    runOutElement.style.color = '#FF3B30';
                    reorderElement.style.color = '#FF3B30';
                } else if (daysRemaining < 21) {
                    supplyDurationElement.style.color = '#FF9500'; // Orange
                    runOutElement.style.color = '#FF9500';
                    reorderElement.style.color = '#FF9500';
                } else {
                    supplyDurationElement.style.color = '#34C759'; // Green
                    runOutElement.style.color = '#34C759';
                    reorderElement.style.color = '#34C759';
                }
            }

            updateMedicationChart() {
                // Keeping old function for compatibility - now calls updateSupplyForecast
                this.updateSupplyForecast();
                return;

                // Check if Chart.js is loaded
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not loaded, skipping chart update');
                    return;
                }

                // Destroy existing chart if it exists
                if (this.charts.medicationChart) {
                    this.charts.medicationChart.destroy();
                }

                if (this.data.injections.length === 0) {
                    // Show empty state
                    ctx.fillStyle = '#888888';
                    ctx.font = '16px -apple-system, BlinkMacSystemFont, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('No injection data yet', canvas.width / 2, canvas.height / 2);
                    return;
                }

                const chartData = this.generateMedicationLevelData();

                this.charts.medicationChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: chartData.labels,
                        datasets: [{
                            label: 'Medication Level',
                            data: chartData.levels,
                            borderColor: '#007AFF',
                            backgroundColor: 'rgba(0, 122, 255, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: '#007AFF',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2,
                            pointRadius: 4
                        }, {
                            label: 'Projected Level',
                            data: chartData.projectedLevels,
                            borderColor: '#007AFF',
                            backgroundColor: 'transparent',
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff',
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(42, 42, 42, 0.9)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#333333',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: 11
                                    }
                                }
                            },
                            y: {
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: 11
                                    },
                                    callback: function(value) {
                                        return value.toFixed(1) + ' mg';
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Medication Level (mg)',
                                    color: '#cccccc'
                                }
                            }
                        }
                    }
                });
            }

            generateMedicationLevelData() {
                const now = new Date();
                const startDate = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000)); // 30 days ago
                const endDate = new Date(now.getTime() + (14 * 24 * 60 * 60 * 1000)); // 14 days in future

                const labels = [];
                const levels = [];
                const projectedLevels = [];

                // Generate data points every 6 hours
                for (let date = new Date(startDate); date <= endDate; date = new Date(date.getTime() + 6 * 60 * 60 * 1000)) {
                    const levelResult = this.calculateCurrentMedicationLevel(date.toISOString());
                    const level = levelResult.value || 0; // Phase 2: Extract value from result
                    const isProjected = date > now;

                    labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));

                    if (isProjected) {
                        levels.push(null);
                        projectedLevels.push(level);
                    } else {
                        levels.push(level);
                        projectedLevels.push(null);
                    }
                }

                return { labels, levels, projectedLevels };
            }

            updateWeightChart(view = 'combined') {
                // Check if Chart.js is loaded
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not loaded, skipping weight chart update');
                    return;
                }

                // Update both charts
                this.updateShotsWithWeightChart();
                this.updateWeightOnlyChart();
            }

            updateShotsWithWeightChart() {
                const canvas = document.getElementById('shots-weight-chart');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // Destroy existing chart if it exists
                if (this.charts.shotsWeightChart) {
                    this.charts.shotsWeightChart.destroy();
                }

                // Filter data based on selected time range
                const now = new Date();
                let cutoffDate = null;
                if (this.timeRange !== 'all') {
                    cutoffDate = new Date(now.getTime() - this.timeRange * 24 * 60 * 60 * 1000);
                }

                const sortedWeights = [...this.data.weights]
                    .filter(w => this.timeRange === 'all' || new Date(w.timestamp) >= cutoffDate)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                const sortedInjections = [...this.data.injections]
                    .filter(i => this.timeRange === 'all' || new Date(i.timestamp) >= cutoffDate)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                // Filter to only show injections that have a matching weight (within 24 hours)
                const injectionsWithWeights = sortedInjections.filter(injection => {
                    const injDate = new Date(injection.timestamp);
                    return sortedWeights.some(weight => {
                        const weightDate = new Date(weight.timestamp);
                        const timeDiff = Math.abs(weightDate - injDate);
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        return hoursDiff <= 24;
                    });
                });

                // Filter weights to only show those that have a matching injection
                const weightsWithInjections = sortedWeights.filter(weight => {
                    const weightDate = new Date(weight.timestamp);
                    return injectionsWithWeights.some(injection => {
                        const injDate = new Date(injection.timestamp);
                        const timeDiff = Math.abs(weightDate - injDate);
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        return hoursDiff <= 24;
                    });
                });

                // Group injections by date and sum doses for the same day
                const injectionsByDate = new Map();
                injectionsWithWeights.forEach(injection => {
                    const injDate = new Date(injection.timestamp);
                    const dateKey = `${injDate.getFullYear()}-${String(injDate.getMonth() + 1).padStart(2, '0')}-${String(injDate.getDate()).padStart(2, '0')}`;

                    if (!injectionsByDate.has(dateKey)) {
                        injectionsByDate.set(dateKey, {
                            date: dateKey,
                            timestamp: injection.timestamp, // Use first injection's timestamp for positioning
                            totalDose: 0,
                            injections: [],
                            hasSkipped: false
                        });
                    }

                    const group = injectionsByDate.get(dateKey);
                    // Only count actual doses, not skipped ones
                    if (!injection.skipped) {
                        group.totalDose += injection.dose_mg;
                    } else {
                        group.hasSkipped = true;
                    }
                    group.injections.push(injection);
                });

                // Convert map to array for easier iteration
                const groupedInjections = Array.from(injectionsByDate.values());

                if (injectionsWithWeights.length === 0 || weightsWithInjections.length === 0) {
                    // Show empty state
                    const container = canvas.parentElement;
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"></div>
                            <h3>No shots with weight data yet</h3>
                            <p>Add weight entries on the same day as your shots to see them here</p>
                        </div>
                    `;
                    return;
                }

                // Ensure canvas exists for chart
                if (!canvas.parentElement.querySelector('canvas')) {
                    const container = canvas.parentElement;
                    container.innerHTML = '<canvas id="shots-weight-chart"></canvas>';
                }

                // Detect mobile screen for responsive chart configuration
                const isMobile = window.innerWidth <= 480;
                const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;

                // Dynamic font sizing based on screen size
                const fontSize = isMobile ? {
                    legend: 11,
                    tick: 10,
                    title: 11
                } : isTablet ? {
                    legend: 11,
                    tick: 10,
                    title: 12
                } : {
                    legend: 12,
                    tick: 11,
                    title: 12
                };

                // Build datasets - only show weights that have matching injections
                const colorPalette = ['#FF6B6B', '#FF9500', '#34C759', '#5AC8FA', '#007AFF', '#AF52DE'];
                const pointColors = weightsWithInjections.map((w, idx) => colorPalette[idx % colorPalette.length]);

                const datasets = [{
                    label: 'Weight (kg)',
                    data: weightsWithInjections.map(w => ({
                        x: w.timestamp,
                        y: w.weight_kg
                    })),
                    borderColor: '#AF52DE',
                    backgroundColor: 'transparent',
                    fill: false,
                    tension: 0.4,
                    yAxisID: 'y',
                    pointRadius: isMobile ? 6 : 5,
                    pointHoverRadius: isMobile ? 8 : 7,
                    pointHitRadius: isMobile ? 14 : 12,
                    pointBackgroundColor: pointColors,
                    pointBorderColor: pointColors,
                    pointBorderWidth: 2,
                    segment: {
                        borderColor: (ctx) => {
                            if (!ctx.p0DataIndex || ctx.p0DataIndex >= pointColors.length - 1) return colorPalette[0];
                            return pointColors[ctx.p0DataIndex];
                        }
                    }
                }];

                // Custom plugin to draw dose labels - only for injections with matching weights
                const doseLabelsPlugin = {
                    id: 'doseLabels',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const xScale = chart.scales.x;
                        const yScale = chart.scales.y;

                        if (!groupedInjections.length) return;

                        // Calculate data density for adaptive label sizing
                        const chartWidth = xScale.right - xScale.left;
                        const avgSpacing = groupedInjections.length > 1 ? chartWidth / groupedInjections.length : chartWidth;

                        // Since we only show shots with weights (weekly), keep labels large and readable
                        // Use consistent sizing with minimal density-based reduction
                        let fontSize, padding, pillHeight, yOffset;
                        const labelFormat = 'full'; // Always show "mg" suffix

                        if (avgSpacing < 40) {
                            // Dense mode (many data points)
                            fontSize = isMobile ? 11 : 14;
                            padding = isMobile ? 5 : 8;
                            pillHeight = isMobile ? 18 : 22;
                            yOffset = isMobile ? 24 : 30;
                        } else {
                            // Normal mode (comfortable spacing)
                            fontSize = isMobile ? 12 : 15;
                            padding = isMobile ? 6 : 9;
                            pillHeight = isMobile ? 20 : 24;
                            yOffset = isMobile ? 28 : 36;
                        }

                        ctx.save();
                        ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';

                        // Draw a label for each date with summed doses
                        groupedInjections.forEach((group, index) => {
                            const injDate = new Date(group.timestamp);
                            const x = xScale.getPixelForValue(injDate);

                            // Find the matching weight to position the label above it
                            const matchingWeight = weightsWithInjections.find(weight => {
                                const weightDate = new Date(weight.timestamp);
                                const timeDiff = Math.abs(weightDate - injDate);
                                const hoursDiff = timeDiff / (1000 * 60 * 60);
                                return hoursDiff <= 24;
                            });

                            // Position above the matching weight point
                            const y = yScale.getPixelForValue(matchingWeight.weight_kg);

                            // Show summed dose for all injections on this date
                            // Check if this group contains only skipped injections
                            const allSkipped = group.injections.every(inj => inj.skipped);
                            const label = allSkipped ? 'SKIPPED' : `${group.totalDose}mg`;

                            // No staggering needed since we only show shots with weights (naturally spaced)
                            const staggerOffset = 0;

                            // Draw background pill with colorful gradient
                            const textWidth = ctx.measureText(label).width;
                            const pillWidth = textWidth + padding * 2;
                            const pillX = x - pillWidth / 2;
                            const pillY = y - yOffset - staggerOffset;

                            // Use gray color for skipped doses, normal color palette otherwise
                            const color = allSkipped ? 'rgba(136, 136, 136, 0.5)' : colorPalette[index % colorPalette.length];
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.roundRect(pillX, pillY, pillWidth, pillHeight, pillHeight / 2);
                            ctx.fill();

                            // Draw text
                            ctx.fillStyle = allSkipped ? 'rgba(255, 255, 255, 0.6)' : '#FFFFFF';
                            ctx.fillText(label, x, pillY + pillHeight - 3);
                        });

                        ctx.restore();
                    }
                };

                // Pass plugin directly to chart instance instead of global registration
                this.charts.shotsWeightChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    plugins: [doseLabelsPlugin],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                top: 35,
                                left: 10,
                                right: 10,
                                bottom: 5
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff',
                                    font: {
                                        size: fontSize.legend
                                    },
                                    padding: isMobile ? 8 : 12,
                                    boxWidth: isMobile ? 30 : 40
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(42, 42, 42, 0.95)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#333333',
                                borderWidth: 1,
                                padding: isMobile ? 10 : 12,
                                titleFont: {
                                    size: isMobile ? 12 : 13
                                },
                                bodyFont: {
                                    size: isMobile ? 12 : 13
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'day',
                                    displayFormats: {
                                        day: isMobile ? 'M/d' : 'MMM d'
                                    }
                                },
                                // Add padding on both sides for visibility (2 days on each side)
                                min: weightsWithInjections.length > 0 ?
                                    new Date(new Date(weightsWithInjections[0].timestamp).getTime() - 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    undefined,
                                max: weightsWithInjections.length > 0 ?
                                    new Date(new Date(weightsWithInjections[weightsWithInjections.length - 1].timestamp).getTime() + 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    new Date().toISOString(),
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : isTablet ? 8 : 10,
                                    maxRotation: isMobile ? 45 : 0,
                                    minRotation: isMobile ? 45 : 0
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : 8,
                                    callback: function(value) {
                                        return value.toFixed(1);
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Weight (kg)',
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.title
                                    }
                                },
                                beginAtZero: false,
                                grace: '5%'
                            }
                        }
                    }
                });
            }

            updateWeightOnlyChart() {
                const canvas = document.getElementById('weight-only-chart');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // Destroy existing chart if it exists
                if (this.charts.weightOnlyChart) {
                    this.charts.weightOnlyChart.destroy();
                }

                // Filter data based on selected time range
                const now = new Date();
                let cutoffDate = null;
                if (this.timeRange !== 'all') {
                    cutoffDate = new Date(now.getTime() - this.timeRange * 24 * 60 * 60 * 1000);
                }

                const sortedWeights = [...this.data.weights]
                    .filter(w => this.timeRange === 'all' || new Date(w.timestamp) >= cutoffDate)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                if (sortedWeights.length === 0) {
                    // Show empty state
                    const container = canvas.parentElement;
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"></div>
                            <h3>No weight data yet</h3>
                            <p>Start tracking your progress by adding your first weight entry</p>
                            <button class="btn-primary" onclick="app.openModal('add-weight-modal')">Add Weight</button>
                        </div>
                    `;
                    return;
                }

                // Ensure canvas exists for chart
                if (!canvas.parentElement.querySelector('canvas')) {
                    const container = canvas.parentElement;
                    container.innerHTML = '<canvas id="weight-only-chart"></canvas>';
                }

                // Detect mobile screen for responsive chart configuration
                const isMobile = window.innerWidth <= 480;
                const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;

                // Dynamic font sizing based on screen size
                const fontSize = isMobile ? {
                    legend: 11,
                    tick: 10,
                    title: 11
                } : isTablet ? {
                    legend: 11,
                    tick: 10,
                    title: 12
                } : {
                    legend: 12,
                    tick: 11,
                    title: 12
                };

                // Build datasets - show all weights
                const colorPalette = ['#FF6B6B', '#FF9500', '#34C759', '#5AC8FA', '#007AFF', '#AF52DE'];
                const pointColors = sortedWeights.map((w, idx) => colorPalette[idx % colorPalette.length]);

                const datasets = [{
                    label: 'Weight (kg)',
                    data: sortedWeights.map(w => ({
                        x: w.timestamp,
                        y: w.weight_kg
                    })),
                    borderColor: '#AF52DE',
                    backgroundColor: 'transparent',
                    fill: false,
                    tension: 0.4,
                    yAxisID: 'y',
                    pointRadius: isMobile ? 6 : 5,
                    pointHoverRadius: isMobile ? 8 : 7,
                    pointHitRadius: isMobile ? 14 : 12,
                    pointBackgroundColor: pointColors,
                    pointBorderColor: pointColors,
                    pointBorderWidth: 2,
                    segment: {
                        borderColor: (ctx) => {
                            if (!ctx.p0DataIndex || ctx.p0DataIndex >= pointColors.length - 1) return colorPalette[0];
                            return pointColors[ctx.p0DataIndex];
                        }
                    }
                }];

                // Create chart without dose labels plugin
                this.charts.weightOnlyChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                top: 15,
                                left: 10,
                                right: 10,
                                bottom: 5
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff',
                                    font: {
                                        size: fontSize.legend
                                    },
                                    padding: isMobile ? 8 : 12,
                                    boxWidth: isMobile ? 30 : 40
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(42, 42, 42, 0.95)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#333333',
                                borderWidth: 1,
                                padding: isMobile ? 10 : 12,
                                titleFont: {
                                    size: isMobile ? 12 : 13
                                },
                                bodyFont: {
                                    size: isMobile ? 12 : 13
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'day',
                                    displayFormats: {
                                        day: isMobile ? 'M/d' : 'MMM d'
                                    }
                                },
                                // Add padding on both sides for visibility (2 days on each side)
                                min: sortedWeights.length > 0 ?
                                    new Date(new Date(sortedWeights[0].timestamp).getTime() - 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    undefined,
                                max: sortedWeights.length > 0 ?
                                    new Date(new Date(sortedWeights[sortedWeights.length - 1].timestamp).getTime() + 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    new Date().toISOString(),
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : isTablet ? 8 : 10,
                                    maxRotation: isMobile ? 45 : 0,
                                    minRotation: isMobile ? 45 : 0
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : 8,
                                    callback: function(value) {
                                        return value.toFixed(1);
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Weight (kg)',
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.title
                                    }
                                },
                                beginAtZero: false,
                                grace: '5%'
                            }
                        }
                    }
                });
            }

            // Helper function: Convert kg to lb
            kgToLbs(kg) {
                return kg * 2.20462;
            }

            // Helper function: Convert lb to kg
            lbsToKg(lbs) {
                return lbs / 2.20462;
            }

            // Helper function: Get date range for display
            getDateRangeText(weights) {
                if (!weights || weights.length === 0) return '';

                const sorted = [...weights].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const start = new Date(sorted[0].timestamp);
                const end = new Date(sorted[sorted.length - 1].timestamp);

                const formatOptions = { month: 'short', day: 'numeric', year: 'numeric' };
                return `${start.toLocaleDateString('en-US', formatOptions)} - ${end.toLocaleDateString('en-US', formatOptions)}`;
            }

            // Phase 2: Extract weight statistics calculation with validation
            calculateWeightStats(timeRangeDays = null) {
                // Validate input data
                const weights = this.data.weights || [];
                if (weights.length === 0) {
                    return {
                        success: false,
                        error: 'No weight data available',
                        metrics: this.getDefaultWeightMetrics()
                    };
                }

                // Filter by time range if specified
                let filteredWeights = weights;
                if (timeRangeDays && timeRangeDays !== 'all') {
                    const cutoffDate = new Date(Date.now() - timeRangeDays * 24 * 60 * 60 * 1000);
                    filteredWeights = weights.filter(w => new Date(w.timestamp) >= cutoffDate);
                }

                // Phase 2: Validate minimum data requirement
                if (filteredWeights.length < 2) {
                    return {
                        success: false,
                        error: 'Need at least 2 weight entries to calculate statistics',
                        metrics: this.getDefaultWeightMetrics(),
                        dataCount: filteredWeights.length
                    };
                }

                // Sort and validate weight entries
                let validCount = 0;
                let invalidCount = 0;
                const validWeights = [];

                filteredWeights.forEach(w => {
                    // Phase 2: Validate each weight entry
                    if (!w.timestamp || !w.weight_kg) {
                        console.warn('[WeightStats] Invalid weight entry:', w.id, 'missing timestamp or weight_kg');
                        invalidCount++;
                        return;
                    }

                    const timestamp = new Date(w.timestamp).getTime();
                    if (isNaN(timestamp)) {
                        console.warn('[WeightStats] Invalid timestamp for weight:', w.id);
                        invalidCount++;
                        return;
                    }

                    const weightKg = parseFloat(w.weight_kg);
                    if (isNaN(weightKg) || weightKg < 20 || weightKg > 300) {
                        console.warn('[WeightStats] Invalid weight value:', w.id, weightKg);
                        invalidCount++;
                        return;
                    }

                    validWeights.push({ ...w, weight_kg: weightKg, timestamp: new Date(w.timestamp) });
                    validCount++;
                });

                // Check if we still have enough valid data
                if (validWeights.length < 2) {
                    return {
                        success: false,
                        error: `Only ${validWeights.length} valid weight entries (need at least 2)`,
                        metrics: this.getDefaultWeightMetrics(),
                        validCount,
                        invalidCount
                    };
                }

                // Sort by timestamp
                const sortedWeights = validWeights.sort((a, b) => a.timestamp - b.timestamp);
                const firstWeight = sortedWeights[0];
                const lastWeight = sortedWeights[sortedWeights.length - 1];

                // Calculate metrics
                const weightChangeKg = lastWeight.weight_kg - firstWeight.weight_kg;
                const currentWeightKg = lastWeight.weight_kg;
                const startWeightKg = firstWeight.weight_kg;

                // Calculate percent change
                const percentChange = (weightChangeKg / startWeightKg) * 100;

                // Calculate weekly average accounting for skip weeks
                const daysDiff = (lastWeight.timestamp - firstWeight.timestamp) / (1000 * 60 * 60 * 24);
                const calendarWeeks = daysDiff / 7;

                // Get skip data to calculate active weeks
                const skipData = this.calculateSkipRate();

                // Calculate active weeks (weeks where medication was actually taken)
                let activeWeeks = calendarWeeks;
                if (skipData.skipRate > 0 && skipData.skipRate < 1) {
                    // If 20% skip rate, then 80% of calendar weeks are active
                    activeWeeks = calendarWeeks * (1 - skipData.skipRate);
                }

                const weeklyAvgKg = activeWeeks > 0 ? (weightChangeKg / activeWeeks) : 0;

                console.log(`[WeightStats] ${calendarWeeks.toFixed(1)} calendar weeks  ${activeWeeks.toFixed(1)} active weeks (skip rate: ${(skipData.skipRate * 100).toFixed(1)}%)`);

                // Calculate goal progress
                let goalProgress = null;
                if (this.data.settings.goalWeightKg) {
                    const goalWeightKg = this.data.settings.goalWeightKg;
                    const totalToLose = startWeightKg - goalWeightKg;
                    const lostSoFar = startWeightKg - currentWeightKg;
                    goalProgress = totalToLose > 0 ? (lostSoFar / totalToLose) * 100 : 0;
                }

                return {
                    success: true,
                    metrics: {
                        weightChangeKg,
                        currentWeightKg,
                        startWeightKg,
                        percentChange,
                        weeklyAvgKg,
                        goalProgress,
                        daysDiff,
                        weeks: calendarWeeks,
                        activeWeeks
                    },
                    validCount,
                    invalidCount,
                    totalCount: filteredWeights.length,
                    warning: invalidCount > 0 ? `${invalidCount} weight entries skipped due to invalid data` : null
                };
            }

            // Phase 2: Helper method for default metrics
            getDefaultWeightMetrics() {
                return {
                    weightChangeKg: 0,
                    currentWeightKg: 0,
                    startWeightKg: 0,
                    percentChange: 0,
                    weeklyAvgKg: 0,
                    goalProgress: null,
                    daysDiff: 0,
                    weeks: 0,
                    activeWeeks: 0
                };
            }

            updateWeightStats() {
                // Get weights for current time range
                const timeRangeDays = this.timeRange === 'all' ? 'all' : this.timeRange;

                // Update date range display
                const cutoffDate = timeRangeDays === 'all' ? new Date(0) :
                    new Date(Date.now() - timeRangeDays * 24 * 60 * 60 * 1000);
                const filteredWeights = this.data.weights.filter(w =>
                    timeRangeDays === 'all' || new Date(w.timestamp) >= cutoffDate
                );

                const dateRangeEl = document.getElementById('date-range-display');
                if (dateRangeEl) {
                    dateRangeEl.textContent = this.getDateRangeText(filteredWeights);
                }

                // Phase 2: Use validated calculation
                const statsResult = this.calculateWeightStats(timeRangeDays);

                if (!statsResult.success) {
                    console.warn('[WeightStats] Calculation failed:', statsResult.error);
                    // Set defaults if not enough data
                    document.getElementById('total-change').textContent = '0 kg';
                    document.getElementById('current-weight').textContent = '0 kg';
                    document.getElementById('current-bmi').textContent = '--';
                    document.getElementById('percent-change').textContent = '0%';
                    document.getElementById('weekly-avg').textContent = '0 kg/wk';
                    document.getElementById('goal-progress').textContent = '--';

                    // Phase 3: Add validation indicators for error state
                    const errorIndicator = `
                        <span class="validation-indicator validation-error validation-tooltip">
                            <span class="validation-icon"></span>
                            <span class="tooltip-content">${statsResult.error}</span>
                        </span>
                    `;
                    document.getElementById('total-change-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('current-weight-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('percent-change-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('weekly-avg-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('goal-progress-validation-indicator').innerHTML = errorIndicator;
                    return;
                }

                const { weightChangeKg, currentWeightKg, percentChange, weeklyAvgKg, goalProgress } = statsResult.metrics;

                // Phase 3: Determine validation status
                const hasWarning = statsResult.warning;
                const validationHTML = hasWarning
                    ? `<span class="validation-indicator validation-warning validation-tooltip">
                           <span class="validation-icon"></span>
                           <span class="tooltip-content">${statsResult.warning}</span>
                       </span>`
                    : `<span class="validation-indicator validation-success">
                           <span class="validation-icon"></span>
                       </span>`;

                // 1. Total change (in kg)
                const totalChangeText = weightChangeKg >= 0 ?
                    `+${Math.abs(weightChangeKg).toFixed(1)} kg` :
                    `${weightChangeKg.toFixed(1)} kg`;
                document.getElementById('total-change').textContent = totalChangeText;
                document.getElementById('total-change-validation-indicator').innerHTML = validationHTML;

                // 2. Current weight (in kg)
                document.getElementById('current-weight').textContent = `${currentWeightKg.toFixed(1)} kg`;
                document.getElementById('current-weight-validation-indicator').innerHTML = validationHTML;

                // 3. Current BMI
                this.updateBMI();

                // 4. Percent change
                const percentText = percentChange >= 0 ?
                    `+${percentChange.toFixed(0)}%` :
                    `${percentChange.toFixed(0)}%`;
                document.getElementById('percent-change').textContent = percentText;
                document.getElementById('percent-change-validation-indicator').innerHTML = validationHTML;

                // 5. Weekly average (kg/wk)
                const weeklyText = weeklyAvgKg >= 0 ?
                    `+${weeklyAvgKg.toFixed(1)} kg/wk` :
                    `${weeklyAvgKg.toFixed(1)} kg/wk`;
                document.getElementById('weekly-avg').textContent = weeklyText;
                document.getElementById('weekly-avg-validation-indicator').innerHTML = validationHTML;

                // 6. Goal progress (%)
                if (goalProgress !== null) {
                    document.getElementById('goal-progress').textContent =
                        `${Math.max(0, Math.min(100, goalProgress)).toFixed(0)}%`;
                    document.getElementById('goal-progress-validation-indicator').innerHTML = validationHTML;
                } else {
                    document.getElementById('goal-progress').textContent = '--';
                    document.getElementById('goal-progress-validation-indicator').innerHTML = '';
                }

                // Color coding for total change
                const totalChangeEl = document.getElementById('total-change');
                if (weightChangeKg < 0) {
                    totalChangeEl.style.color = '#34C759'; // Green for weight loss
                } else if (weightChangeKg > 0) {
                    totalChangeEl.style.color = '#FF9500'; // Orange for weight gain
                } else {
                    totalChangeEl.style.color = 'var(--text-primary)';
                }

                // Color coding for percent change
                const percentEl = document.getElementById('percent-change');
                if (percentChange < 0) {
                    percentEl.style.color = '#34C759';
                } else if (percentChange > 0) {
                    percentEl.style.color = '#FF9500';
                } else {
                    percentEl.style.color = 'var(--text-primary)';
                }

                // Color coding for weekly average
                const weeklyEl = document.getElementById('weekly-avg');
                if (weeklyAvgKg < 0) {
                    weeklyEl.style.color = '#34C759';
                } else if (weeklyAvgKg > 0) {
                    weeklyEl.style.color = '#FF9500';
                } else {
                    weeklyEl.style.color = 'var(--text-primary)';
                }
            }

            // Phase 2: Extract BMI calculation with validation
            calculateBMI() {
                // Validate input data
                const weights = this.data.weights || [];
                if (weights.length === 0) {
                    return {
                        success: false,
                        error: 'No weight data available',
                        value: 0
                    };
                }

                const heightCm = this.data.settings?.heightCm;
                if (!heightCm) {
                    return {
                        success: false,
                        error: 'Height not set in settings',
                        value: 0
                    };
                }

                // Phase 2: Validate height is reasonable (100-250cm)
                const height = parseFloat(heightCm);
                if (isNaN(height) || height < 100 || height > 250) {
                    return {
                        success: false,
                        error: `Invalid height: ${heightCm}cm (must be 100-250cm)`,
                        value: 0
                    };
                }

                // Get last weight
                const sortedWeights = [...weights].sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                );
                const lastWeight = sortedWeights[sortedWeights.length - 1];

                // Phase 2: Validate weight is reasonable (20-300kg)
                const weightKg = parseFloat(lastWeight.weight_kg);
                if (isNaN(weightKg) || weightKg < 20 || weightKg > 300) {
                    return {
                        success: false,
                        error: `Invalid weight: ${lastWeight.weight_kg}kg (must be 20-300kg)`,
                        value: 0
                    };
                }

                // Calculate BMI
                const heightM = height / 100;
                const bmi = weightKg / (heightM * heightM);

                // Phase 2: Validate BMI is reasonable (10-60)
                if (bmi < 10 || bmi > 60) {
                    return {
                        success: false,
                        error: `Calculated BMI ${bmi.toFixed(1)} is out of reasonable range (10-60)`,
                        value: bmi,
                        warning: 'BMI calculation may be incorrect - check height and weight settings'
                    };
                }

                return {
                    success: true,
                    value: bmi,
                    weightKg,
                    heightCm: height,
                    category: bmi < 18.5 ? 'underweight' :
                             bmi < 25 ? 'normal' :
                             bmi < 30 ? 'overweight' : 'obese'
                };
            }

            updateBMI() {
                const bmiElement = document.getElementById('current-bmi');
                const validationIndicator = document.getElementById('bmi-validation-indicator');

                // Phase 2: Use validated calculation
                const bmiResult = this.calculateBMI();

                if (!bmiResult.success) {
                    console.warn('[BMI] Calculation failed:', bmiResult.error);
                    bmiElement.textContent = '--';
                    bmiElement.style.color = 'var(--text-primary)';

                    // Phase 3: Add validation indicator
                    validationIndicator.innerHTML = `
                        <span class="validation-indicator validation-error validation-tooltip">
                            <span class="validation-icon"></span>
                            <span class="tooltip-content">${bmiResult.error}</span>
                        </span>
                    `;
                    return;
                }

                const bmi = bmiResult.value;
                bmiElement.textContent = bmi.toFixed(1);

                // Color code BMI
                if (bmi < 18.5) {
                    bmiElement.style.color = '#007AFF'; // Blue - underweight
                } else if (bmi < 25) {
                    bmiElement.style.color = '#34C759'; // Green - normal
                } else if (bmi < 30) {
                    bmiElement.style.color = '#FF9500'; // Orange - overweight
                } else {
                    bmiElement.style.color = '#FF3B30'; // Red - obese
                }

                // Phase 3: Add validation indicator for warnings
                if (bmiResult.warning) {
                    validationIndicator.innerHTML = `
                        <span class="validation-indicator validation-warning validation-tooltip">
                            <span class="validation-icon"></span>
                            <span class="tooltip-content">${bmiResult.warning}</span>
                        </span>
                    `;
                } else {
                    validationIndicator.innerHTML = `
                        <span class="validation-indicator validation-success">
                            <span class="validation-icon"></span>
                        </span>
                    `;
                }
            }

            updateGoalProgress() {
                const goalCard = document.getElementById('goal-progress-card');

                // Hide card if no goal weight or insufficient weight data
                if (!this.data.settings.goalWeightKg || this.data.weights.length < 2) {
                    goalCard.style.display = 'none';
                    return;
                }

                const sortedWeights = [...this.data.weights].sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                );

                const startWeight = sortedWeights[0].weight_kg;
                const currentWeight = sortedWeights[sortedWeights.length - 1].weight_kg;
                const goalWeight = this.data.settings.goalWeightKg;

                // Check if goal is already reached
                if (currentWeight <= goalWeight) {
                    goalCard.style.display = 'block';
                    document.getElementById('goal-start-weight').textContent = startWeight.toFixed(1);
                    document.getElementById('goal-target-weight').textContent = goalWeight.toFixed(1);
                    document.getElementById('goal-progress-percent').textContent = '100';
                    document.getElementById('goal-progress-bar').style.width = '100%';
                    document.getElementById('goal-remaining').textContent = '0 kg';
                    document.getElementById('goal-weekly-rate').textContent = '--';
                    document.getElementById('goal-eta-date').textContent = 'Achieved!';
                    document.getElementById('goal-message').textContent = ' Congratulations! You\'ve reached your goal!';
                    document.getElementById('goal-message').style.background = 'rgba(52, 199, 89, 0.2)';
                    return;
                }

                // Calculate progress
                const totalToLose = startWeight - goalWeight;
                const alreadyLost = startWeight - currentWeight;
                const remaining = currentWeight - goalWeight;
                const progressPercent = Math.max(0, Math.min(100, (alreadyLost / totalToLose) * 100));

                // Calculate weekly rate (last 4 weeks)
                const fourWeeksAgo = new Date();
                fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);
                const recentWeights = sortedWeights.filter(w =>
                    new Date(w.timestamp) >= fourWeeksAgo
                );

                let weeklyRate = 0;
                let etaText = '--';

                if (recentWeights.length >= 2) {
                    const oldestRecent = recentWeights[0];
                    const newestRecent = recentWeights[recentWeights.length - 1];
                    const daysDiff = (new Date(newestRecent.timestamp) - new Date(oldestRecent.timestamp)) / (1000 * 60 * 60 * 24);
                    const weightDiff = oldestRecent.weight_kg - newestRecent.weight_kg;

                    if (daysDiff > 0) {
                        weeklyRate = (weightDiff / daysDiff) * 7;

                        // Calculate ETA
                        if (weeklyRate > 0) {
                            const weeksToGoal = remaining / weeklyRate;
                            const etaDate = new Date();
                            etaDate.setDate(etaDate.getDate() + (weeksToGoal * 7));

                            // Format date based on how far away it is
                            if (weeksToGoal < 8) {
                                etaText = `${Math.ceil(weeksToGoal)} weeks`;
                            } else {
                                etaText = etaDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                            }
                        } else {
                            etaText = '--';
                        }
                    }
                }

                // Update UI
                goalCard.style.display = 'block';
                document.getElementById('goal-start-weight').textContent = startWeight.toFixed(1);
                document.getElementById('goal-target-weight').textContent = goalWeight.toFixed(1);
                document.getElementById('goal-progress-percent').textContent = progressPercent.toFixed(0);
                document.getElementById('goal-progress-bar').style.width = progressPercent + '%';
                document.getElementById('goal-remaining').textContent = remaining.toFixed(1) + ' kg';
                document.getElementById('goal-weekly-rate').textContent = weeklyRate > 0 ?
                    '-' + weeklyRate.toFixed(2) + ' kg' : '--';
                document.getElementById('goal-eta-date').textContent = etaText;

                // Update message based on progress
                const messageEl = document.getElementById('goal-message');
                if (progressPercent >= 75) {
                    messageEl.textContent = ' Almost there! You\'re in the home stretch!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.15)';
                } else if (progressPercent >= 50) {
                    messageEl.textContent = ' Great progress! You\'re halfway to your goal!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.1)';
                } else if (progressPercent >= 25) {
                    messageEl.textContent = ' Keep going! You\'re making steady progress!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.1)';
                } else if (weeklyRate > 0) {
                    messageEl.textContent = ' You\'re on track! Stay consistent!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.1)';
                } else {
                    messageEl.textContent = ' Keep tracking to see your progress!';
                    messageEl.style.background = 'rgba(128, 128, 128, 0.1)';
                    messageEl.style.color = 'var(--text-secondary)';
                }
            }

            showSettingSaveIndicator(inputElement) {
                if (!inputElement) return;
                const wrapper = inputElement.closest('.setting-input-wrapper');
                if (!wrapper) return;

                const indicator = wrapper.querySelector('.save-indicator');
                if (!indicator) return;

                // Show checkmark
                indicator.classList.add('show');
                indicator.style.color = '#34C759';

                // Hide after 2 seconds
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            }

            showSettingsSavedNotification() {
                // Debounce: Clear existing timeout
                if (this.settingsSaveTimeout) {
                    clearTimeout(this.settingsSaveTimeout);
                }

                // Set new timeout to show notification after 1 second
                this.settingsSaveTimeout = setTimeout(() => {
                    if (window.deleteManager && window.deleteManager.notificationManager) {
                        window.deleteManager.notificationManager.show('Settings saved successfully', 'success');
                    }
                }, 1000);
            }

            updateWeightsList() {
                const weightsList = document.getElementById('weights-list');
                weightsList.innerHTML = '';

                if (this.data.weights.length === 0) {
                    weightsList.innerHTML = '<p style="text-align: center; color: var(--text-muted); padding: 24px;">No weight entries yet</p>';
                    return;
                }

                // Filter out invalid weights first
                const validWeights = this.data.weights.filter(w => w && w.weight_kg && w.timestamp);

                const sortedWeights = [...validWeights].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                sortedWeights.forEach(weight => {
                    const weightItem = this.createWeightListItem(weight);
                    if (weightItem && weightItem.hasChildNodes()) {
                        weightsList.appendChild(weightItem);
                    }
                });
            }

            createWeightListItem(weight) {
                // Safety check for invalid weight data
                if (!weight || !weight.weight_kg) {
                    console.warn('Invalid weight data:', weight);
                    return document.createElement('div');
                }

                const div = document.createElement('div');
                div.className = 'weight-item';
                div.setAttribute('data-item-id', weight.id || weight.timestamp);
                div.setAttribute('data-timestamp', weight.timestamp);
                div.innerHTML = `
                    <div class="weight-content">
                        <div class="shot-header">
                            <div class="shot-dose">${weight.weight_kg.toFixed(1)} kg</div>
                            <div class="shot-date">${this.formatDate(weight.timestamp)}</div>
                        </div>
                        ${weight.body_fat_percentage ? `
                        <div class="shot-details">
                            <div>Body Fat: ${weight.body_fat_percentage}%</div>
                        </div>
                        ` : ''}
                    </div>
                    <div class="item-actions">
                        <button class="edit-btn" data-entity-type="weight" data-entity-id="${weight.id || weight.timestamp}" aria-label="Edit weight entry" title="Edit this weight entry">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                        <button class="delete-btn" aria-label="Delete weight entry" title="Delete this weight entry">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                                <path d="M10 11v6M14 11v6"/>
                            </svg>
                        </button>
                    </div>
                `;
                return div;
            }

            updateInventoryStats() {
                const activeVials = this.data.vials.filter(v =>
                    v.status === 'active' &&
                    v.remaining_ml > 0 &&
                    new Date(v.expiration_date) > new Date()
                );

                const dryStockVials = this.data.vials.filter(v =>
                    v.status === 'dry_stock' &&
                    new Date(v.expiration_date) > new Date()
                );

                const expiredVials = this.data.vials.filter(v =>
                    new Date(v.expiration_date) < new Date()
                );

                const defaultDose = this.data.settings.defaultDose || 2.0;
                let totalDoses = 0;
                let totalMgUsed = 0;

                // Count doses from active vials
                activeVials.forEach(vial => {
                    // Handle property name variations (cloud sync compatibility)
                    const concentration = vial.concentration_mg_ml || vial.concentrationMgMl || 0;
                    const remainingMl = vial.remaining_ml || vial.current_volume_ml || vial.currentVolumeMl || 0;

                    if (concentration <= 0 || remainingMl <= 0) {
                        console.warn('[VialsPage] Skipping active vial with invalid data:', vial.vial_id);
                        return;
                    }

                    const dosesInVial = (remainingMl * concentration) / defaultDose;
                    totalDoses += dosesInVial;
                });

                // Count doses from dry stock vials (full vials)
                dryStockVials.forEach(vial => {
                    const totalMg = vial.total_mg || vial.totalMg || 0;

                    if (totalMg <= 0) {
                        console.warn('[VialsPage] Skipping dry stock vial with invalid data:', vial.vial_id);
                        return;
                    }

                    const dosesInVial = totalMg / defaultDose;
                    totalDoses += dosesInVial;
                });

                this.data.vials.forEach(vial => {
                    totalMgUsed += vial.doses_used * defaultDose;
                });

                // Calculate days remaining based on dose day
                const daysRemaining = this.calculateDaysRemaining(totalDoses);


                // Update basic stats
                document.getElementById('total-stock').textContent = totalDoses.toFixed(1);
                document.getElementById('days-remaining').textContent = daysRemaining;
                // Cost fields removed - no longer tracking costs

                // Update colors based on stock levels
                const stockElement = document.getElementById('total-stock');
                const daysElement = document.getElementById('days-remaining');

                if (totalDoses < 5 || daysRemaining < 14) {
                    stockElement.style.color = '#FF3B30'; // Red for low stock
                    daysElement.style.color = '#FF3B30';
                } else if (totalDoses < 10 || daysRemaining < 30) {
                    stockElement.style.color = '#FF9500'; // Orange for medium stock
                    daysElement.style.color = '#FF9500';
                } else {
                    stockElement.style.color = '#34C759'; // Green for good stock
                    daysElement.style.color = '#34C759';
                }

                // Update analytics
                this.updateInventoryAnalytics(totalDoses, daysRemaining, expiredVials);
            }

            updateInventoryAnalytics(totalDoses, daysRemaining, expiredVials) {
                // Reorder Alert
                let reorderAlert = "Stock levels look good";
                let reorderColor = '#34C759';

                if (totalDoses < 5 || daysRemaining < 14) {
                    reorderAlert = " Critical - Order immediately!";
                    reorderColor = '#FF3B30';
                } else if (totalDoses < 8 || daysRemaining < 21) {
                    reorderAlert = " Low stock - Order soon";
                    reorderColor = '#FF9500';
                } else if (totalDoses < 12 || daysRemaining < 30) {
                    reorderAlert = " Consider ordering";
                    reorderColor = '#FF9500';
                }

                const reorderElement = document.getElementById('reorder-alert');
                if (reorderElement) {
                    reorderElement.textContent = reorderAlert;
                    reorderElement.style.color = reorderColor;
                }

                // Usage Rate - calculated from default dose and injection frequency
                const defaultDose = this.data.settings.defaultDose || 2.0;
                const injectionFrequency = this.data.settings.injectionFrequency || 7;
                const dosesPerWeek = 7 / injectionFrequency;
                const mgPerWeek = defaultDose * dosesPerWeek;
                const usageRate = `${mgPerWeek.toFixed(1)} mg/week`;
                const usageRateElement = document.getElementById('usage-rate');
                if (usageRateElement) {
                    usageRateElement.textContent = usageRate;
                }

                // Waste Tracking
                let wasteText = "No expired vials";
                let wasteColor = '#34C759';

                if (expiredVials.length > 0) {
                    const expiredMg = expiredVials.reduce((sum, vial) => {
                        return sum + (vial.remaining_ml * vial.concentration_mg_ml);
                    }, 0);
                    wasteText = `${expiredVials.length} expired (${expiredMg.toFixed(0)}mg lost)`;
                    wasteColor = '#FF3B30';
                }

                const wasteElement = document.getElementById('waste-tracking');
                if (wasteElement) {
                    wasteElement.textContent = wasteText;
                    wasteElement.style.color = wasteColor;
                }

                // Next Order Suggestion
                let nextOrderText = "Order in 30+ days";
                let nextOrderColor = '#34C759';

                if (daysRemaining <= 14) {
                    nextOrderText = "Order now!";
                    nextOrderColor = '#FF3B30';
                } else if (daysRemaining <= 30) {
                    nextOrderText = `Order in ${Math.max(0, daysRemaining - 14)} days`;
                    nextOrderColor = '#FF9500';
                } else {
                    const orderInDays = Math.max(daysRemaining - 21, 1);
                    nextOrderText = `Order in ${orderInDays} days`;
                }

                const nextOrderElement = document.getElementById('next-order');
                if (nextOrderElement) {
                    nextOrderElement.textContent = nextOrderText;
                    nextOrderElement.style.color = nextOrderColor;
                }
            }

            // ====================================
            // COUNTDOWN FUNCTIONALITY
            // ====================================

            startCountdownTimer() {
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                }

                this.countdownInterval = setInterval(() => {
                    this.updateCountdown();
                }, 1000);
            }

            updateCountdown() {
                if (this.data.injections.length === 0) {
                    document.getElementById('next-shot-day').textContent = 'No shots recorded';
                    document.getElementById('next-shot-date').textContent = '';
                    document.getElementById('next-shot-time').textContent = '';
                    this.updateCountdownProgress(0);
                    return;
                }

                const now = new Date();
                const lastInjection = this.getMostRecentInjection();
                const lastShot = new Date(lastInjection.timestamp);

                // Calculate next shot based on injection frequency
                const frequency = this.data.settings.injectionFrequency ||
                                this.data.settings.injectionFrequencyDays || 7;
                const nextShot = new Date(lastShot);
                nextShot.setDate(nextShot.getDate() + frequency);

                // Format the date display
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

                const dayName = dayNames[nextShot.getDay()];
                const monthName = monthNames[nextShot.getMonth()];
                const date = nextShot.getDate();

                // Format time
                let hours = nextShot.getHours();
                const minutes = nextShot.getMinutes();
                const ampm = hours >= 12 ? 'PM' : 'AM';
                hours = hours % 12;
                hours = hours ? hours : 12; // 0 should be 12
                const timeString = `${hours}:${minutes.toString().padStart(2, '0')} ${ampm}`;

                document.getElementById('next-shot-day').textContent = dayName;
                document.getElementById('next-shot-date').textContent = `${monthName} ${date}`;
                document.getElementById('next-shot-time').textContent = timeString;

                // Calculate progress and update colors
                const timeDiff = nextShot.getTime() - now.getTime();
                const totalTime = frequency * 24 * 60 * 60 * 1000;
                const elapsedTime = now.getTime() - lastShot.getTime();
                const progress = Math.min(100, (elapsedTime / totalTime) * 100);

                this.updateCountdownProgress(progress);

                // Update colors based on timing
                const dayElement = document.getElementById('next-shot-day');
                const dateElement = document.getElementById('next-shot-date');

                if (timeDiff <= 0) {
                    // Shot is overdue
                    dayElement.style.color = '#FF3B30';
                    dateElement.style.color = '#FF3B30';
                    dayElement.textContent = 'OVERDUE';
                    dateElement.textContent = '';
                } else if (timeDiff <= 24 * 60 * 60 * 1000) {
                    // Due within 24 hours
                    dayElement.style.color = '#FF9500';
                    dateElement.style.color = '#FF9500';
                } else {
                    // Normal timing
                    dayElement.style.color = 'var(--accent-color)';
                    dateElement.style.color = 'var(--text-primary)';
                }
            }

            updateCountdownProgress(percentage) {
                const circle = document.getElementById('countdown-circle');
                const circumference = 2 * Math.PI * 90; // radius = 90
                const offset = circumference - (percentage / 100) * circumference;
                circle.style.strokeDashoffset = offset;
            }

            // ====================================
            // GOOGLE DRIVE INTEGRATION
            // ====================================

            async initGoogleDrive() {
                // Google API client ID (you'll need to replace this with your own)
                this.CLIENT_ID = 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com';
                this.API_KEY = 'YOUR_GOOGLE_API_KEY';
                this.DISCOVERY_DOCS = ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'];
                this.SCOPES = 'https://www.googleapis.com/auth/drive.appdata';

                this.loadGoogleAPI();
            }

            loadGoogleAPI() {
                const script = document.createElement('script');
                script.src = 'https://apis.google.com/js/api.js';
                script.onload = () => this.handleGoogleAPILoad();
                document.body.appendChild(script);
            }

            handleGoogleAPILoad() {
                gapi.load('client:auth2', () => {
                    gapi.client.init({
                        apiKey: this.API_KEY,
                        clientId: this.CLIENT_ID,
                        discoveryDocs: this.DISCOVERY_DOCS,
                        scope: this.SCOPES
                    }).then(() => {
                        // Listen for sign-in state changes
                        gapi.auth2.getAuthInstance().isSignedIn.listen((isSignedIn) => {
                            this.handleGoogleSignInStatus(isSignedIn);
                        });

                        // Handle initial sign-in state
                        this.handleGoogleSignInStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
                    });
                });
            }

            handleGoogleSignInStatus(isSignedIn) {
                const connectBtn = document.getElementById('google-drive-btn');
                if (isSignedIn) {
                    connectBtn.textContent = 'Disconnect Google Drive';
                    connectBtn.classList.add('connected');
                    this.data.settings.googleDriveConnected = true;
                    this.syncToGoogleDrive();
                } else {
                    connectBtn.textContent = 'Connect Google Drive';
                    connectBtn.classList.remove('connected');
                    this.data.settings.googleDriveConnected = false;
                }
                this.saveData();
            }

            async syncToGoogleDrive() {
                if (!this.data.settings.googleDriveConnected) {
                    console.log('Google Drive not connected');
                    return;
                }

                try {
                    const boundary = '-------314159265358979323846';
                    const delimiter = "\r\n--" + boundary + "\r\n";
                    const close_delim = "\r\n--" + boundary + "--";

                    const metadata = {
                        'name': 'injection_data.json',
                        'mimeType': 'application/json',
                        'parents': ['appDataFolder']
                    };

                    const multipartRequestBody =
                        delimiter +
                        'Content-Type: application/json\r\n\r\n' +
                        JSON.stringify(metadata) +
                        delimiter +
                        'Content-Type: application/json\r\n\r\n' +
                        JSON.stringify(this.data) +
                        close_delim;

                    // Check if file exists
                    const response = await gapi.client.drive.files.list({
                        'spaces': 'appDataFolder',
                        'fields': 'files(id, name)',
                        'pageSize': 10
                    });

                    const files = response.result.files;
                    let fileId = null;

                    if (files && files.length > 0) {
                        fileId = files[0].id;
                    }

                    if (fileId) {
                        // Update existing file
                        await gapi.client.request({
                            'path': `/upload/drive/v3/files/${fileId}`,
                            'method': 'PATCH',
                            'params': {'uploadType': 'multipart'},
                            'headers': {
                                'Content-Type': 'multipart/related; boundary="' + boundary + '"'
                            },
                            'body': multipartRequestBody
                        });
                        console.log('Data synced to Google Drive');
                    } else {
                        // Create new file
                        await gapi.client.request({
                            'path': '/upload/drive/v3/files',
                            'method': 'POST',
                            'params': {'uploadType': 'multipart'},
                            'headers': {
                                'Content-Type': 'multipart/related; boundary="' + boundary + '"'
                            },
                            'body': multipartRequestBody
                        });
                        console.log('Data uploaded to Google Drive');
                    }

                    this.data.settings.lastSync = new Date().toISOString();
                    this.updateSyncStatus();
                } catch (error) {
                    console.error('Error syncing to Google Drive:', error);
                }
            }

            async loadFromGoogleDrive() {
                if (!this.data.settings.googleDriveConnected) return;

                try {
                    const response = await gapi.client.drive.files.list({
                        'spaces': 'appDataFolder',
                        'fields': 'files(id, name)',
                        'pageSize': 10
                    });

                    const files = response.result.files;
                    if (files && files.length > 0) {
                        const file = await gapi.client.drive.files.get({
                            'fileId': files[0].id,
                            'alt': 'media'
                        });

                        const cloudData = JSON.parse(file.body);

                        // Merge cloud data with local data (prefer newer)
                        if (cloudData.settings && cloudData.settings.lastSync) {
                            const cloudTime = new Date(cloudData.settings.lastSync);
                            const localTime = this.data.settings.lastSync ? new Date(this.data.settings.lastSync) : new Date(0);

                            if (cloudTime > localTime) {
                                this.data = cloudData;
                                await this.saveData();
                                this.updateUI();
                                console.log('Loaded data from Google Drive');
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error loading from Google Drive:', error);
                }
            }

            updateSyncStatus() {
                if (this.data.settings.lastSync) {
                    const lastSync = new Date(this.data.settings.lastSync);
                    const syncStatus = document.createElement('div');
                    syncStatus.className = 'sync-status';
                    syncStatus.textContent = `Last synced: ${lastSync.toLocaleString()}`;

                    const settingsContainer = document.querySelector('#settings-tab .container');
                    const existingStatus = settingsContainer.querySelector('.sync-status');
                    if (existingStatus) {
                        existingStatus.textContent = syncStatus.textContent;
                    } else {
                        settingsContainer.appendChild(syncStatus);
                    }
                }
            }

            // ====================================
            // WITHINGS HEALTH API INTEGRATION
            // ====================================

            connectWithings() {
                // Withings OAuth 2.0 configuration
                // Replace with your actual Withings Client ID from developer.withings.com
                const WITHINGS_CLIENT_ID = 'YOUR_WITHINGS_CLIENT_ID';

                // Check if client ID has been configured
                if (WITHINGS_CLIENT_ID === 'YOUR_WITHINGS_CLIENT_ID') {
                    alert('Withings integration not configured. Please update WITHINGS_CLIENT_ID with your actual client ID from developer.withings.com');
                    return;
                }
                const WITHINGS_REDIRECT_URI = window.location.origin + '/withings-callback';
                const WITHINGS_AUTH_URL = 'https://account.withings.com/oauth2_user/authorize2';

                // Generate state for security
                const state = Math.random().toString(36).substring(2, 15);
                sessionStorage.setItem('withings_state', state);

                // Build authorization URL
                const params = new URLSearchParams({
                    response_type: 'code',
                    client_id: WITHINGS_CLIENT_ID,
                    scope: 'user.metrics',
                    redirect_uri: WITHINGS_REDIRECT_URI,
                    state: state
                });

                const authUrl = `${WITHINGS_AUTH_URL}?${params.toString()}`;

                // For demo purposes, show configuration instructions
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-header">
                        <h3 class="modal-title">Connect Withings Health</h3>
                        <button class="modal-close" onclick="this.parentElement.parentElement.remove(); document.getElementById('modal-overlay').style.display='none';">&times;</button>
                    </div>
                    <div class="modal-content">
                        <p>To enable Withings integration:</p>
                        <ol>
                            <li>Register your app at <a href="https://developer.withings.com" target="_blank">developer.withings.com</a></li>
                            <li>Get your Client ID and Secret</li>
                            <li>Update the WITHINGS_CLIENT_ID in this app</li>
                            <li>Configure OAuth redirect URL</li>
                        </ol>
                        <p>Once configured, this will allow automatic import of:</p>
                        <ul>
                            <li>Weight measurements</li>
                            <li>Body fat percentage</li>
                            <li>BMI calculations</li>
                            <li>Historical data</li>
                        </ul>
                        <button class="btn-primary" onclick="window.open('${authUrl}', '_blank')">Proceed to Withings</button>
                    </div>
                `;

                document.getElementById('modal-overlay').style.display = 'flex';
                document.getElementById('modal-overlay').appendChild(modal);
            }

            async handleWithingsCallback(code) {
                // This would handle the OAuth callback
                // Exchange code for access token
                // Store token securely
                // Fetch user data
                console.log('Withings callback handling for code:', code);

                // For production, implement token exchange and data fetching
                this.data.settings.withingsConnected = true;
                await this.saveData();
                this.fetchWithingsData();
            }

            async fetchWithingsData() {
                if (!this.data.settings.withingsConnected) return;

                try {
                    // In production, this would use the Withings API
                    // For now, simulate the API response structure
                    const mockWithingsData = {
                        body: {
                            measuregrps: [
                                {
                                    date: Math.floor(Date.now() / 1000),
                                    measures: [
                                        {
                                            value: 82500, // 82.5 kg
                                            type: 1, // Weight
                                            unit: -3 // kg
                                        },
                                        {
                                            value: 185, // 18.5%
                                            type: 6, // Fat percentage
                                            unit: -1
                                        }
                                    ]
                                }
                            ]
                        }
                    };

                    // Process Withings data
                    mockWithingsData.body.measuregrps.forEach(group => {
                        const timestamp = new Date(group.date * 1000).toISOString();
                        let weight_kg = null;
                        let body_fat_percentage = null;

                        group.measures.forEach(measure => {
                            if (measure.type === 1) { // Weight
                                weight_kg = measure.value * Math.pow(10, measure.unit);
                            } else if (measure.type === 6) { // Fat percentage
                                body_fat_percentage = measure.value * Math.pow(10, measure.unit);
                            }
                        });

                        if (weight_kg) {
                            // Check if we already have this weight entry
                            const existingEntry = this.data.weights.find(w =>
                                Math.abs(new Date(w.timestamp) - new Date(timestamp)) < 60000 // Within 1 minute
                            );

                            if (!existingEntry) {
                                this.addWeight({
                                    timestamp: timestamp,
                                    weight_kg: weight_kg,
                                    body_fat_percentage: body_fat_percentage,
                                    source: 'withings'
                                });
                            }
                        }
                    });

                    console.log('Withings data fetched and processed');
                } catch (error) {
                    console.error('Error fetching Withings data:', error);
                }
            }

            // ====================================
            // PWA FUNCTIONALITY
            // ====================================

            registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('/sw.js')
                        .then(registration => {
                            console.log('Service Worker registered successfully:', registration.scope);

                            // Force update check on every page load to bust cache
                            registration.update().then(() => {
                                console.log('Service Worker update check completed');
                            });

                            // Listen for new service worker
                            registration.addEventListener('updatefound', () => {
                                const newWorker = registration.installing;
                                console.log('New Service Worker found, installing...');

                                newWorker.addEventListener('statechange', () => {
                                    if (newWorker.state === 'activated') {
                                        console.log('New Service Worker activated');
                                        // Don't auto-reload - causes infinite loop on localhost
                                        // User can manually reload if needed
                                    }
                                });
                            });
                        })
                        .catch(error => {
                            console.log('Service Worker registration failed:', error);
                        });
                }
            }

            // Confetti animations
            triggerConfetti(type = 'default') {
                if (typeof confetti === 'undefined') return;

                switch (type) {
                    case 'milestone':
                        // Milestone achievement - big celebration
                        confetti({
                            particleCount: 100,
                            spread: 70,
                            origin: { y: 0.6 },
                            colors: ['#007AFF', '#34C759', '#FF9500']
                        });
                        break;

                    case 'goal':
                        // Weight loss goal - shower from top
                        const duration = 3 * 1000;
                        const animationEnd = Date.now() + duration;
                        const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 10000 };

                        function randomInRange(min, max) {
                            return Math.random() * (max - min) + min;
                        }

                        const interval = setInterval(function() {
                            const timeLeft = animationEnd - Date.now();

                            if (timeLeft <= 0) {
                                return clearInterval(interval);
                            }

                            const particleCount = 50 * (timeLeft / duration);
                            confetti(Object.assign({}, defaults, {
                                particleCount,
                                origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
                            }));
                            confetti(Object.assign({}, defaults, {
                                particleCount,
                                origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
                            }));
                        }, 250);
                        break;

                    case 'ontrack':
                        // Adheren ce milestone - small celebration
                        confetti({
                            particleCount: 50,
                            angle: 60,
                            spread: 55,
                            origin: { x: 0 },
                            colors: ['#34C759', '#00C853']
                        });
                        confetti({
                            particleCount: 50,
                            angle: 120,
                            spread: 55,
                            origin: { x: 1 },
                            colors: ['#34C759', '#00C853']
                        });
                        break;

                    default:
                        // Default celebration
                        confetti({
                            particleCount: 30,
                            spread: 60,
                            origin: { y: 0.7 }
                        });
                }
            }

            // Check for milestones and trigger celebrations
            checkMilestones() {
                const totalInjections = this.data.injections.length;
                const weights = this.data.weights;

                // Injection milestones
                if ([10, 25, 50, 100].includes(totalInjections)) {
                    this.triggerConfetti('milestone');
                    this.showEnhancedNotification({
                        title: ` ${totalInjections} Injections Milestone!`,
                        body: `You've completed ${totalInjections} injections. Great progress!`,
                        tag: 'milestone-' + totalInjections,
                        requireInteraction: true
                    });
                }

                // Weight loss milestones (if we have enough data)
                if (weights.length >= 2) {
                    const sorted = [...weights].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    const firstWeight = sorted[0].weight_kg;
                    const currentWeight = sorted[sorted.length - 1].weight_kg;
                    const loss = firstWeight - currentWeight;

                    // 5kg, 10kg, 15kg, 20kg milestones
                    const milestones = [5, 10, 15, 20, 25, 30];
                    milestones.forEach(target => {
                        if (loss >= target && !localStorage.getItem(`milestone-${target}kg`)) {
                            localStorage.setItem(`milestone-${target}kg`, 'true');
                            this.triggerConfetti('goal');
                            this.showEnhancedNotification({
                                title: ` ${target}kg Weight Loss!`,
                                body: `Amazing progress! You've lost ${loss.toFixed(1)}kg total!`,
                                tag: 'weightloss-' + target,
                                requireInteraction: true,
                                actions: [
                                    { action: 'view', title: ' View Progress' }
                                ]
                            });
                        }
                    });
                }
            }

            // ====================================
            // DATA INTEGRITY VALIDATION
            // ====================================

            validateDataIntegrity() {
                const issues = [];

                // Check vial integrity
                this.data.vials.forEach(vial => {
                    // Check if vial has been used more than its capacity
                    if (vial.status === 'active' && vial.concentration_mg_ml > 0) {
                        // Calculate total used by summing actual injection doses from this vial (excluding skipped)
                        const injectionsFromVial = this.data.injections.filter(inj => inj.vial_id === vial.vial_id && !inj.skipped);
                        const totalUsedMg = injectionsFromVial.reduce((sum, inj) => sum + inj.dose_mg, 0);
                        const calculatedRemainingMg = vial.total_mg - totalUsedMg;
                        const reportedRemainingMg = vial.remaining_ml * vial.concentration_mg_ml;

                        // Allow 0.5mg tolerance for rounding
                        if (Math.abs(calculatedRemainingMg - reportedRemainingMg) > 0.5) {
                            issues.push(`Vial ${vial.vial_id}: Calculated remaining (${calculatedRemainingMg.toFixed(1)}mg) doesn't match reported (${reportedRemainingMg.toFixed(1)}mg)`);
                        }
                    }

                    // Check for impossible remaining volumes
                    if (vial.remaining_ml < 0) {
                        issues.push(`Vial ${vial.vial_id}: Negative remaining volume (${vial.remaining_ml}ml)`);
                    }

                    // Check for vials marked as empty but still have volume
                    if (vial.status === 'empty' && vial.remaining_ml > 0) {
                        issues.push(`Vial ${vial.vial_id}: Marked as empty but has ${vial.remaining_ml}ml remaining`);
                    }

                    // Check for expired active vials (compare dates only, not times)
                    if (vial.status === 'active' && vial.expiration_date) {
                        const expiryDate = new Date(vial.expiration_date);
                        const today = new Date();
                        // Set both to midnight for fair comparison
                        expiryDate.setHours(0, 0, 0, 0);
                        today.setHours(0, 0, 0, 0);

                        if (expiryDate < today) {
                            issues.push(`Vial ${vial.vial_id}: Marked as active but expired on ${new Date(vial.expiration_date).toLocaleDateString()}`);
                        }
                    }
                });

                // Check injection integrity
                this.data.injections.forEach(injection => {
                    // Only validate vial reference if injection has a vial_id (null is valid)
                    if (injection.vial_id && injection.vial_id !== 'null') {
                        const vial = this.findVialById(injection.vial_id); // Phase 2: Use helper method
                        if (!vial) {
                            issues.push(`Injection ${injection.id}: References non-existent vial ${injection.vial_id}`);
                        }
                    }
                });

                if (issues.length > 0) {
                    console.warn('Data integrity issues found:', issues);
                    return issues;
                } else {
                    console.log('Data integrity check passed ');
                    return [];
                }
            }
        }

        // ====================================
        // NOTIFICATION SYSTEM
        // ====================================

        class SimpleNotificationManager {
            constructor() {
                this.container = null;
            }

            initialize() {
                this.container = document.getElementById('notification-container');
            }

            show(type, message) {
                if (!this.container) this.initialize();

                const notification = document.createElement('div');
                notification.className = `notification ${type}`;

                const icons = {
                    'success': '',
                    'error': '',
                    'warning': '',
                    'info': ''
                };

                const titles = {
                    'success': 'Success',
                    'error': 'Error',
                    'warning': 'Warning',
                    'info': 'Info'
                };

                notification.innerHTML = `
                    <div class="notification-icon">${icons[type] || ''}</div>
                    <div class="notification-content">
                        <div class="notification-title">${titles[type] || 'Notification'}</div>
                        <div class="notification-message">${message}</div>
                    </div>
                    <button class="notification-close" aria-label="Close"></button>
                `;

                this.container.appendChild(notification);

                const closeBtn = notification.querySelector('.notification-close');
                closeBtn.onclick = () => this.hide(notification);

                setTimeout(() => this.hide(notification), 3000);
            }

            hide(notification) {
                notification.classList.add('hiding');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }

            success(message) { this.show('success', message); }
            error(message) { this.show('error', message); }
            warning(message) { this.show('warning', message); }
            info(message) { this.show('info', message); }
        }

        // ====================================
        // DELETE MANAGER
        // ====================================

        class SimpleDeleteManager {
            constructor() {
                this.undoStack = [];
                this.maxUndoStack = 20;
                this.notificationManager = new SimpleNotificationManager();
                this.undoButton = null;
            }

            initialize() {
                this.notificationManager.initialize();
                this.undoButton = document.getElementById('undo-button');

                if (this.undoButton) {
                    this.undoButton.onclick = () => this.undoLastDelete();
                }
            }

            enableDeleteForShots() {
                const setupDeleteButtons = () => {
                    const shotItems = document.querySelectorAll('.shot-item');
                    shotItems.forEach(item => {
                        const deleteBtn = item.querySelector('.delete-btn');
                        if (deleteBtn && !deleteBtn.dataset.initialized) {
                            deleteBtn.dataset.initialized = 'true';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteShot(item, itemId, timestamp);
                            };
                        }

                        // Also add handler to the delete action button that appears after swipe
                        const deleteAction = item.querySelector('.delete-action');
                        if (deleteAction && !deleteAction.dataset.initialized) {
                            deleteAction.dataset.initialized = 'true';
                            deleteAction.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteShot(item, itemId, timestamp);
                            };
                        }
                    });
                };

                // Run immediately and after any UI update
                setupDeleteButtons();
                const observer = new MutationObserver(() => setupDeleteButtons());
                observer.observe(document.getElementById('shots-list'), {
                    childList: true,
                    subtree: true
                });
            }

            enableDeleteForVials() {
                const setupDeleteButtons = () => {
                    const vialItems = document.querySelectorAll('.vial-item');
                    vialItems.forEach(item => {
                        const deleteBtn = item.querySelector('.delete-btn');
                        if (deleteBtn && !deleteBtn.dataset.initialized) {
                            deleteBtn.dataset.initialized = 'true';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteVial(item, itemId, timestamp);
                            };
                        }

                        // Add handler for edit button
                        const editBtn = item.querySelector('.edit-btn');
                        if (editBtn && !editBtn.dataset.initialized) {
                            editBtn.dataset.initialized = 'true';
                            editBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                app.openEditVialModal(itemId);
                            };
                        }

                        // Also add handler to the delete action button that appears after swipe
                        const deleteAction = item.querySelector('.delete-action');
                        if (deleteAction && !deleteAction.dataset.initialized) {
                            deleteAction.dataset.initialized = 'true';
                            deleteAction.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteVial(item, itemId, timestamp);
                            };
                        }
                    });
                };

                setupDeleteButtons();
                const observer = new MutationObserver(() => setupDeleteButtons());
                observer.observe(document.getElementById('vials-list'), {
                    childList: true,
                    subtree: true
                });
            }

            enableDeleteForWeights() {
                const setupDeleteButtons = () => {
                    const weightItems = document.querySelectorAll('.weight-item');
                    weightItems.forEach(item => {
                        const deleteBtn = item.querySelector('.delete-btn');
                        if (deleteBtn && !deleteBtn.dataset.initialized) {
                            deleteBtn.dataset.initialized = 'true';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteWeight(item, itemId, timestamp);
                            };
                        }

                        // Also add handler to the delete action button that appears after swipe
                        const deleteAction = item.querySelector('.delete-action');
                        if (deleteAction && !deleteAction.dataset.initialized) {
                            deleteAction.dataset.initialized = 'true';
                            deleteAction.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteWeight(item, itemId, timestamp);
                            };
                        }
                    });
                };

                setupDeleteButtons();
                const observer = new MutationObserver(() => setupDeleteButtons());
                observer.observe(document.getElementById('weights-list'), {
                    childList: true,
                    subtree: true
                });
            }

            async handleDeleteShot(element, shotId, timestamp) {
                if (!confirm('Delete this injection?')) {
                    return;
                }

                // Find and delete the injection
                const index = app.data.injections.findIndex(inj => inj.id === shotId);
                if (index === -1) {
                    this.notificationManager.error('Injection not found');
                    return;
                }

                const deletedInjection = app.data.injections[index];

                // Mark as pending deletion to prevent sync from re-adding
                app._pendingDeletions.add(shotId);
                console.log(`Added ${shotId} to pending deletions`);

                // Add to undo stack
                this.undoStack.push({
                    type: 'injection',
                    data: deletedInjection,
                    index: index,
                    timestamp: Date.now()
                });

                if (this.undoStack.length > this.maxUndoStack) {
                    this.undoStack.shift();
                }

                // Reverse vial usage if injection had a vial
                if (deletedInjection.vial_id && deletedInjection.dose_mg) {
                    await app.reverseVialUsage(deletedInjection.vial_id, deletedInjection.dose_mg);
                }

                // Remove from app data
                app.data.injections.splice(index, 1);

                // Save and update UI
                app.saveData();
                app.updateUI();

                // Push deletion to sync queue (Phase 1B: Reliable sync with retry)
                // Note: Pending deletion will auto-expire after 2 minutes
                if (authManager && authManager.isAuthenticated() && app.syncQueue) {
                    app.syncQueue.add({
                        type: 'delete',
                        entity: 'injection',
                        localId: shotId,
                        data: { id: shotId }
                    });
                    console.log('Injection deletion added to sync queue');
                }
                // If offline, deletion will be queued and synced when back online

                // Animate out
                element.style.opacity = '0';
                element.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (element.parentNode) {
                        element.remove();
                    }
                }, 300);

                this.notificationManager.success('Injection deleted');
                this.showUndoButton();
            }

            async handleDeleteVial(element, vialId, timestamp) {
                // Check if vial has been used for any injections
                const hasInjections = app.data.injections.some(inj => inj.vial_id === vialId);

                if (hasInjections) {
                    if (!confirm('This vial has been used for injections. Delete anyway? (Injections will remain)')) {
                        return;
                    }
                }

                if (!hasInjections && !confirm('Delete this vial?')) {
                    return;
                }

                const index = app.data.vials.findIndex(v => app.getVialId(v) === vialId);
                if (index === -1) {
                    this.notificationManager.error('Vial not found');
                    return;
                }

                const deletedVial = app.data.vials[index];

                // Mark as pending deletion to prevent sync from re-adding
                app._pendingDeletions.add(vialId);
                console.log(`Added ${vialId} to pending deletions`);

                // Add to undo stack
                this.undoStack.push({
                    type: 'vial',
                    data: deletedVial,
                    index: index,
                    timestamp: Date.now()
                });

                if (this.undoStack.length > this.maxUndoStack) {
                    this.undoStack.shift();
                }

                // Remove from app data
                app.data.vials.splice(index, 1);

                // Save and update UI
                app.saveData();
                app.updateUI();

                // Sync deletion to cloud
                // Note: Pending deletion will auto-expire after 2 minutes (set in add() call above)
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        await apiClient.deleteVial(vialId);
                        console.log('Vial deleted from cloud successfully');
                        // Pending deletion will auto-expire, no manual cleanup needed
                    } catch (error) {
                        console.error('Failed to delete vial from cloud:', error);
                        // Pending deletion will auto-expire, allowing retry on next sync
                    }
                }
                // If offline, pending deletion persists until sync succeeds or expires

                // Animate out
                element.style.opacity = '0';
                element.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (element.parentNode) {
                        element.remove();
                    }
                }, 300);

                this.notificationManager.success('Vial deleted');
                this.showUndoButton();
            }

            async handleDeleteWeight(element, weightId, timestamp) {
                if (!confirm('Delete this weight entry?')) {
                    return;
                }

                // Try to find by ID first, fallback to timestamp for backwards compatibility
                let index = app.data.weights.findIndex(w => w.id === weightId);
                if (index === -1) {
                    index = app.data.weights.findIndex(w => w.timestamp === timestamp);
                }

                if (index === -1) {
                    this.notificationManager.error('Weight entry not found');
                    return;
                }

                const deletedWeight = app.data.weights[index];
                const actualWeightId = deletedWeight.id || weightId;

                // Mark as pending deletion to prevent sync from re-adding
                app._pendingDeletions.add(actualWeightId);
                console.log(`Added ${actualWeightId} to pending deletions`);

                // Add to undo stack
                this.undoStack.push({
                    type: 'weight',
                    data: deletedWeight,
                    index: index,
                    timestamp: Date.now()
                });

                if (this.undoStack.length > this.maxUndoStack) {
                    this.undoStack.shift();
                }

                // Remove from app data
                app.data.weights.splice(index, 1);

                // Save and update UI
                app.saveData();
                app.updateUI();

                // Push deletion to sync queue (Phase 1B: Reliable sync with retry)
                // Note: Pending deletion will auto-expire after 2 minutes
                if (authManager && authManager.isAuthenticated() && actualWeightId && app.syncQueue) {
                    app.syncQueue.add({
                        type: 'delete',
                        entity: 'weight',
                        localId: actualWeightId,
                        data: { id: actualWeightId }
                    });
                    console.log('Weight deletion added to sync queue');
                }
                // If offline, deletion will be queued and synced when back online

                // Animate out
                element.style.opacity = '0';
                element.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (element.parentNode) {
                        element.remove();
                    }
                }, 300);

                this.notificationManager.success('Weight entry deleted');
                this.showUndoButton();
            }

            showUndoButton() {
                if (this.undoButton) {
                    this.undoButton.classList.add('show');
                    setTimeout(() => {
                        this.undoButton.classList.remove('show');
                    }, 5000);
                }
            }

            async undoLastDelete() {
                if (this.undoStack.length === 0) {
                    this.notificationManager.warning('Nothing to undo');
                    return;
                }

                const operation = this.undoStack.pop();

                // Remove from pending deletions if present
                const itemId = operation.type === 'vial' ? operation.data.vial_id :
                               operation.type === 'injection' ? operation.data.id :
                               operation.data.timestamp;
                if (app._pendingDeletions.has(itemId)) {
                    app._pendingDeletions.delete(itemId);
                    console.log(`Removed ${itemId} from pending deletions (undo)`);
                }

                // Restore locally
                switch (operation.type) {
                    case 'injection':
                        app.data.injections.splice(operation.index, 0, operation.data);
                        break;
                    case 'vial':
                        app.data.vials.splice(operation.index, 0, operation.data);
                        break;
                    case 'weight':
                        app.data.weights.splice(operation.index, 0, operation.data);
                        break;
                }

                app.saveData();
                app.updateUI();

                // Sync restoration to cloud
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        switch (operation.type) {
                            case 'injection':
                                await apiClient.createInjection({
                                    id: operation.data.id,
                                    timestamp: operation.data.timestamp,
                                    doseMg: operation.data.dose_mg,
                                    site: operation.data.injection_site,
                                    vialId: operation.data.vial_id,
                                    notes: operation.data.notes || ''
                                });
                                console.log('Undone injection synced to cloud');
                                break;
                            case 'vial':
                                await apiClient.createVial({
                                    id: operation.data.vial_id,
                                    startDate: operation.data.order_date,
                                    initialVolumeMl: operation.data.bac_water_ml,
                                    concentrationMgPerMl: operation.data.concentration_mg_per_ml,
                                    currentVolumeMl: operation.data.current_volume_ml,
                                    usedVolumeMl: operation.data.used_volume_ml,
                                    status: operation.data.status,
                                    source: operation.data.supplier || '',
                                    notes: operation.data.notes || ''
                                });
                                console.log('Undone vial synced to cloud');
                                break;
                            case 'weight':
                                await apiClient.createWeight({
                                    timestamp: operation.data.timestamp,
                                    weightKg: operation.data.weight_kg,
                                    source: operation.data.source || 'manual',
                                    notes: operation.data.notes || ''
                                });
                                console.log('Undone weight synced to cloud');
                                break;
                        }
                    } catch (error) {
                        console.error('Failed to sync undo to cloud:', error);
                        this.notificationManager.warning('Restored locally but cloud sync failed');
                    }
                }

                const typeNames = {
                    'injection': 'Injection',
                    'vial': 'Vial',
                    'weight': 'Weight entry'
                };
                this.notificationManager.success(`${typeNames[operation.type]} restored`);

                if (this.undoButton) {
                    this.undoButton.classList.remove('show');
                }
            }
        }

        // ====================================
        // RESILIENT BACKUP SYSTEM
        // ====================================

        class ResilientBackupManager {
            constructor() {
                this.storageKey = 'injectionTrackerData';
                this.dbName = 'RetatrutideDB';
                this.dbVersion = 1;
                this.storeName = 'appData';
                this.db = null;
            }

            async initialize() {
                // Initialize IndexedDB
                await this.initIndexedDB();

                console.log('Resilient backup system initialized');
            }

            initIndexedDB() {
                return new Promise((resolve) => {
                    if (!window.indexedDB) {
                        console.warn('IndexedDB not available');
                        resolve(null);
                        return;
                    }

                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = () => {
                        console.error('IndexedDB open failed');
                        resolve(null);
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        console.log('IndexedDB initialized');
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const objectStore = db.createObjectStore(this.storeName, { keyPath: 'key' });
                            objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            }

            async saveData(data) {
                // Save to localStorage
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(data));
                } catch (error) {
                    console.error('Failed to save to localStorage:', error);
                }

                // Save to IndexedDB as fallback
                if (this.db) {
                    await this.saveToIndexedDB(data);
                }

                return true;
            }

            async saveToIndexedDB(data) {
                if (!this.db) return false;

                return new Promise((resolve) => {
                    try {
                        const transaction = this.db.transaction([this.storeName], 'readwrite');
                        const objectStore = transaction.objectStore(this.storeName);

                        const record = {
                            key: this.storageKey,
                            data: data,
                            timestamp: Date.now(),
                            date: new Date().toISOString()
                        };

                        const request = objectStore.put(record);
                        request.onsuccess = () => resolve(true);
                        request.onerror = () => resolve(false);
                    } catch (error) {
                        console.error('IndexedDB save error:', error);
                        resolve(false);
                    }
                });
            }

            async loadData() {
                // Check if nuclear reset is in progress
                const nuclearResetFlag = localStorage.getItem('__nuclear_reset_in_progress__');
                if (nuclearResetFlag === 'true') {
                    console.log(' Nuclear reset in progress - skipping data restore from IndexedDB');
                    localStorage.removeItem('__nuclear_reset_in_progress__');
                    return null;
                }

                // Try localStorage first
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) {
                        return JSON.parse(stored);
                    }
                } catch (error) {
                    console.error('Failed to load from localStorage:', error);
                }

                // Try IndexedDB as fallback
                if (this.db) {
                    return await this.loadFromIndexedDB();
                }

                return null;
            }

            async loadFromIndexedDB() {
                if (!this.db) return null;

                return new Promise((resolve) => {
                    try {
                        const transaction = this.db.transaction([this.storeName], 'readonly');
                        const objectStore = transaction.objectStore(this.storeName);
                        const request = objectStore.get(this.storageKey);

                        request.onsuccess = () => {
                            if (request.result) {
                                resolve(request.result.data);
                            } else {
                                resolve(null);
                            }
                        };

                        request.onerror = () => resolve(null);
                    } catch (error) {
                        console.error('IndexedDB load error:', error);
                        resolve(null);
                    }
                });
            }

        }

        // ====================================
        // INITIALIZE APPLICATION
        // ====================================

        let app;
        let deleteManager;
        let backupManager;

        document.addEventListener('DOMContentLoaded', async function() {
            console.log('[INIT] DOMContentLoaded event fired');

            // CRITICAL: Set up auth button IMMEDIATELY for mobile compatibility
            const authGateButtonEarly = document.getElementById('auth-gate-button');
            if (authGateButtonEarly) {
                console.log('[INIT] Setting up early auth button handler for mobile');

                const handleSignIn = async (event) => {
                    event.preventDefault();
                    console.log('[AUTH-EARLY] Sign in button activated');
                    authGateButtonEarly.textContent = 'Redirecting...';
                    authGateButtonEarly.disabled = true;
                    try {
                        if (typeof authManager !== 'undefined') {
                            await authManager.signInWithGoogle();
                        } else {
                            alert('Authentication system not ready. Please refresh the page.');
                            authGateButtonEarly.textContent = 'Sign In with Google';
                            authGateButtonEarly.disabled = false;
                        }
                    } catch (error) {
                        console.error('[AUTH-EARLY] Error:', error);
                        authGateButtonEarly.textContent = 'Sign In with Google';
                        authGateButtonEarly.disabled = false;
                        alert(error.message || 'Sign in failed. Please try again.');
                    }
                };

                // Add both click and touchend for maximum mobile compatibility
                authGateButtonEarly.addEventListener('click', handleSignIn, { passive: false });
                authGateButtonEarly.addEventListener('touchend', handleSignIn, { passive: false, once: false });
                console.log('[INIT] Auth button handlers attached (click + touchend)');
            } else {
                console.error('[INIT] Auth gate button not found at initialization!');
            }

            // CRITICAL: Check test mode FIRST before any async operations (localhost only!)
            const urlParams = new URLSearchParams(window.location.search);
            const isTestMode = urlParams.get('test') === 'true';
            const isLocalhost = window.location.hostname === 'localhost' ||
                                window.location.hostname === '127.0.0.1';

            if (isTestMode && isLocalhost) {
                console.log('[INIT] Test mode detected on localhost - setting SKIP_AUTH_INIT flag');
                window.SKIP_AUTH_INIT = true;

                // Immediately hide auth gate and show app content
                const authGate = document.getElementById('auth-gate');
                const appContent = document.getElementById('app-content');
                const appHeader = document.getElementById('app-header');
                const bottomNav = document.getElementById('bottom-nav');

                if (authGate) authGate.style.display = 'none';
                if (appContent) appContent.style.display = 'block';
                if (appHeader) appHeader.style.display = 'block';
                if (bottomNav) bottomNav.style.display = 'flex';

                console.log('[INIT] Test mode UI elements configured');
            } else if (isTestMode && !isLocalhost) {
                console.warn('[INIT] Test mode parameter detected on production - IGNORING for security');
            }

            console.log('[INIT] Creating InjectionTracker instance');
            app = new InjectionTracker();
            window.app = app; // Expose globally for tests
            console.log('[INIT] window.app set, registering service worker');
            app.registerServiceWorker();

            // Initialize backup system
            console.log('[INIT] Initializing backup manager');
            backupManager = new ResilientBackupManager();
            await backupManager.initialize();
            console.log('[INIT] Backup manager initialized');

            // Initialize delete functionality
            deleteManager = new SimpleDeleteManager();
            deleteManager.initialize();
            deleteManager.enableDeleteForShots();
            deleteManager.enableDeleteForVials();
            deleteManager.enableDeleteForWeights();

            // Initialize cloud integration
            apiClient.initialize(authManager);
            // Legacy cloud storage disabled - using direct API sync instead
            // await cloudStorage.initialize(authManager, apiClient, app.storage);

            // Set up auth state change listener (after all initializations)
            setupAuthStateListener();

            // Handle URL parameters for PWA shortcuts (reuse urlParams from above)
            if (urlParams.get('action') === 'add_shot') {
                setTimeout(() => app.openModal('add-shot-modal'), 500);
            } else if (urlParams.get('tab')) {
                const tab = urlParams.get('tab');
                setTimeout(() => {
                    document.querySelector(`[data-tab="${tab}"]`)?.click();
                }, 500);
            }
        });

        // Update UI based on auth state
        function updateAuthUI(user) {
            const authButton = document.getElementById('auth-button');
            const userInfo = document.getElementById('user-info');

            if (user) {
                // User is signed in
                if (authButton) {
                    authButton.textContent = 'Logout';
                    authButton.onclick = () => authManager.signOut();
                }
                if (userInfo) {
                    userInfo.textContent = `Signed in as ${user.displayName || user.email}`;
                    userInfo.style.display = 'block';
                }
            } else {
                // User is signed out
                if (authButton) {
                    authButton.textContent = 'Sign In with Google';
                    authButton.onclick = async () => {
                        authButton.textContent = 'Redirecting...';
                        authButton.disabled = true;
                        try {
                            await authManager.signInWithGoogle();
                            // Page will redirect, so no need to reset button state
                        } catch (error) {
                            console.error('Sign in error:', error);
                            authButton.textContent = 'Sign In with Google';
                            authButton.disabled = false;
                            alert(error.message || 'Failed to sign in. Please try again.');
                        }
                    };
                }
                if (userInfo) {
                    userInfo.style.display = 'none';
                }
            }
        }

        // Auth state listener setup function
        function setupAuthStateListener() {
            console.log('[INIT] Setting up auth state listener');

            const authGate = document.getElementById('auth-gate');
            const authGateButton = document.getElementById('auth-gate-button');
            const appContent = document.getElementById('app-content');
            let lastAuthUserId = null;  // Track last known user to prevent duplicate syncs

            // Test mode bypass: skip authentication ONLY if on localhost with test param
            const urlParams = new URLSearchParams(window.location.search);
            const isTestMode = urlParams.get('test') === 'true';
            const isLocalhost = window.location.hostname === 'localhost' ||
                                window.location.hostname === '127.0.0.1';

            if (isTestMode && isLocalhost && window.SKIP_AUTH_INIT) {
                console.log('[INIT] Test mode active on localhost - skipping auth setup');
                // Disable cloud backup button in test mode
                const cloudBackupBtn = document.getElementById('create-cloud-backup-btn');
                if (cloudBackupBtn) {
                    cloudBackupBtn.disabled = true;
                }
                // Hide sync queue modal in test mode (prevents UI interference)
                const syncQueueModal = document.getElementById('sync-queue-modal');
                if (syncQueueModal) {
                    syncQueueModal.style.display = 'none';
                }
                return; // Skip auth setup entirely in test mode
            } else if (isTestMode && !isLocalhost) {
                console.warn('[INIT] Test mode parameter detected on production - IGNORING for security');
            }

            // Auth button handler is now set up early in DOMContentLoaded for mobile compatibility
            // No need to set it up again here - just verify it exists
            if (authGateButton) {
                console.log('[AUTH-SETUP] Auth gate button found (handler already attached during init)');
            } else {
                console.error('[AUTH-SETUP] Auth gate button not found!');
            }

            // Check for stored auth errors and display them
            try {
                const authErrorJson = sessionStorage.getItem('auth_error');
                if (authErrorJson) {
                    const authError = JSON.parse(authErrorJson);
                    // Only show errors from the last 5 minutes
                    if (Date.now() - authError.timestamp < 5 * 60 * 1000) {
                        const errorMessageDiv = document.getElementById('auth-error-message');
                        const errorTextP = document.getElementById('auth-error-text');
                        const popupFallbackBtn = document.getElementById('auth-popup-fallback-button');

                        if (errorMessageDiv && errorTextP) {
                            errorTextP.textContent = authError.message;
                            errorMessageDiv.style.display = 'block';
                        }

                        // Show popup fallback button for storage-related errors
                        if (authError.code === 'missing-initial-state' && popupFallbackBtn) {
                            popupFallbackBtn.style.display = 'block';

                            // Set up popup fallback button handler
                            popupFallbackBtn.addEventListener('click', async () => {
                                popupFallbackBtn.textContent = 'Opening...';
                                popupFallbackBtn.disabled = true;
                                try {
                                    await authManager.signInWithGoogle(true); // Force popup mode
                                    // Clear error on success
                                    sessionStorage.removeItem('auth_error');
                                } catch (error) {
                                    console.error('Popup sign in error:', error);
                                    popupFallbackBtn.textContent = 'Try Popup Mode';
                                    popupFallbackBtn.disabled = false;
                                    if (errorTextP) {
                                        errorTextP.textContent = error.message || 'Sign-in failed. Please try again.';
                                    }
                                }
                            });
                        }
                    } else {
                        // Error is too old, clear it
                        sessionStorage.removeItem('auth_error');
                    }
                }
            } catch (e) {
                console.error('Failed to check auth errors:', e);
            }

            // Show/hide content based on auth state
            authManager.onAuthStateChange((user) => {
            if (user) {
                // Check if this is a new auth state (not just a token refresh)
                const isNewAuth = lastAuthUserId !== user.uid;
                lastAuthUserId = user.uid;

                // User signed in - show app, hide gate
                if (authGate) authGate.style.display = 'none';
                if (appContent) appContent.style.display = 'block';

                // Show header and navigation
                const appHeader = document.getElementById('app-header');
                const bottomNav = document.getElementById('bottom-nav');
                if (appHeader) appHeader.style.display = 'block';
                if (bottomNav) bottomNav.style.display = 'flex';

                updateAuthUI(user);

                // Phase 1B: Initialize sync queue (only once)
                if (!app.syncQueue && window.SyncQueue) {
                    app.syncQueue = new window.SyncQueue(apiClient);
                    console.log('[Phase1B] Sync queue initialized');
                }

                // Enable cloud backup button
                const cloudBackupBtn = document.getElementById('create-cloud-backup-btn');
                if (cloudBackupBtn) {
                    cloudBackupBtn.disabled = false;
                }

                // ALWAYS sync from cloud when authenticated (cloud is source of truth)
                if (app) {
                    if (isNewAuth) {
                        console.log('New auth detected, performing full sync...');
                    } else {
                        console.log('Auth state confirmed, syncing from cloud...');
                    }

                    // Update cloud backup status
                    app.updateCloudBackupStatus();

                    // Check if auto-backup is needed
                    app.checkAutoBackup();

                    // Sync data from cloud - ALWAYS (protected by guard to prevent concurrent syncs)
                    app.syncFromCloud();

                    // Sync settings from cloud
                    app.syncSettingsFromCloud();
                }
            } else {
                // User signed out - reset tracking and show gate
                lastAuthUserId = null;
                if (authGate) authGate.style.display = 'flex';
                if (appContent) appContent.style.display = 'none';

                // Hide header and navigation
                const appHeader = document.getElementById('app-header');
                const bottomNav = document.getElementById('bottom-nav');
                if (appHeader) appHeader.style.display = 'none';
                if (bottomNav) bottomNav.style.display = 'none';

                // Reset auth gate button to initial state
                if (authGateButton) {
                    authGateButton.textContent = 'Sign In with Google';
                    authGateButton.disabled = false;
                }

                // Disable cloud backup button
                const cloudBackupBtn = document.getElementById('create-cloud-backup-btn');
                if (cloudBackupBtn) {
                    cloudBackupBtn.disabled = true;
                }

                // Update cloud backup status
                if (app) {
                    app.updateCloudBackupStatus();
                }
            }
            });
        }
    </script>
    </div> <!-- Close app-content -->
</body>
</html>