<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta name="googlebot" content="noindex, nofollow">
    <title>Injection Tracker</title>

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Injection Tracker">
    <meta name="description" content="Comprehensive injection tracker with vial management and weight tracking">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Crect width='32' height='32' fill='%231a1a1a'/%3E%3Ctext x='50%25' y='50%25' font-family='sans-serif' font-size='16' fill='white' text-anchor='middle' dominant-baseline='central'%3ESR%3C/text%3E%3C/svg%3E">

    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- Confetti for celebrations -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <!-- Firebase Configuration -->
    <script>
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyDkdbPPZ2pySDOWBhAsSWzkfyYWvR0jlO8",
            authDomain: "reta-tracker.firebaseapp.com",
            projectId: "reta-tracker",
            storageBucket: "reta-tracker.firebasestorage.app",
            messagingSenderId: "273148192362",
            appId: "1:273148192362:web:c3011ac8cf76a3611e0c13"
        };
        firebase.initializeApp(firebaseConfig);
    </script>

    <!-- Cloud Integration Modules -->
    <script src="js/auth-manager.js"></script>
    <script src="js/api-client.js"></script>
    <script src="js/cloud-storage.js"></script>
    <script src="js/migration-wizard.js"></script>

    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: #0a0a0a;
            --secondary-bg: #1a1a1a;
            --card-bg: #2a2a2a;
            --border-color: #333333;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #888888;
            --accent-color: #007AFF;
            --success-color: #34C759;
            --warning-color: #FF9500;
            --danger-color: #FF3B30;
            --border-radius: 12px;
            --border-radius-sm: 8px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
            padding-bottom: 80px;
            line-height: 1.5;
        }

        /* Header Styles */
        #app-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
            height: 60px;
            backdrop-filter: blur(10px);
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-md);
            height: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        .menu-btn, .add-shot-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 18px;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .add-shot-btn {
            background-color: var(--accent-color);
            color: white;
            font-weight: 600;
            font-size: 14px;
            padding: var(--spacing-sm) var(--spacing-md);
        }

        .menu-btn:hover, .add-shot-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .add-shot-btn:hover {
            background-color: #0056b3;
        }

        .date-display {
            font-weight: 600;
            font-size: 16px;
            color: var(--text-primary);
        }

        /* Main Content */
        #main-content {
            margin-top: 60px;
            min-height: calc(100vh - 140px);
        }

        .container {
            padding: var(--spacing-lg) var(--spacing-md);
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Responsive design */
        @media (min-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .results-stats {
                grid-template-columns: repeat(4, 1fr);
            }

            .inventory-stats {
                grid-template-columns: repeat(4, 1fr);
            }

            .chart-container, .supply-forecast-container {
                padding: var(--spacing-xl);
            }

            .chart-container canvas {
                max-height: 600px;
            }

            .shot-item, .vial-item {
                padding: var(--spacing-lg);
            }

            .form-container {
                max-width: 600px;
                margin: 0 auto;
            }

            .countdown-container {
                max-width: 600px;
                margin: 0 auto var(--spacing-lg);
            }
        }

        /* Tablet specific */
        @media (min-width: 768px) and (max-width: 1024px) {
            .container {
                max-width: 90%;
            }
        }

        /* Large desktop */
        @media (min-width: 1200px) {
            .tab-content {
                max-width: 1000px;
                margin: 0 auto;
            }
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: calc(100vh - 140px);
            font-size: 18px;
            color: var(--text-secondary);
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
        }

        .stat-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            text-align: center;
            transition: background-color 0.2s;
            min-width: 0; /* Allow cards to shrink */
        }

        .stat-card:hover {
            background-color: #353535;
        }

        .stat-value {
            font-size: clamp(20px, 4vw, 24px); /* Fluid typography */
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-muted);
            font-weight: 500;
        }

        /* Chart Container */
        .chart-container, .supply-forecast-container {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .chart-container h3, .supply-forecast-container h3 {
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
        }

        .chart-container canvas {
            max-height: 450px;
            width: 100% !important;
            height: auto !important;
        }

        .chart-section {
            margin-bottom: var(--spacing-xl);
        }

        .chart-section-title {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
            padding-left: var(--spacing-md);
        }

        .supply-forecast {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .forecast-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-color);
        }

        .forecast-row:last-child {
            border-bottom: none;
        }

        .forecast-label {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .forecast-value {
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
        }

        .forecast-input-group {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .forecast-input {
            width: 60px;
            padding: var(--spacing-xs);
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            font-size: 16px;
            font-weight: 600;
            text-align: center;
        }

        .forecast-unit {
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Countdown Container */
        .countdown-container {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            text-align: center;
        }

        .countdown-container h3 {
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
        }

        .countdown-circle {
            position: relative;
            display: inline-block;
        }

        .countdown-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .next-shot-day {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-color);
            line-height: 1;
        }

        .next-shot-date {
            font-size: 32px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 4px 0;
        }

        .next-shot-time {
            font-size: 18px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .countdown-progress {
            width: 200px;
            height: 200px;
        }

        .countdown-progress circle {
            transition: stroke-dashoffset 1s ease;
        }

        /* Buttons */
        .btn-primary, .btn-secondary {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md) var(--spacing-lg);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: var(--spacing-sm);
        }

        .btn-secondary {
            background-color: var(--card-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-primary:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        .btn-secondary:hover {
            background-color: #353535;
        }

        /* Shots List */
        .shots-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
        }

        .shots-header h2 {
            font-size: 24px;
            font-weight: 700;
        }

        .shots-list, .weights-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .shot-item, .weight-item {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
            position: relative;
        }

        .shot-item:hover, .weight-item:hover {
            background-color: #353535;
        }

        .shot-content, .weight-content {
            flex: 1;
        }

        .shot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .shot-dose {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-color);
        }

        .shot-date {
            font-size: 14px;
            color: var(--text-muted);
        }

        .shot-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Results Header */
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .results-header h2 {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }

        .add-shot-btn-results {
            background-color: transparent;
            color: var(--accent-color);
            border: none;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            padding: 8px 0;
        }

        .add-shot-btn-results:hover {
            opacity: 0.7;
        }

        /* Time Period Segmented Control */
        .time-period-control {
            display: flex;
            background-color: #3a3a3a;
            border-radius: 10px;
            padding: 2px;
            margin-bottom: 24px;
        }

        .period-btn {
            flex: 1;
            background-color: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .period-btn.active {
            background-color: #505050;
            color: var(--text-primary);
        }

        .period-btn:hover:not(.active) {
            color: var(--text-primary);
        }

        /* Weight Change Section */
        .weight-change-section {
            margin-bottom: 24px;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title h3 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .section-icon {
            width: 24px;
            height: 24px;
            color: var(--text-secondary);
        }

        .date-range {
            font-size: 14px;
            color: var(--text-muted);
        }

        /* Results Stats Grid (2x3) */
        .results-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        .result-card {
            background-color: #3a3a3a;
            border: 1px solid #4a4a4a;
            border-radius: 12px;
            padding: 16px;
        }

        .result-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .metric-icon {
            width: 16px;
            height: 16px;
            stroke-width: 2.5;
        }

        .result-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Old results-stats for backward compatibility */
        .results-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
        }

        /* Inventory */
        .inventory-header {
            margin-bottom: var(--spacing-lg);
        }

        .vials-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
        }

        .vial-item {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
            position: relative;
        }

        .vial-content {
            flex: 1;
        }

        .vial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .vial-status {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .vial-status.active {
            background-color: var(--success-color);
            color: white;
        }

        .vial-status.expired {
            background-color: var(--danger-color);
            color: white;
        }

        .vial-status.expiring {
            background-color: var(--warning-color);
            color: white;
        }

        .vial-status.empty {
            background-color: var(--text-muted);
            color: white;
        }

        .vial-status.dry_stock {
            background-color: var(--warning-color);
            color: var(--bg-color);
        }

        .vial-item.dry_stock {
            border-left: 4px solid var(--warning-color);
        }

        /* Delete Button Styles */
        .delete-btn {
            background-color: transparent;
            border: 2px solid var(--danger-color);
            color: var(--danger-color);
            border-radius: var(--border-radius-sm);
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .delete-btn:hover {
            background-color: var(--danger-color);
            color: white;
            opacity: 1;
            transform: scale(1.05);
        }

        .delete-btn:active {
            transform: scale(0.95);
        }

        .delete-btn svg {
            width: 20px;
            height: 20px;
        }

        .vial-info {
            flex: 1;
        }

        .vial-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .vial-subtitle {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 2px;
        }

        .vial-details {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .vial-detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .vial-detail-row span:first-child {
            color: var(--text-muted);
            font-weight: 500;
        }

        .vial-detail-row span:last-child {
            color: var(--text-secondary);
            font-weight: 600;
        }

        .inventory-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
        }


        .inventory-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            text-align: center;
        }

        .inventory-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--warning-color);
            margin-bottom: var(--spacing-xs);
        }

        .inventory-label {
            font-size: 14px;
            color: var(--text-muted);
        }

        /* Settings */
        .settings-section {
            margin-bottom: var(--spacing-xl);
        }

        .settings-section h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
        }

        .settings-section label {
            display: block;
            margin-bottom: var(--spacing-md);
            color: var(--text-secondary);
        }

        .settings-section select,
        .settings-section input[type="number"],
        .settings-section input[type="text"] {
            width: 100%;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            color: var(--text-primary);
            font-size: 16px;
            margin-top: var(--spacing-sm);
        }

        .settings-section input[type="checkbox"] {
            width: auto;
            margin-left: var(--spacing-sm);
            transform: scale(1.2);
        }

        .btn-secondary.connected {
            background-color: var(--success-color);
            color: white;
        }

        .setting-input-wrapper {
            position: relative;
        }

        .save-indicator {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%) scale(0.8);
            font-size: 13px;
            font-weight: 600;
            color: #34C759;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            white-space: nowrap;
        }

        .save-indicator.show {
            opacity: 1;
            transform: translateY(-50%) scale(1);
        }

        @keyframes saveTextPulse {
            0%, 100% { opacity: 1; transform: translateY(-50%) scale(1); }
            50% { opacity: 0.7; transform: translateY(-50%) scale(0.95); }
        }

        .save-indicator.show {
            animation: saveTextPulse 0.6s ease-in-out;
        }

        .notification-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background-color: var(--secondary-bg);
            border-radius: var(--border-radius-sm);
            margin-bottom: 8px;
        }

        .notification-toggle label {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .notification-toggle input[type="checkbox"] {
            margin: 0;
        }

        .sync-status {
            margin-top: var(--spacing-md);
            padding: var(--spacing-md);
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .modal-content {
            padding: var(--spacing-lg);
        }

        .modal-content p,
        .modal-content li {
            color: var(--text-secondary);
            margin-bottom: var(--spacing-sm);
        }

        .modal-content a {
            color: var(--accent-color);
            text-decoration: none;
        }

        .modal-content a:hover {
            text-decoration: underline;
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--secondary-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: var(--spacing-sm) 0;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .nav-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            transition: color 0.2s;
            min-width: 60px;
        }

        .nav-btn.active {
            color: var(--accent-color);
        }

        .nav-btn:hover {
            color: var(--text-primary);
        }

        .nav-btn.active:hover {
            color: var(--accent-color);
        }

        .nav-icon {
            width: 24px;
            height: 24px;
            margin-bottom: var(--spacing-xs);
            stroke: currentColor;
        }

        .nav-btn.active .nav-icon {
            stroke: var(--accent-color);
        }

        .nav-label {
            font-size: 12px;
            font-weight: 500;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-xl);
            margin: var(--spacing-md);
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Migration Modal Styles */
        #migration-modal .modal-content {
            max-width: 500px;
        }

        .migration-summary {
            background: var(--card-bg);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-lg) 0;
        }

        .migration-summary h3 {
            margin-bottom: var(--spacing-sm);
        }

        .migration-summary ul {
            list-style: none;
            margin: var(--spacing-sm) 0;
        }

        .migration-summary li {
            padding: var(--spacing-xs) 0;
        }

        .migration-actions {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--card-bg);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: var(--spacing-md);
        }

        .progress-fill {
            height: 100%;
            background: var(--success-color);
            transition: width 0.3s ease;
            width: 0%;
        }

        .migration-success,
        .migration-error {
            text-align: center;
            padding: var(--spacing-lg);
        }

        .migration-stats {
            background: var(--card-bg);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
        }

        .migration-stats p {
            padding: var(--spacing-xs) 0;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
        }

        .modal-title {
            font-size: 20px;
            font-weight: 700;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
            padding: var(--spacing-xs);
        }

        /* Form Styles */
        .form-group {
            margin-bottom: var(--spacing-lg);
        }

        .form-group label {
            display: block;
            margin-bottom: var(--spacing-sm);
            color: var(--text-secondary);
            font-weight: 500;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            color: var(--text-primary);
            font-size: 16px;
            transition: border-color 0.2s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Enhanced Responsive Design */

        /* Mobile First - Small phones (320px - 480px) */
        @media (max-width: 480px) {
            :root {
                --spacing-sm: 8px;
                --spacing-md: 12px;
                --spacing-lg: 16px;
                --spacing-xl: 20px;
            }

            body {
                font-size: 14px;
            }

            .container {
                padding: var(--spacing-md) var(--spacing-sm);
            }

            .stats-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-sm);
            }

            .header-content {
                padding: 0 var(--spacing-sm);
                flex-wrap: wrap;
                gap: var(--spacing-sm);
            }

            header h1 {
                font-size: 20px;
            }

            .tab-nav {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
            }

            .tab-nav::-webkit-scrollbar {
                display: none;
            }

            .tab-button {
                min-width: 80px;
                padding: 10px 12px;
                font-size: 13px;
                white-space: nowrap;
            }

            .shot-details {
                grid-template-columns: 1fr;
            }

            .results-stats,
            .inventory-stats {
                grid-template-columns: 1fr;
            }

            .results-stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .result-card {
                padding: 12px;
            }

            .result-value {
                font-size: 20px;
            }

            .period-btn {
                font-size: 12px;
                padding: 6px 12px;
            }

            .section-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .modal-content {
                margin: var(--spacing-sm);
                max-width: calc(100% - 32px);
                padding: var(--spacing-lg);
            }

            .btn-primary,
            .btn-secondary {
                padding: 12px 16px;
                font-size: 14px;
                min-height: 44px; /* Touch-friendly */
            }

            input,
            select,
            textarea {
                min-height: 44px; /* Touch-friendly */
                font-size: 16px; /* Prevent iOS zoom */
            }

            .notification-container {
                right: 10px;
                left: 10px;
                max-width: calc(100% - 20px);
            }

            .notification {
                min-width: unset;
                width: 100%;
            }

            .chart-container canvas {
                max-height: 400px !important;
                min-height: 350px !important;
            }

            .chart-container,
            .supply-forecast-container {
                padding: var(--spacing-md) 8px;
                margin-left: -4px;
                margin-right: -4px;
            }

            .stat-label {
                font-size: 12px;
            }

            .card,
            .vial-card,
            .result-card {
                padding: var(--spacing-md);
            }
        }

        /* Tablets and small laptops (481px - 768px) */
        @media (min-width: 481px) and (max-width: 768px) {
            .container {
                padding: var(--spacing-lg) var(--spacing-md);
                max-width: 95%;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .shot-details {
                grid-template-columns: repeat(2, 1fr);
            }

            .results-stats,
            .inventory-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-content {
                max-width: 90%;
            }

            .tab-button {
                min-width: 90px;
            }
        }

        /* Medium devices (769px - 1024px) */
        @media (min-width: 769px) and (max-width: 1024px) {
            .container {
                max-width: 90%;
            }

            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .tab-button {
                min-width: 100px;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .btn-primary,
            .btn-secondary,
            .tab-button,
            button {
                min-height: 44px;
                min-width: 44px;
            }

            .modal-close {
                min-width: 44px;
                min-height: 44px;
                font-size: 24px;
            }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .modal-content {
                max-height: 90vh;
                overflow-y: auto;
            }

            header {
                padding: var(--spacing-sm) 0;
            }
        }

        /* Print styles */
        @media print {
            header,
            .tab-nav,
            .modal,
            .notification-container,
            #undo-button {
                display: none !important;
            }

            .tab-content {
                display: block !important;
            }
        }

        /* Loading Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 2s infinite;
        }

        /* Notification System */
        #notification-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .notification {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 16px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: slideInRight 0.3s ease-out;
            min-width: 300px;
        }

        .notification.success {
            border-left: 4px solid var(--success-color);
        }

        .notification.error {
            border-left: 4px solid var(--danger-color);
        }

        .notification.warning {
            border-left: 4px solid var(--warning-color);
        }

        .notification.info {
            border-left: 4px solid var(--accent-color);
        }

        .notification.saving {
            border-left: 4px solid var(--accent-color);
        }

        .notification-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .notification-content {
            flex: 1;
        }

        .notification-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        .notification-message {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .notification-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-close:hover {
            color: var(--text-primary);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification.hiding {
            animation: slideOutRight 0.3s ease-in forwards;
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Undo Button */
        #undo-button {
            position: fixed;
            bottom: 100px;
            right: 20px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 9999;
            display: none;
        }

        #undo-button:hover {
            background-color: #0066CC;
        }

        #undo-button.show {
            display: block;
            animation: slideInUp 0.3s ease-out;
        }

        @keyframes slideInUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Save Indicator Animations */
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translateX(-50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }
        }

        @keyframes fadeOutScale {
            from {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }
            to {
                opacity: 0;
                transform: translateX(-50%) scale(0.8);
            }
        }

        /* Utility Classes */
        .text-center { text-align: center; }
        .text-left { text-align: left; }
        .text-right { text-align: right; }
        .mb-0 { margin-bottom: 0; }
        .mb-sm { margin-bottom: var(--spacing-sm); }
        .mb-md { margin-bottom: var(--spacing-md); }
        .mb-lg { margin-bottom: var(--spacing-lg); }
        .hidden { display: none !important; }
        .flex { display: flex; }
        .flex-column { flex-direction: column; }
        .justify-between { justify-content: space-between; }
        .align-center { align-items: center; }

        /* Empty States */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-xl) var(--spacing-md);
            text-align: center;
            min-height: 300px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: var(--spacing-md);
            opacity: 0.5;
        }

        .empty-state h3 {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
        }

        .empty-state p {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: var(--spacing-lg);
            max-width: 300px;
        }

        /* Floating Action Button (FAB) */
        .fab {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #007AFF, #0051a8);
            color: white;
            border: none;
            font-size: 28px;
            font-weight: 300;
            line-height: 1;
            box-shadow: 0 4px 16px rgba(0, 122, 255, 0.4);
            z-index: 99;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fab:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 122, 255, 0.5);
        }

        .fab:active {
            transform: scale(0.95);
        }

        /* Form Validation */
        .form-group input:invalid:not(:focus):not(:placeholder-shown),
        .form-group select:invalid:not(:focus) {
            border-color: var(--danger-color);
        }

        .form-group input:valid:not(:focus):not(:placeholder-shown):not([type="datetime-local"]):not([type="date"]),
        .form-group select:valid:not(:focus):not([value=""]) {
            border-color: var(--success-color);
        }

        .field-error {
            color: var(--danger-color);
            font-size: 12px;
            margin-top: 4px;
            display: none;
        }

        .form-group.error .field-error {
            display: block;
        }

        /* Pull to Refresh Indicator - Disabled due to UX issues */
        .pull-to-refresh {
            display: none !important;  /* Completely hidden */
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            background: var(--card-bg);
            padding: 12px 24px;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s;
            z-index: 1001;
            align-items: center;
            gap: 8px;
        }

        .pull-to-refresh.active {
            transform: translateX(-50%) translateY(10px);
        }

        .pull-to-refresh-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Time Range Selector - Removed, now using .period-btn styles defined above */

        /* Swipe to Delete */
        .shot-item, .weight-item, .vial-item {
            position: relative;
            transition: transform 0.3s;
        }

        .shot-item.swiping, .weight-item.swiping, .vial-item.swiping {
            transition: none;
        }

        .delete-action {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 80px;
            background: var(--danger-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .shot-item.swiped .delete-action,
        .weight-item.swiped .delete-action,
        .vial-item.swiped .delete-action {
            opacity: 1;
        }

        /* Animated Transitions */
        .tab-content {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Offline Indicator */
        .offline-indicator {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--warning-color);
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            z-index: 10002;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .offline-indicator.show {
            display: block;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100%);
            }
            to {
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Weekly Insights Card */
        .insight-card {
            background: linear-gradient(135deg, var(--card-bg) 0%, #2d2d2d 100%);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .insight-card h3 {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
        }

        .insight-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-color);
        }

        .insight-stat:last-child {
            border-bottom: none;
        }

        .insight-label {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .insight-value {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 700;
        }

        .insight-trend {
            color: var(--success-color);
            font-size: 14px;
            font-weight: 600;
        }

        .insight-trend.negative {
            color: var(--danger-color);
        }

        /* Loading Spinner */
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        /* Countdown Timer Enhancements */
        .countdown-circle {
            cursor: pointer;
            user-select: none;
        }

        .countdown-circle:active {
            transform: scale(0.98);
        }

        .countdown-pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.02);
            }
        }
    </style>
</head>
<body>
    <!-- Authentication Gate -->
    <div id="auth-gate" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%); padding: 20px;">
        <div style="text-align: center; max-width: 400px;">
            <h1 style="font-size: 32px; margin-bottom: 16px; background: linear-gradient(135deg, #007AFF 0%, #0051a8 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                Retatrutide Tracker
            </h1>
            <p style="color: #888888; margin-bottom: 32px; font-size: 16px;">
                Please sign in to access your tracking data
            </p>
            <button id="auth-gate-button" style="background: linear-gradient(135deg, #007AFF 0%, #0051a8 100%); color: white; border: none; padding: 16px 32px; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3); transition: transform 0.2s, box-shadow 0.2s; min-width: 200px;">
                Sign In with Google
            </button>
            <p style="color: #666666; margin-top: 32px; font-size: 12px;">
                This is a private application. No data is shared publicly.
            </p>
        </div>
    </div>

    <!-- Application Content (hidden until authenticated) -->
    <div id="app-content" style="display: none;">
        <!-- Notification Container -->
        <div id="notification-container"></div>

        <!-- Undo Button -->
        <button id="undo-button"> Undo Delete</button>

        <!-- Save Indicator -->
        <div id="save-indicator" style="position: fixed; top: 70px; left: 50%; transform: translateX(-50%); background-color: #34C759; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 600; display: none; z-index: 10001; box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3);">
             Saved
        </div>

        <!-- Offline Indicator -->
        <div id="offline-indicator" class="offline-indicator">
             Offline - Changes saved locally
        </div>

        <!-- Floating Action Button -->
        <button id="fab-button" class="fab" title="Quick Add Shot">+</button>

        <!-- Header -->
        <header id="app-header">
        <div class="header-content">
            <button id="menu-btn" class="menu-btn"></button>
            <div class="date-display" id="current-date"></div>
            <button id="add-shot-btn" class="add-shot-btn">+ Shot</button>
        </div>
    </header>

    <!-- Main Content Area -->
    <main id="main-content">
        <div class="loading" id="loading-screen">
            Loading Injection Tracker...
        </div>

        <!-- Summary Tab -->
        <div id="summary-tab" class="tab-content" style="display: none;">
            <div class="container">
                <!-- Weekly Insights Card -->
                <div id="weekly-insights" class="insight-card" style="display: none;">
                    <h3>This Week's Progress</h3>
                    <div class="insight-stat">
                        <span class="insight-label">Weight Change</span>
                        <span class="insight-value" id="insight-weight-change">--</span>
                        <span class="insight-trend" id="insight-weight-trend">--</span>
                    </div>
                    <div class="insight-stat">
                        <span class="insight-label">Adherence</span>
                        <span class="insight-value" id="insight-adherence">--</span>
                        <span class="insight-trend" id="insight-adherence-trend">--</span>
                    </div>
                    <div class="insight-stat">
                        <span class="insight-label">Avg Dose</span>
                        <span class="insight-value" id="insight-avg-dose">--</span>
                        <span class="insight-trend">--</span>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="total-shots">0</div>
                        <div class="stat-label">Total Shots</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="last-dose">0 mg</div>
                        <div class="stat-label">Last Dose</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="current-level">0%</div>
                        <div class="stat-label">Level at Last Shot</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="next-shot">0 days</div>
                        <div class="stat-label">Next Shot</div>
                    </div>
                </div>

                <div class="countdown-container">
                    <h3>Next Shot Due</h3>
                    <div class="countdown-circle">
                        <div class="countdown-content">
                            <div class="next-shot-day" id="next-shot-day">Saturday</div>
                            <div class="next-shot-date" id="next-shot-date">Jan 1</div>
                            <div class="next-shot-time" id="next-shot-time">8:00 AM</div>
                        </div>
                        <svg class="countdown-progress" width="200" height="200">
                            <circle cx="100" cy="100" r="90" stroke="#333333" stroke-width="8" fill="none"/>
                            <circle id="countdown-circle" cx="100" cy="100" r="90" stroke="#007AFF" stroke-width="8"
                                    fill="none" stroke-linecap="round" transform="rotate(-90 100 100)"
                                    stroke-dasharray="565.48" stroke-dashoffset="0"/>
                        </svg>
                    </div>
                </div>

                <div class="supply-forecast-container">
                    <h3>Supply Forecast</h3>
                    <div class="supply-forecast">
                        <div class="forecast-row">
                            <span class="forecast-label">Total Supply:</span>
                            <span class="forecast-value" id="total-supply">0 mg</span>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Planned Weekly Dose:</span>
                            <div class="forecast-input-group">
                                <input type="number" id="planned-dose" step="0.5" min="0" max="20" value="4.0" class="forecast-input">
                                <span class="forecast-unit">mg</span>
                            </div>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Supply Will Last:</span>
                            <span class="forecast-value" id="supply-duration">0 weeks</span>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Estimated Run Out Date:</span>
                            <span class="forecast-value" id="run-out-date">--</span>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Days Until Reorder:</span>
                            <span class="forecast-value" id="reorder-days">--</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Shots Tab -->
        <div id="shots-tab" class="tab-content" style="display: none;">
            <div class="container">
                <div class="shots-header">
                    <h2>Shot History</h2>
                    <button id="add-shot-modal-btn" class="btn-primary">Add Shot</button>
                </div>
                <div id="shots-list" class="shots-list"></div>
            </div>
        </div>

        <!-- Results Tab -->
        <div id="results-tab" class="tab-content" style="display: none;">
            <div class="container">
                <!-- Results Header -->
                <div class="results-header">
                    <h2>Results</h2>
                    <button class="add-shot-btn-results" onclick="app.showAddInjectionModal()">
                        + Add shot
                    </button>
                </div>

                <!-- Time Period Segmented Control -->
                <div class="time-period-control">
                    <button class="period-btn active" data-months="1">1 month</button>
                    <button class="period-btn" data-months="3">3 months</button>
                    <button class="period-btn" data-months="6">6 months</button>
                    <button class="period-btn" data-months="all">All time</button>
                </div>

                <!-- Shots with Weight Chart -->
                <div class="chart-section">
                    <h3 class="chart-section-title">Shots with Weight</h3>
                    <div class="chart-container" id="shots-weight-chart-view">
                        <canvas id="shots-weight-chart"></canvas>
                    </div>
                </div>

                <!-- Weight Only Chart -->
                <div class="chart-section">
                    <h3 class="chart-section-title">Weight Trend</h3>
                    <div class="chart-container" id="weight-only-chart-view">
                        <canvas id="weight-only-chart"></canvas>
                    </div>
                </div>

                <div id="table-view" class="table-view" style="display: none;">
                    <div id="weight-table"></div>
                </div>

                <!-- Weight Change Section -->
                <div class="weight-change-section">
                    <div class="section-header">
                        <div class="section-title">
                            <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                                <path d="M2 17l10 5 10-5M2 12l10 5 10-5"/>
                            </svg>
                            <h3>Weight Change</h3>
                        </div>
                        <div class="date-range" id="date-range-display">Sep 27, 2025 - Oct 29</div>
                    </div>

                    <!-- Metric Cards Grid (2x3) -->
                    <div class="results-stats-grid">
                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                                </svg>
                                Total change
                            </div>
                            <div class="result-value" id="total-change">-11.3 kg</div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                                    <circle cx="12" cy="7" r="4"/>
                                </svg>
                                Current BMI
                            </div>
                            <div class="result-value" id="current-bmi">--</div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M12 6v6l4 2"/>
                                </svg>
                                Weight
                            </div>
                            <div class="result-value" id="current-weight">94.5 kg</div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <text x="12" y="16" text-anchor="middle" fill="currentColor" font-size="10">%</text>
                                </svg>
                                Percent
                            </div>
                            <div class="result-value" id="percent-change">-11%</div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 2v20M17 12H7M17 7H7M17 17H7"/>
                                </svg>
                                Weekly avg
                            </div>
                            <div class="result-value" id="weekly-avg">-2.5 kg/wk</div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/>
                                </svg>
                                Progress
                            </div>
                            <div class="result-value" id="goal-progress">52%</div>
                        </div>
                    </div>
                </div>

                <!-- Goal Progress Card -->
                <div id="goal-progress-card" style="display: none; margin-top: 24px; background: linear-gradient(135deg, var(--card-bg) 0%, #2d2d2d 100%); border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: var(--spacing-lg);">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Goal Progress</h3>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-sm);">
                        <span style="color: var(--text-secondary); font-size: 14px;">
                            <span id="goal-start-weight">--</span> kg  <span id="goal-target-weight">--</span> kg
                        </span>
                        <span style="color: var(--text-primary); font-weight: 600; font-size: 16px;">
                            <span id="goal-progress-percent">0</span>%
                        </span>
                    </div>
                    <div style="width: 100%; height: 8px; background: var(--border-color); border-radius: 4px; overflow: hidden; margin-bottom: var(--spacing-md);">
                        <div id="goal-progress-bar" style="height: 100%; background: linear-gradient(90deg, var(--accent-color), #34C759); width: 0%; transition: width 0.5s ease;"></div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: var(--spacing-md);">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 4px;">Remaining</div>
                            <div style="color: var(--text-primary); font-weight: 600; font-size: 16px;" id="goal-remaining">-- kg</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 4px;">Weekly Avg</div>
                            <div style="color: var(--text-primary); font-weight: 600; font-size: 16px;" id="goal-weekly-rate">-- kg</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 4px;">Est. Date</div>
                            <div style="color: var(--text-primary); font-weight: 600; font-size: 16px;" id="goal-eta-date">--</div>
                        </div>
                    </div>
                    <p id="goal-message" style="margin-top: var(--spacing-md); padding: var(--spacing-sm); background: rgba(52, 199, 89, 0.1); border-radius: 6px; color: var(--success-color); font-size: 14px; text-align: center;">
                        Keep up the great work!
                    </p>
                </div>

                <h3 style="margin-top: 32px; margin-bottom: 16px;">Weight History</h3>
                <div id="weights-list" class="weights-list"></div>
            </div>
        </div>

        <!-- Inventory Tab -->
        <div id="inventory-tab" class="tab-content" style="display: none;">
            <div class="container">
                <h2>Vial Management</h2>
                <div class="inventory-header">
                    <button id="add-vial-btn" class="btn-primary">Add Vials to Stock</button>
                    <button id="activate-vial-btn" class="btn-secondary">Activate Vial</button>
                </div>
                <div id="vials-list" class="vials-list"></div>
                <div class="inventory-stats">
                    <div class="inventory-card">
                        <div class="inventory-value" id="total-stock">0</div>
                        <div class="inventory-label">Doses in Stock</div>
                    </div>
                    <div class="inventory-card">
                        <div class="inventory-value" id="days-remaining">0</div>
                        <div class="inventory-label">Days Remaining</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Tab -->
        <div id="settings-tab" class="tab-content" style="display: none;">
            <div class="container">
                <h2>Settings</h2>

                <!-- Cloud Sync Section -->
                <div class="settings-section" style="background: linear-gradient(135deg, var(--accent-color) 0%, #0051a8 100%); border-radius: var(--border-radius); padding: var(--spacing-lg); margin-bottom: var(--spacing-lg);">
                    <h3 style="margin-bottom: var(--spacing-sm);"> Cloud Sync</h3>
                    <p id="user-info" style="display: none; margin-bottom: var(--spacing-md); opacity: 0.9;"></p>
                    <button id="auth-button" class="btn-primary" style="width: 100%; background: white; color: var(--accent-color); font-weight: 600;">
                        Sign In with Google
                    </button>
                    <p style="margin-top: var(--spacing-sm); font-size: 0.85em; opacity: 0.8;">
                        Sign in to sync your data across devices and enable automatic backups
                    </p>
                </div>

                <div class="settings-section">
                    <h3>Injection Schedule</h3>
                    <label>
                        Injection Frequency:
                        <div class="setting-input-wrapper">
                            <select id="injection-frequency">
                                <option value="7">Weekly</option>
                                <option value="14">Bi-weekly</option>
                                <option value="21">Every 3 weeks</option>
                                <option value="28">Monthly</option>
                            </select>
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <label>
                        Default Dose (mg):
                        <div class="setting-input-wrapper">
                            <input type="number" id="default-dose" step="0.1" min="0" max="50" value="2.0">
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <label>
                        Injection Day:
                        <div class="setting-input-wrapper">
                            <select id="day-of-dose">
                                <option value="0">Sunday</option>
                                <option value="1">Monday</option>
                                <option value="2">Tuesday</option>
                                <option value="3">Wednesday</option>
                                <option value="4">Thursday</option>
                                <option value="5">Friday</option>
                                <option value="6" selected>Saturday</option>
                            </select>
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <label>
                        Height (cm):
                        <div class="setting-input-wrapper">
                            <input type="number" id="user-height" step="0.1" min="0" max="300" placeholder="Enter height">
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <label>
                        Goal Weight (kg):
                        <div class="setting-input-wrapper">
                            <input type="number" id="goal-weight" step="0.1" min="0" max="300" placeholder="Enter goal weight">
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                </div>
                <div class="settings-section">
                    <h3>Notifications</h3>
                    <div class="notification-toggle">
                        <label>
                            <input type="checkbox" id="notify-injection-due" checked>
                            <span>Injection Due Reminder</span>
                        </label>
                    </div>
                    <div class="notification-toggle">
                        <label>
                            <input type="checkbox" id="notify-vial-expiring" checked>
                            <span>Vial Expiring Soon</span>
                        </label>
                    </div>
                    <div class="notification-toggle">
                        <label>
                            <input type="checkbox" id="notify-low-stock" checked>
                            <span>Low Stock Alert</span>
                        </label>
                    </div>
                    <div class="notification-toggle">
                        <label>
                            <input type="checkbox" id="notify-weekly-summary" checked>
                            <span>Weekly Progress Summary</span>
                        </label>
                    </div>
                    <button type="button" id="test-notification-btn" class="btn-secondary" style="margin-top: 8px;">Test Notification</button>
                </div>
                <div class="settings-section">
                    <h3>Data Management</h3>
                    <button id="export-data-btn" class="btn-secondary">Export Data</button>
                    <button id="import-data-btn" class="btn-secondary">Import Data from File</button>
                </div>
                <div class="settings-section">
                    <h3> Cloud Backup</h3>
                    <div id="cloud-backup-info" style="margin-bottom: 16px; padding: 12px; background-color: var(--secondary-bg); border-radius: var(--border-radius-sm);">
                        <p style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">
                            Store a secure backup of all your data in the cloud (AWS S3).
                        </p>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span>Status:</span>
                            <span id="cloud-backup-status">Not authenticated</span>
                        </div>
                        <div id="cloud-backup-last" style="display: none; justify-content: space-between; margin-bottom: 8px;">
                            <span>Last Cloud Backup:</span>
                            <span id="cloud-backup-timestamp">Never</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-muted);">
                            <span>Next Auto-Backup:</span>
                            <span id="next-backup-date">-</span>
                        </div>
                    </div>
                    <button id="create-cloud-backup-btn" class="btn-primary" style="margin-bottom: 8px;" disabled>
                        Backup to Cloud
                    </button>
                    <p style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">
                         Cloud backups: Auto-backup every Monday at 9 AM. Keeps only 4 most recent backups. Sign in required.
                    </p>
                </div>
            </div>
        </div>
    </main>

    <!-- Bottom Navigation -->
    <nav id="bottom-nav" class="bottom-nav">
        <button class="nav-btn active" data-tab="summary">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <path d="M3 9h18M9 21V9"/>
            </svg>
            <span class="nav-label">Summary</span>
        </button>
        <button class="nav-btn" data-tab="shots">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 2l4 4-4 4M10 8l-2 2 2 2"/>
                <path d="M22 6H10a8 8 0 00-8 8v0a2 2 0 002 2h10"/>
                <circle cx="18" cy="18" r="3"/>
            </svg>
            <span class="nav-label">Shots</span>
        </button>
        <button class="nav-btn" data-tab="results">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 3v18h18"/>
                <path d="M18 17l-5-5-4 4-4-7"/>
            </svg>
            <span class="nav-label">Results</span>
        </button>
        <button class="nav-btn" data-tab="inventory">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 16V8a2 2 0 00-1-1.73l-7-4a2 2 0 00-2 0l-7 4A2 2 0 003 8v8a2 2 0 001 1.73l7 4a2 2 0 002 0l7-4A2 2 0 0021 16z"/>
                <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
                <line x1="12" y1="22.08" x2="12" y2="12"/>
            </svg>
            <span class="nav-label">Inventory</span>
        </button>
        <button class="nav-btn" data-tab="settings">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.25m4.24 4.24l4.24 4.25M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.25"/>
            </svg>
            <span class="nav-label">Settings</span>
        </button>
    </nav>

    <!-- Modals -->
    <div id="modal-overlay" class="modal-overlay" style="display: none;">
        <!-- Add Shot Modal -->
        <div id="add-shot-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Add New Shot</h3>
                <button class="modal-close" data-modal="add-shot-modal">&times;</button>
            </div>
            <form id="add-shot-form">
                <div class="form-group">
                    <label for="shot-date">Date & Time</label>
                    <input type="datetime-local" id="shot-date" required>
                </div>
                <div class="form-group">
                    <label for="shot-dose">Dose (mg)</label>
                    <input type="number" id="shot-dose" step="0.1" min="0" max="50" required>
                </div>
                <div class="form-group">
                    <label for="shot-site">Injection Site</label>
                    <select id="shot-site" required>
                        <option value="">Select injection site</option>
                        <option value="left_thigh">Left Thigh</option>
                        <option value="right_thigh">Right Thigh</option>
                        <option value="left_arm">Left Arm</option>
                        <option value="right_arm">Right Arm</option>
                        <option value="abdomen_left">Abdomen Left</option>
                        <option value="abdomen_right">Abdomen Right</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="shot-vial">Vial</label>
                    <select id="shot-vial" required>
                        <option value="">Select vial</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="shot-weight">Weight (kg) - Optional</label>
                    <input type="number" id="shot-weight" step="0.1" min="0" max="500">
                </div>
                <div class="form-group">
                    <label for="shot-notes">Notes - Optional</label>
                    <textarea id="shot-notes" placeholder="Side effects, timing, etc."></textarea>
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Add Shot</button>
                    <button type="button" class="btn-secondary" data-modal="add-shot-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Add Vial Modal -->
        <div id="add-vial-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Add New Vials to Dry Stock</h3>
                <button class="modal-close" data-modal="add-vial-modal">&times;</button>
            </div>
            <form id="add-vial-form">
                <div class="form-group">
                    <label for="vial-order-date">Order Date</label>
                    <input type="date" id="vial-order-date" required>
                </div>
                <div class="form-group">
                    <label for="vial-supplier">Supplier</label>
                    <input type="text" id="vial-supplier" placeholder="Pharmacy name">
                </div>
                <div class="form-group">
                    <label for="vial-mg">mg per Vial</label>
                    <input type="number" id="vial-mg" step="0.1" min="0" required placeholder="10" value="10">
                </div>
                <div class="form-group">
                    <label for="vial-quantity">Number of Vials</label>
                    <input type="number" id="vial-quantity" min="1" required placeholder="2" value="1">
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Add to Dry Stock</button>
                    <button type="button" class="btn-secondary" data-modal="add-vial-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Activate Vial Modal -->
        <div id="activate-vial-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Activate Vial</h3>
                <button class="modal-close" data-modal="activate-vial-modal">&times;</button>
            </div>
            <form id="activate-vial-form">
                <div class="form-group">
                    <label for="activate-vial-id">Select Vial to Activate</label>
                    <select id="activate-vial-id" required>
                        <option value="">Select a vial to activate...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="activate-bac-water">BAC Water (ml)</label>
                    <input type="number" id="activate-bac-water" step="0.1" min="0" required placeholder="1.0" value="1.0">
                </div>
                <div class="form-group">
                    <label for="activate-reconstitution-date">Reconstitution Date & Time</label>
                    <input type="datetime-local" id="activate-reconstitution-date" required>
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Activate Vial</button>
                    <button type="button" class="btn-secondary" data-modal="activate-vial-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Add Weight Modal -->
        <div id="add-weight-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Add Weight Entry</h3>
                <button class="modal-close" data-modal="add-weight-modal">&times;</button>
            </div>
            <form id="add-weight-form">
                <div class="form-group">
                    <label for="weight-date">Date & Time</label>
                    <input type="datetime-local" id="weight-date" required>
                </div>
                <div class="form-group">
                    <label for="weight-kg">Weight (kg)</label>
                    <input type="number" id="weight-kg" step="0.1" min="0" max="500" required>
                </div>
                <div class="form-group">
                    <label for="weight-body-fat">Body Fat % - Optional</label>
                    <input type="number" id="weight-body-fat" step="0.1" min="0" max="100">
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Add Weight</button>
                    <button type="button" class="btn-secondary" data-modal="add-weight-modal">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // ====================================
        // DATA STRUCTURES & STORAGE SYSTEM
        // ====================================

        class InjectionTracker {
            constructor() {
                this.data = {
                    injections: [],
                    vials: [],
                    weights: [],
                    settings: {
                        injectionFrequency: 7,
                        defaultDose: 2.0,
                        dayOfDose: 6, // Saturday (0=Sunday, 6=Saturday)
                        heightCm: null,
                        goalWeightKg: null,
                        units: 'metric',
                        notifications: {
                            injectionDue: true,
                            vialExpiring: true,
                            lowStock: true,
                            weeklySummary: true
                        },
                        lastSync: null
                    }
                };
                this.charts = {};
                this.timeRange = 30; // Default to 30 days
                this._isSyncing = false;  // Guard against concurrent syncs
                this._lastSyncTime = 0;    // Debounce rapid syncs
                this._pendingDeletions = new Set();  // Track items being deleted to prevent re-sync
                this.init();
            }

            // Initialize the application
            async init() {
                try {
                    await this.loadData();
                    this.setupEventListeners();
                    this.setupUXEnhancements(); // NEW: Setup all UX improvements
                    this.updateUI();
                    this.startCountdownTimer();
                    this.setupInjectionReminders();
                    this.checkVialExpirations();
                    this.checkLowStock();
                    this.scheduleWeeklySummary();
                    this.validateDataIntegrity();
                    this.updateWeeklyInsights(); // NEW: Update insights on load
                } catch (error) {
                    console.error('Error during initialization:', error);
                } finally {
                    // Always hide loading screen, even if there's an error
                    this.hideLoadingScreen();
                }
            }

            // ====================================
            // UX ENHANCEMENTS
            // ====================================

            setupUXEnhancements() {
                this.setupFAB();
                this.setupOfflineIndicator();
                this.setupPullToRefresh();
                this.setupKeyboardShortcuts();
                this.setupTimeRangeSelector();
                this.setupCountdownInteraction();
                this.setupSwipeToDelete();
            }

            // Floating Action Button (context-aware)
            setupFAB() {
                const fab = document.getElementById('fab-button');
                if (fab) {
                    fab.addEventListener('click', () => {
                        this.triggerHaptic();

                        // Get active tab to determine which modal to open
                        const activeTab = document.querySelector('.nav-btn.active');
                        const currentTab = activeTab ? activeTab.dataset.tab : 'summary';

                        // Open appropriate modal based on current tab
                        switch (currentTab) {
                            case 'shots':
                                this.openModal('add-shot-modal');
                                break;
                            case 'results':
                                this.openModal('add-weight-modal');
                                break;
                            case 'inventory':
                                this.openModal('add-vial-modal');
                                break;
                            case 'summary':
                                // On summary, default to adding a shot
                                this.openModal('add-shot-modal');
                                break;
                            case 'settings':
                                // On settings, hide FAB or default to shot
                                this.openModal('add-shot-modal');
                                break;
                            default:
                                this.openModal('add-shot-modal');
                                break;
                        }
                    });
                }
            }

            // Haptic Feedback
            triggerHaptic(type = 'light') {
                if ('vibrate' in navigator) {
                    const patterns = {
                        light: 10,
                        medium: 20,
                        heavy: 30
                    };
                    navigator.vibrate(patterns[type] || 10);
                }
            }

            // Offline/Online Indicators
            setupOfflineIndicator() {
                const indicator = document.getElementById('offline-indicator');

                window.addEventListener('online', () => {
                    if (indicator) indicator.classList.remove('show');
                    this.showNotification('Back online - syncing data...', 'success');
                    this.syncFromCloud();
                });

                window.addEventListener('offline', () => {
                    if (indicator) indicator.classList.add('show');
                    this.showNotification('Offline - changes saved locally', 'warning');
                });
            }

            // Pull to Refresh (DISABLED - element removed from DOM)
            setupPullToRefresh() {
                // Disabled to prevent "Refreshing..." indicator from appearing
                // Pull-to-refresh functionality removed for better UX
                console.log('Pull-to-refresh disabled');
            }

            // Keyboard Shortcuts
            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Ignore if typing in input/textarea
                    if (e.target.matches('input, textarea')) return;

                    // Cmd/Ctrl + N: New shot
                    if ((e.metaKey || e.ctrlKey) && e.key === 'n') {
                        e.preventDefault();
                        this.triggerHaptic();
                        this.openModal('add-shot-modal');
                    }

                    // Cmd/Ctrl + W: New weight
                    if ((e.metaKey || e.ctrlKey) && e.key === 'w') {
                        e.preventDefault();
                        this.triggerHaptic();
                        this.openModal('add-weight-modal');
                    }

                    // Number keys 1-5: Switch tabs
                    if (/[1-5]/.test(e.key)) {
                        e.preventDefault();
                        const tabs = ['summary', 'shots', 'results', 'inventory', 'settings'];
                        this.switchTab(tabs[parseInt(e.key) - 1]);
                    }
                });
            }

            setupTimeRangeSelector() {
                const buttons = document.querySelectorAll('.period-btn');
                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.triggerHaptic('light');
                        buttons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        const months = btn.dataset.months;
                        // Convert months to days for internal time range
                        if (months === 'all') {
                            this.timeRange = 'all';
                        } else {
                            const monthsNum = parseInt(months);
                            this.timeRange = monthsNum * 30; // Approximate days per month
                        }

                        // Update stats with new time range
                        this.updateWeightStats();

                        // Update chart with new time range (always show combined weight + dose labels)
                        this.updateWeightChart('combined');
                    });
                });
            }

            switchChartView(view) {
                const chartView = document.getElementById('chart-view');
                const tableView = document.getElementById('table-view');

                if (view === 'table') {
                    chartView.style.display = 'none';
                    tableView.style.display = 'block';
                    this.renderWeightTable();
                } else {
                    chartView.style.display = 'block';
                    tableView.style.display = 'none';
                    this.updateWeightChart(view);
                }
            }

            renderWeightTable() {
                const tableDiv = document.getElementById('weight-table');
                if (!tableDiv) return;

                const sortedWeights = [...this.data.weights].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                let html = `
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border-color);">
                                <th style="padding: 12px; text-align: left; color: var(--text-secondary);">Date</th>
                                <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Weight (kg)</th>
                                <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Change</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                sortedWeights.forEach((weight, idx) => {
                    const date = new Date(weight.timestamp).toLocaleDateString();
                    const nextWeight = sortedWeights[idx + 1];
                    const change = nextWeight ? (weight.weight_kg - nextWeight.weight_kg).toFixed(1) : '--';
                    const changeColor = change > 0 ? 'var(--danger-color)' : change < 0 ? 'var(--success-color)' : 'var(--text-secondary)';

                    html += `
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 12px; color: var(--text-primary);">${date}</td>
                            <td style="padding: 12px; text-align: right; color: var(--text-primary); font-weight: 600;">${weight.weight_kg.toFixed(1)}</td>
                            <td style="padding: 12px; text-align: right; color: ${changeColor}; font-weight: 600;">${change !== '--' ? (change > 0 ? '+' : '') + change : '--'}</td>
                        </tr>
                    `;
                });

                html += `
                        </tbody>
                    </table>
                `;

                tableDiv.innerHTML = html;
            }

            // Enhanced Countdown Interaction
            setupCountdownInteraction() {
                const countdown = document.querySelector('.countdown-circle');
                if (countdown) {
                    countdown.addEventListener('click', () => {
                        this.triggerHaptic('medium');
                        this.openModal('add-shot-modal');
                    });
                }
            }

            // Swipe to Delete
            setupSwipeToDelete() {
                // Will be applied to dynamically created list items
                this.swipeToDeleteEnabled = true;
            }

            addSwipeToDeleteHandlers(element) {
                if (!this.swipeToDeleteEnabled) return;

                let touchStartX = 0;
                let touchEndX = 0;
                const swipeThreshold = 80;

                element.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    element.classList.add('swiping');
                }, { passive: true });

                element.addEventListener('touchmove', (e) => {
                    touchEndX = e.touches[0].clientX;
                    const swipeDistance = touchStartX - touchEndX;

                    if (swipeDistance > 0 && swipeDistance < 100) {
                        element.style.transform = `translateX(-${swipeDistance}px)`;
                    }
                }, { passive: true });

                element.addEventListener('touchend', () => {
                    element.classList.remove('swiping');
                    const swipeDistance = touchStartX - touchEndX;

                    if (swipeDistance > swipeThreshold) {
                        element.classList.add('swiped');
                        element.style.transform = `translateX(-80px)`;
                        this.triggerHaptic('medium');
                    } else {
                        element.classList.remove('swiped');
                        element.style.transform = '';
                    }

                    touchStartX = 0;
                    touchEndX = 0;
                }, { passive: true });
            }

            // Weekly Insights
            updateWeeklyInsights() {
                const insightsCard = document.getElementById('weekly-insights');
                if (!insightsCard) return;

                const now = new Date();
                const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

                // Get this week's weights
                const weekWeights = this.data.weights.filter(w =>
                    new Date(w.timestamp) >= oneWeekAgo
                ).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                // Get this week's injections
                const weekInjections = this.data.injections.filter(i =>
                    new Date(i.timestamp) >= oneWeekAgo
                );

                if (weekWeights.length < 2 && weekInjections.length === 0) {
                    insightsCard.style.display = 'none';
                    return;
                }

                insightsCard.style.display = 'block';

                // Weight change
                if (weekWeights.length >= 2) {
                    const firstWeight = weekWeights[0].weight_kg;
                    const lastWeight = weekWeights[weekWeights.length - 1].weight_kg;
                    const change = lastWeight - firstWeight;

                    document.getElementById('insight-weight-change').textContent =
                        `${change >= 0 ? '+' : ''}${change.toFixed(1)} kg`;

                    const trendEl = document.getElementById('insight-weight-trend');
                    if (change < 0) {
                        trendEl.textContent = ` ${Math.abs(change).toFixed(1)} kg`;
                        trendEl.classList.remove('negative');
                    } else {
                        trendEl.textContent = ` ${change.toFixed(1)} kg`;
                        trendEl.classList.add('negative');
                    }
                } else {
                    document.getElementById('insight-weight-change').textContent = '--';
                    document.getElementById('insight-weight-trend').textContent = '--';
                }

                // Adherence
                const expectedInjections = Math.floor(7 / this.data.settings.injectionFrequency);
                const adherence = expectedInjections > 0 ?
                    Math.round((weekInjections.length / expectedInjections) * 100) : 0;

                document.getElementById('insight-adherence').textContent =
                    `${adherence}%`;
                document.getElementById('insight-adherence-trend').textContent =
                    adherence >= 100 ? ' On track' : ' Below target';

                // Average dose
                if (weekInjections.length > 0) {
                    const avgDose = weekInjections.reduce((sum, inj) => sum + inj.dose_mg, 0) / weekInjections.length;
                    document.getElementById('insight-avg-dose').textContent =
                        `${avgDose.toFixed(1)} mg`;
                } else {
                    document.getElementById('insight-avg-dose').textContent = '--';
                }
            }

            // ====================================
            // DATA MANAGEMENT
            // ====================================

            async loadData() {
                try {
                    const stored = localStorage.getItem('injection_data');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.data = { ...this.data, ...data };

                        // Fix notification settings if they're in old format (boolean instead of object)
                        if (typeof this.data.settings.notifications === 'boolean') {
                            this.data.settings.notifications = {
                                injectionDue: this.data.settings.notifications,
                                vialExpiring: this.data.settings.notifications,
                                lowStock: this.data.settings.notifications,
                                weeklySummary: this.data.settings.notifications
                            };
                        }
                    } else {
                        // Check if we should load sample data (not in test mode)
                        const urlParams = new URLSearchParams(window.location.search);
                        if (!urlParams.get('test')) {
                            // Load sample data for demo purposes
                            this.loadSampleData();
                        }
                    }
                } catch (error) {
                    console.error('Error loading data:', error);
                    // Load sample data if there's an error (unless in test mode)
                    const urlParams = new URLSearchParams(window.location.search);
                    if (!urlParams.get('test')) {
                        this.loadSampleData();
                    }
                }
            }

            // ====================================
            // DATA MERGE HELPER
            // ====================================

            mergeArrays(localData, cloudData, keyField) {
                // Intelligent merge: prefer local data for items not yet in cloud
                const merged = new Map();

                // First, add all cloud items (source of truth for synced data)
                // BUT exclude items that are pending deletion
                cloudData.forEach(item => {
                    const itemId = item[keyField];
                    if (!this._pendingDeletions.has(itemId)) {
                        merged.set(itemId, item);
                    } else {
                        console.log(`Skipping ${itemId} from cloud sync - pending deletion`);
                    }
                });

                // Then add local items that aren't in cloud yet
                // These are likely pending sync or were just added
                localData.forEach(item => {
                    const itemId = item[keyField];
                    const cloudItem = merged.get(itemId);
                    if (!cloudItem && !this._pendingDeletions.has(itemId)) {
                        // Item exists locally but not in cloud - keep it (pending sync)
                        merged.set(itemId, item);
                    }
                    // If item exists in cloud, cloud version is source of truth
                });

                return Array.from(merged.values()).sort(
                    (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
                );
            }

            async syncFromCloud() {
                // Guard against concurrent syncs
                if (this._isSyncing) {
                    console.log('Sync already in progress, skipping...');
                    return;
                }

                // Debounce rapid syncs (wait at least 2 seconds between syncs)
                const now = Date.now();
                if (now - this._lastSyncTime < 2000) {
                    console.log('Sync called too soon after previous sync, skipping...');
                    return;
                }

                // Check if user is authenticated
                if (!authManager || !authManager.isAuthenticated()) {
                    console.log('User not authenticated, skipping cloud sync');
                    return;
                }

                this._isSyncing = true;
                this._lastSyncTime = now;

                try {
                    console.log('Syncing data from cloud...');

                    // Fetch all data from API
                    const [injectionsAPI, weightsAPI, vialsAPI] = await Promise.all([
                        apiClient.getInjections(),
                        apiClient.getWeights(),
                        apiClient.getVials()
                    ]);

                    console.log(`Fetched from cloud: ${injectionsAPI.length} injections, ${weightsAPI.length} weights, ${vialsAPI.length} vials`);

                    // Map API format (camelCase) to app format (snake_case)
                    const cloudInjections = injectionsAPI.map(inj => ({
                        id: inj.id,
                        timestamp: inj.timestamp,
                        dose_mg: inj.doseMg,
                        injection_site: inj.site,
                        vial_id: inj.vialId,
                        notes: inj.notes || ''
                    }));

                    const cloudWeights = weightsAPI.map(wt => ({
                        id: wt.id,
                        timestamp: wt.timestamp,
                        weight_kg: wt.weightKg,
                        notes: wt.notes || ''
                    }));

                    const cloudVials = vialsAPI.map(vial => ({
                        vial_id: vial.id,
                        order_date: vial.startDate,
                        total_mg: vial.initialVolumeMl * vial.concentrationMgPerMl,
                        bac_water_ml: vial.initialVolumeMl,
                        concentration_mg_per_ml: vial.concentrationMgPerMl,
                        current_volume_ml: vial.currentVolumeMl,
                        used_volume_ml: vial.usedVolumeMl,
                        status: vial.status,
                        supplier: vial.source || '',
                        notes: vial.notes || '',
                        reconstitution_date: vial.startDate
                    }));

                    // MERGE cloud data with local data (prevents losing pending items)
                    this.data.injections = this.mergeArrays(this.data.injections, cloudInjections, 'id');
                    this.data.weights = this.mergeArrays(this.data.weights, cloudWeights, 'id');
                    this.data.vials = this.mergeArrays(this.data.vials, cloudVials, 'vial_id');

                    // Save to localStorage (without showing indicator - this is a sync, not a user save)
                    this.saveData(false);

                    // Update UI
                    this.updateUI();

                    console.log('Cloud sync complete');
                } catch (error) {
                    console.error('Error syncing from cloud:', error);
                    // Don't rethrow - sync failures should be silent
                } finally {
                    this._isSyncing = false;
                }
            }

            loadSampleData() {
                const now = new Date();

                // Add a sample vial
                const sampleVial = {
                    order_date: new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 15 days ago
                    supplier: 'Sample Pharmacy',
                    lot_number: 'LOT123456',
                    total_mg: 15,
                    bac_water_ml: 1.5,
                    reconstitution_date: new Date(now.getTime() - 10 * 24 * 60 * 60 * 1000).toISOString() // 10 days ago
                };

                this.addVial(sampleVial);

                // Add sample weights
                for (let i = 0; i < 8; i++) {
                    const weightDate = new Date(now.getTime() - (i * 3.5 * 24 * 60 * 60 * 1000)); // Every 3.5 days
                    this.addWeight({
                        timestamp: weightDate.toISOString(),
                        weight_kg: 85 - (i * 0.3) + (Math.random() * 0.4 - 0.2), // Gradual weight loss with some variation
                        source: 'manual'
                    });
                }

                // Add sample injections (use full vial to make it realistic)
                const sampleDoses = [2.0, 2.5, 3.0, 3.5, 4.0]; // Total = 15mg (use full vial)
                for (let i = 0; i < sampleDoses.length; i++) {
                    const injectionDate = new Date(now.getTime() - (i * 7 * 24 * 60 * 60 * 1000)); // Weekly
                    const vialId = this.data.vials[0]?.vial_id;
                    if (vialId) {
                        this.data.injections.push({
                            id: this.generateId(),
                            timestamp: injectionDate.toISOString(),
                            dose_mg: sampleDoses[i],
                            injection_site: ['right_abdomen', 'left_abdomen', 'right_thigh', 'left_thigh', 'right_arm'][i % 5],
                            vial_id: vialId,
                            weight_kg: null,
                            weight_source: 'manual',
                            notes: i === 0 ? 'Final injection - vial finished' : i === sampleDoses.length - 1 ? 'First injection - starting treatment' : '',
                            medication_level_at_injection: i > 0 ? sampleDoses[i-1] : 0
                        });
                        this.updateVialUsage(vialId, sampleDoses[i]);
                    }
                }

                this.data.injections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Save the sample data to localStorage
                this.saveData();
            }

            async saveData(showIndicator = true) {
                try {
                    if (window.backupManager) {
                        await backupManager.saveData(this.data);
                    } else {
                        // Fallback to simple localStorage if backup manager not ready
                        localStorage.setItem('injection_data', JSON.stringify(this.data));
                    }
                    if (showIndicator) {
                        this.showSaveIndicator();
                    }
                } catch (error) {
                    console.error('Error saving data:', error);
                }
            }

            showSaveIndicator() {
                const indicator = document.getElementById('save-indicator');
                if (indicator) {
                    indicator.style.display = 'block';
                    indicator.style.animation = 'fadeInScale 0.2s ease-out';

                    clearTimeout(this.saveIndicatorTimeout);
                    this.saveIndicatorTimeout = setTimeout(() => {
                        indicator.style.animation = 'fadeOutScale 0.2s ease-in';
                        setTimeout(() => {
                            indicator.style.display = 'none';
                        }, 200);
                    }, 1500);
                }
            }

            // ====================================
            // INJECTION MANAGEMENT
            // ====================================

            async addInjection(injection) {
                const newInjection = {
                    id: this.generateId(),
                    timestamp: injection.timestamp || new Date().toISOString(),
                    dose_mg: parseFloat(injection.dose_mg),
                    injection_site: injection.injection_site,
                    vial_id: injection.vial_id,
                    weight_kg: injection.weight_kg ? parseFloat(injection.weight_kg) : null,
                    weight_source: injection.weight_source || 'manual',
                    notes: injection.notes || '',
                    medication_level_at_injection: this.calculateCurrentMedicationLevel(injection.timestamp)
                };

                this.data.injections.push(newInjection);
                this.data.injections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                this.updateVialUsage(injection.vial_id, injection.dose_mg);
                this.saveData();
                this.updateUI();
                this.setupInjectionReminders();

                // Check for milestones and celebrate
                this.checkMilestones();

                // Push to cloud if authenticated
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        await apiClient.createInjection({
                            id: newInjection.id,
                            timestamp: newInjection.timestamp,
                            doseMg: newInjection.dose_mg,
                            site: newInjection.injection_site,
                            vialId: newInjection.vial_id,
                            notes: newInjection.notes
                        });
                        console.log('Injection synced to cloud successfully');
                    } catch (error) {
                        console.error('Failed to sync injection to cloud:', error);
                        // Still saved locally, so don't block the user
                    }
                }
            }

            updateVialUsage(vialId, doseMg) {
                const vial = this.data.vials.find(v => v.vial_id === vialId);
                if (vial) {
                    const doseVolumeML = doseMg / vial.concentration_mg_ml;
                    vial.remaining_ml = Math.max(0, vial.remaining_ml - doseVolumeML);
                    vial.doses_used++;

                    // Check if vial has less than next required dose
                    const plannedDose = parseFloat(document.getElementById('planned-dose')?.value || 4.0);
                    const remainingMg = vial.remaining_ml * vial.concentration_mg_ml;

                    if (remainingMg < plannedDose && remainingMg > 0) {
                        // Mark vial as empty if it can't provide the next dose
                        vial.status = 'insufficient';
                        vial.remaining_ml = 0;
                    } else if (vial.remaining_ml <= 0) {
                        vial.status = 'empty';
                    }
                }
            }

            // ====================================
            // VIAL MANAGEMENT
            // ====================================

            async addVial(vial) {
                const concentration = vial.total_mg / vial.bac_water_ml;
                const newVial = {
                    vial_id: this.generateId(),
                    order_date: vial.order_date,
                    supplier: vial.supplier || '',
                    lot_number: vial.lot_number || '',
                    total_mg: parseFloat(vial.total_mg),
                    bac_water_ml: parseFloat(vial.bac_water_ml),
                    concentration_mg_ml: concentration,
                    reconstitution_date: vial.reconstitution_date,
                    expiration_date: this.calculateExpirationDate(vial.reconstitution_date, vial.order_date),
                    remaining_ml: parseFloat(vial.bac_water_ml),
                    doses_used: 0,
                    status: 'active'
                };

                this.data.vials.push(newVial);
                this.data.vials.sort((a, b) => new Date(b.reconstitution_date) - new Date(a.reconstitution_date));
                this.saveData();
                this.updateUI();

                // Push to cloud if authenticated
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        await apiClient.createVial({
                            id: newVial.vial_id,
                            startDate: newVial.order_date,
                            initialVolumeMl: newVial.bac_water_ml,
                            concentrationMgPerMl: newVial.concentration_mg_ml,
                            currentVolumeMl: newVial.remaining_ml,
                            usedVolumeMl: 0,
                            status: newVial.status,
                            source: newVial.supplier || '',
                            notes: ''
                        });
                        console.log('Vial synced to cloud successfully');
                    } catch (error) {
                        console.error('Failed to sync vial to cloud:', error);
                        // Still saved locally, so don't block the user
                    }
                }
            }

            calculateExpirationDate(reconstitutionDate, orderDate) {
                if (reconstitutionDate) {
                    // Reconstituted peptide lasts 30 days in refrigerator
                    const date = new Date(reconstitutionDate);
                    date.setDate(date.getDate() + 30);
                    return date.toISOString();
                } else if (orderDate) {
                    // Lyophilized powder lasts 2 years in freezer
                    const date = new Date(orderDate);
                    date.setFullYear(date.getFullYear() + 2);
                    return date.toISOString();
                }
                // Default to 2 years from now
                const date = new Date();
                date.setFullYear(date.getFullYear() + 2);
                return date.toISOString();
            }

            calculateDaysRemaining(totalDoses) {
                if (totalDoses <= 0) return 0;

                const today = new Date();
                const targetDayOfWeek = this.data.settings.dayOfDose || 6; // Default to Saturday
                const injectionFrequency = this.data.settings.injectionFrequency || 7;

                // Find the next dose day from today
                const daysUntilNextDose = (targetDayOfWeek - today.getDay() + 7) % 7;
                const nextDoseDate = new Date(today);
                nextDoseDate.setDate(today.getDate() + daysUntilNextDose);

                // If the next dose day is today and we haven't taken it yet, use today
                // Otherwise, calculate from the next occurrence
                if (daysUntilNextDose === 0) {
                    // Check if we've already dosed today
                    const todayString = today.toISOString().split('T')[0];
                    const dosedToday = this.data.injections.some(inj =>
                        inj.timestamp.startsWith(todayString)
                    );
                    if (!dosedToday) {
                        // Haven't dosed yet today, so start from today
                        nextDoseDate.setTime(today.getTime());
                    } else {
                        // Already dosed today, next dose is in injectionFrequency days
                        nextDoseDate.setDate(today.getDate() + injectionFrequency);
                    }
                }

                // Calculate when the last dose will be taken
                const totalDaysOfMedication = (totalDoses - 1) * injectionFrequency;
                const lastDoseDate = new Date(nextDoseDate);
                lastDoseDate.setDate(nextDoseDate.getDate() + totalDaysOfMedication);

                // Calculate days from today to last dose
                const daysRemaining = Math.ceil((lastDoseDate - today) / (1000 * 60 * 60 * 24));
                return Math.max(0, daysRemaining);
            }

            getActiveVial() {
                const plannedDose = parseFloat(document.getElementById('planned-dose')?.value || 4.0);
                return this.data.vials.find(v => {
                    const remainingMg = v.remaining_ml * v.concentration_mg_ml;
                    return v.status === 'active' &&
                           remainingMg >= plannedDose && // Must have enough for next dose
                           new Date(v.expiration_date) > new Date();
                });
            }

            // ====================================
            // WEIGHT MANAGEMENT
            // ====================================

            async addWeight(weight) {
                const newWeight = {
                    timestamp: weight.timestamp || new Date().toISOString(),
                    weight_kg: parseFloat(weight.weight_kg),
                    weight_lbs: this.kgToLbs(parseFloat(weight.weight_kg)),
                    source: weight.source || 'manual',
                    bmi: weight.bmi || null,
                    body_fat_percentage: weight.body_fat_percentage || null
                };

                this.data.weights.push(newWeight);
                this.data.weights.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                this.saveData();
                this.updateUI();

                // Check for milestones and celebrate
                this.checkMilestones();

                // Push to cloud if authenticated
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        await apiClient.createWeight({
                            timestamp: newWeight.timestamp,
                            weightKg: newWeight.weight_kg,
                            source: newWeight.source,
                            bmi: newWeight.bmi,
                            bodyFatPercentage: newWeight.body_fat_percentage
                        });
                        console.log('Weight synced to cloud successfully');
                    } catch (error) {
                        console.error('Failed to sync weight to cloud:', error);
                        // Still saved locally, so don't block the user
                    }
                }
            }

            // ====================================
            // MEDICATION LEVEL CALCULATIONS
            // ====================================

            calculateCurrentMedicationLevel(currentTime = new Date().toISOString()) {
                const medicationHalfLife = 165; // 165 hours (about 7 days) - adjust as needed
                const currentTimestamp = new Date(currentTime).getTime();
                let totalLevel = 0;

                this.data.injections.forEach(injection => {
                    const injectionTime = new Date(injection.timestamp).getTime();
                    const hoursElapsed = (currentTimestamp - injectionTime) / (1000 * 60 * 60);

                    if (hoursElapsed >= 0) {
                        const remainingLevel = injection.dose_mg * Math.pow(0.5, hoursElapsed / medicationHalfLife);
                        totalLevel += remainingLevel;
                    }
                });

                return totalLevel;
            }

            // ====================================
            // UTILITY FUNCTIONS
            // ====================================

            generateId() {
                return 'id_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            }

            kgToLbs(kg) {
                return kg * 2.20462;
            }

            lbsToKg(lbs) {
                return lbs / 2.20462;
            }

            formatDate(dateString) {
                return new Date(dateString).toLocaleDateString();
            }

            formatDateTime(dateString) {
                return new Date(dateString).toLocaleString();
            }

            // ====================================
            // UI UPDATE FUNCTIONS
            // ====================================

            updateUI() {
                this.updateSummaryTab();
                this.updateShotsTab();
                this.updateResultsTab();
                this.updateInventoryTab();
                this.updateSettingsTab();
            }

            getMostRecentInjection() {
                if (this.data.injections.length === 0) return null;

                return this.data.injections.reduce((mostRecent, current) => {
                    const currentDate = new Date(current.timestamp);
                    const mostRecentDate = new Date(mostRecent.timestamp);
                    return currentDate > mostRecentDate ? current : mostRecent;
                });
            }

            updateSummaryTab() {
                const totalShots = this.data.injections.length;
                const lastInjection = this.getMostRecentInjection();

                // Calculate remaining vial volume after last shot
                let vialRemainingMl = 0;
                if (lastInjection && lastInjection.vial_id) {
                    const vial = this.data.vials.find(v => v.id === lastInjection.vial_id);
                    if (vial) {
                        // Calculate total used from this vial
                        const injectionsFromVial = this.data.injections
                            .filter(inj => inj.vial_id === vial.id)
                            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                        const totalUsedMg = injectionsFromVial.reduce((sum, inj) => sum + inj.dose_mg, 0);
                        const totalUsedMl = totalUsedMg / vial.concentration_mg_ml;
                        vialRemainingMl = 1.0 - totalUsedMl; // Assuming 1ml bac water per vial
                    }
                }

                const nextShotDays = this.calculateNextShotDays();

                document.getElementById('total-shots').textContent = totalShots;
                document.getElementById('last-dose').textContent = lastInjection ?
                    `${lastInjection.dose_mg} mg` : '0 mg';
                document.getElementById('current-level').textContent = `${vialRemainingMl.toFixed(2)} ml`;
                document.getElementById('next-shot').textContent = `${nextShotDays} days`;

                this.updateCountdown();
                this.updateSupplyForecast();
            }

            updateShotsTab() {
                const shotsList = document.getElementById('shots-list');
                shotsList.innerHTML = '';

                // Sort injections by date (newest first) and display
                const sortedInjections = [...this.data.injections].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                sortedInjections.forEach(injection => {
                    const shotItem = this.createShotListItem(injection);
                    shotsList.appendChild(shotItem);
                });
            }

            updateResultsTab() {
                try {
                    this.updateWeightChart();
                } catch (error) {
                    console.error('Error updating weight chart:', error);
                }
                try {
                    this.updateWeightStats();
                } catch (error) {
                    console.error('Error updating weight stats:', error);
                }
                try {
                    this.updateGoalProgress();
                } catch (error) {
                    console.error('Error updating goal progress:', error);
                }
                try {
                    this.updateWeightsList();
                } catch (error) {
                    console.error('Error updating weights list:', error);
                }
            }

            updateInventoryTab() {
                const vialsList = document.getElementById('vials-list');
                vialsList.innerHTML = '';

                // Sort vials: Active first, Dry stock middle, Finished/Expired last
                const sortedVials = [...this.data.vials].sort((a, b) => {
                    const getStatusPriority = (vial) => {
                        // Check if vial is expired, empty, or expiring (finished status)
                        const now = new Date();
                        const expDate = vial.expiration_date ? new Date(vial.expiration_date) : null;
                        const isExpired = expDate && expDate < now;
                        const isEmpty = vial.remaining_ml <= 0;

                        if (vial.status === 'active' && !isExpired && !isEmpty) return 1; // Active at top
                        if (vial.status === 'dry_stock') return 2; // Dry stock in middle
                        return 3; // Finished/expired/empty at bottom
                    };

                    const priorityA = getStatusPriority(a);
                    const priorityB = getStatusPriority(b);

                    if (priorityA !== priorityB) {
                        return priorityA - priorityB;
                    }

                    // Within same priority group, sort by most recent date
                    if (priorityA === 1) {
                        // Active vials: sort by reconstitution date (newest first)
                        return new Date(b.reconstitution_date || 0) - new Date(a.reconstitution_date || 0);
                    } else if (priorityA === 2) {
                        // Dry stock: sort by order date (newest first)
                        return new Date(b.order_date || 0) - new Date(a.order_date || 0);
                    } else {
                        // Finished: sort by expiration date (oldest first)
                        return new Date(a.expiration_date || 0) - new Date(b.expiration_date || 0);
                    }
                });

                sortedVials.forEach(vial => {
                    const vialItem = this.createVialListItem(vial);
                    vialsList.appendChild(vialItem);
                });

                this.updateInventoryStats();
            }

            updateSettingsTab() {
                // Update injection frequency
                document.getElementById('injection-frequency').value = this.data.settings.injectionFrequency;

                // Update default dose
                if (this.data.settings.defaultDose) {
                    document.getElementById('default-dose').value = this.data.settings.defaultDose;
                }

                // Update day of dose
                if (this.data.settings.dayOfDose !== undefined) {
                    document.getElementById('day-of-dose').value = this.data.settings.dayOfDose;
                }

                // Update user height
                if (this.data.settings.heightCm) {
                    document.getElementById('user-height').value = this.data.settings.heightCm;
                }

                // Update goal weight
                if (this.data.settings.goalWeightKg) {
                    document.getElementById('goal-weight').value = this.data.settings.goalWeightKg;
                }

                // Update granular notification settings
                if (this.data.settings.notifications) {
                    document.getElementById('notify-injection-due').checked = this.data.settings.notifications.injectionDue;
                    document.getElementById('notify-vial-expiring').checked = this.data.settings.notifications.vialExpiring;
                    document.getElementById('notify-low-stock').checked = this.data.settings.notifications.lowStock;
                    document.getElementById('notify-weekly-summary').checked = this.data.settings.notifications.weeklySummary;
                }
            }


            calculateNextShotDays() {
                if (this.data.injections.length === 0) return 0;

                const lastInjection = this.getMostRecentInjection();
                const lastShot = new Date(lastInjection.timestamp);
                const nextShot = new Date(lastShot);
                nextShot.setDate(nextShot.getDate() + this.data.settings.injectionFrequency);

                const now = new Date();
                const diffTime = nextShot - now;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                return Math.max(0, diffDays);
            }

            // ====================================
            // EVENT LISTENERS
            // ====================================

            setupEventListeners() {
                this.setupNavigation();
                this.setupModalHandlers();
                this.setupFormHandlers();
            }

            setupNavigation() {
                const navButtons = document.querySelectorAll('.nav-btn');
                const tabContents = document.querySelectorAll('.tab-content');

                navButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const targetTab = btn.dataset.tab;

                        navButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        tabContents.forEach(tab => {
                            tab.style.display = 'none';
                        });
                        document.getElementById(targetTab + '-tab').style.display = 'block';

                        // Update charts when switching tabs
                        if (targetTab === 'summary') this.updateSupplyForecast();
                        if (targetTab === 'results') this.updateWeightChart();
                    });
                });
            }

            hideLoadingScreen() {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('summary-tab').style.display = 'block';
                document.getElementById('current-date').textContent = new Date().toLocaleDateString();
            }

            // ====================================
            // PLACEHOLDER FUNCTIONS (TO BE IMPLEMENTED)
            // ====================================

            setupModalHandlers() {
                const overlay = document.getElementById('modal-overlay');
                const modals = document.querySelectorAll('.modal');

                // Add Shot Button handlers
                document.getElementById('add-shot-btn').addEventListener('click', () => {
                    this.openModal('add-shot-modal');
                });
                document.getElementById('add-shot-modal-btn').addEventListener('click', () => {
                    this.openModal('add-shot-modal');
                });

                // Add Vial Button handler
                document.getElementById('add-vial-btn').addEventListener('click', () => {
                    this.openModal('add-vial-modal');
                });

                // Activate Vial Button handler
                document.getElementById('activate-vial-btn').addEventListener('click', () => {
                    this.openModal('activate-vial-modal');
                });

                // Note: Add shot button is now in the Results header (no need to dynamically create it)

                // Close modal handlers
                document.querySelectorAll('.modal-close, [data-modal]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (btn.classList.contains('modal-close') || btn.textContent === 'Cancel') {
                            this.closeModal();
                        }
                    });
                });

                // Click outside modal to close
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        this.closeModal();
                    }
                });
            }

            setupFormHandlers() {
                // Add Shot Form
                document.getElementById('add-shot-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddShot();
                });

                // Add Vial Form
                document.getElementById('add-vial-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddVial();
                });

                // Activate Vial Form
                document.getElementById('activate-vial-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleActivateVial();
                });

                // Add Weight Form
                document.getElementById('add-weight-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddWeight();
                });

                // Settings form handlers
                document.getElementById('injection-frequency').addEventListener('change', (e) => {
                    this.data.settings.injectionFrequency = parseInt(e.target.value);
                    this.saveData();
                    this.updateUI();
                    this.setupInjectionReminders(); // Reschedule with new frequency
                    this.showSettingSaveIndicator(e.target);
                });

                // Default dose handler
                document.getElementById('default-dose').addEventListener('change', (e) => {
                    this.data.settings.defaultDose = parseFloat(e.target.value);
                    this.saveData();
                    this.updateUI();
                    this.showSettingSaveIndicator(e.target);
                });

                // Day of dose handler
                document.getElementById('day-of-dose').addEventListener('change', (e) => {
                    this.data.settings.dayOfDose = parseInt(e.target.value);
                    this.saveData();
                    this.updateUI();
                    this.showSettingSaveIndicator(e.target);
                });

                // Height handler
                document.getElementById('user-height').addEventListener('change', (e) => {
                    this.data.settings.heightCm = parseFloat(e.target.value);
                    this.saveData();
                    this.updateBMI();
                    this.showSettingSaveIndicator(e.target);
                });

                // Goal weight handler
                document.getElementById('goal-weight').addEventListener('change', (e) => {
                    this.data.settings.goalWeightKg = parseFloat(e.target.value);
                    this.saveData();
                    this.updateGoalProgress();
                    this.showSettingSaveIndicator(e.target);
                });

                // Individual notification toggles
                document.getElementById('notify-injection-due').addEventListener('change', (e) => {
                    this.data.settings.notifications.injectionDue = e.target.checked;
                    this.saveData();
                    this.setupInjectionReminders();
                    this.showSettingsSavedNotification();
                });

                document.getElementById('notify-vial-expiring').addEventListener('change', (e) => {
                    this.data.settings.notifications.vialExpiring = e.target.checked;
                    this.saveData();
                    this.checkVialExpirations();
                    this.showSettingsSavedNotification();
                });

                document.getElementById('notify-low-stock').addEventListener('change', (e) => {
                    this.data.settings.notifications.lowStock = e.target.checked;
                    this.saveData();
                    this.showSettingsSavedNotification();
                });

                document.getElementById('notify-weekly-summary').addEventListener('change', (e) => {
                    this.data.settings.notifications.weeklySummary = e.target.checked;
                    this.saveData();
                    if (e.target.checked) {
                        this.scheduleWeeklySummary();
                    }
                    this.showSettingsSavedNotification();
                });


                // Export data
                document.getElementById('export-data-btn').addEventListener('click', () => {
                    this.exportData();
                });

                // Planned dose change listener
                const plannedDoseInput = document.getElementById('planned-dose');
                if (plannedDoseInput) {
                    plannedDoseInput.addEventListener('input', () => {
                        this.updateSupplyForecast();
                    });
                }

                // Import data
                document.getElementById('import-data-btn').addEventListener('click', () => {
                    this.importData();
                });

                // Test notification
                document.getElementById('test-notification-btn').addEventListener('click', () => {
                    this.testNotification();
                });

                // Cloud backup
                document.getElementById('create-cloud-backup-btn').addEventListener('click', () => {
                    this.createCloudBackup();
                });
            }

            // ====================================
            // DATA EXPORT/IMPORT
            // ====================================

            exportData() {
                const dataStr = JSON.stringify(this.data, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `injection_data_${new Date().toISOString().split('T')[0]}.json`;
                link.click();

                URL.revokeObjectURL(url);

                // Also generate CSV for injections
                this.exportInjectionsCSV();
            }

            exportInjectionsCSV() {
                if (this.data.injections.length === 0) {
                    alert('No injection data to export');
                    return;
                }

                const headers = ['Date', 'Time', 'Dose (mg)', 'Site', 'Weight (kg)', 'Notes'];
                const rows = this.data.injections.map(inj => {
                    const date = new Date(inj.timestamp);
                    return [
                        date.toLocaleDateString(),
                        date.toLocaleTimeString(),
                        inj.dose_mg,
                        inj.injection_site,
                        inj.weight_kg || '',
                        inj.notes || ''
                    ];
                });

                let csv = headers.join(',') + '\n';
                rows.forEach(row => {
                    csv += row.map(cell => `"${cell}"`).join(',') + '\n';
                });

                const blob = new Blob([csv], {type: 'text/csv'});
                const url = URL.createObjectURL(blob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `injection_log_${new Date().toISOString().split('T')[0]}.csv`;
                link.click();

                URL.revokeObjectURL(url);
            }

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const text = await file.text();
                        const importedData = JSON.parse(text);

                        if (confirm('This will replace all your current data. Are you sure?')) {
                            this.data = importedData;
                            await this.saveData();
                            this.updateUI();
                            this.setupInjectionReminders();
                            const issues = this.validateDataIntegrity();
                            if (issues.length > 0) {
                                alert('Data imported successfully!\n\nNote: Some data integrity issues were found. Check the console for details.');
                            } else {
                                alert('Data imported successfully!');
                            }
                        }
                    } catch (error) {
                        alert('Error importing data: ' + error.message);
                    }
                };

                input.click();
            }

            async importHistoricalData() {
                // Check Firebase auth directly
                const currentUser = firebase.auth().currentUser;
                if (!currentUser) {
                    throw new Error('Please sign in first');
                }

                const token = await currentUser.getIdToken();
                const API_BASE = 'https://5is9pmy9be.execute-api.eu-west-1.amazonaws.com/v1';

                const injections = [
                    { timestamp: '2025-08-06T09:00:00.000Z', doseMg: 0.25, site: 'abdomen', notes: 'Right abdomen. First micro-dose (2.5 units) to start titration.', vialId: null },
                    { timestamp: '2025-08-12T09:00:00.000Z', doseMg: 0.5, site: 'abdomen', notes: 'Right abdomen. Second dose (5 units). No major side effects.', vialId: null },
                    { timestamp: '2025-08-19T09:00:00.000Z', doseMg: 1, site: 'abdomen', notes: 'Right abdomen. First 1.0 mg (10 units). Mild nausea only.', vialId: null },
                    { timestamp: '2025-08-30T10:12:00.000Z', doseMg: 2, site: 'abdomen', notes: 'Right abdomen. First 2.0 mg dose (20 units). Mild appetite suppression.', vialId: null },
                    { timestamp: '2025-09-06T09:00:00.000Z', doseMg: 3, site: 'abdomen', notes: 'Right abdomen. 3.0 mg (30 units). Tolerated well, little nausea.', vialId: null },
                    { timestamp: '2025-09-13T09:00:00.000Z', doseMg: 4, site: 'abdomen', notes: 'Right abdomen. New vial reconstituted (10 mg + 1 mL BAC). First 4.0 mg dose (40 units).', vialId: 'vial-1' },
                    { timestamp: '2025-09-20T09:00:00.000Z', doseMg: 4, site: 'abdomen', notes: 'Right abdomen. Second 4.0 mg dose. Mild suppression noticed.', vialId: 'vial-1' },
                    { timestamp: '2025-09-27T10:51:00.000Z', doseMg: 4.2, site: 'abdomen', notes: 'Right abdomen. Only 42 units left in vial. Finished it. Suppression moderate.', vialId: 'vial-1' }
                ];

                const weights = [
                    { timestamp: '2025-08-06T09:00:00.000Z', weightKg: 95, notes: '' },
                    { timestamp: '2025-08-19T09:00:00.000Z', weightKg: 96, notes: '' },
                    { timestamp: '2025-08-30T10:12:00.000Z', weightKg: 93.6, notes: '' },
                    { timestamp: '2025-09-06T09:00:00.000Z', weightKg: 93, notes: '' },
                    { timestamp: '2025-09-20T09:00:00.000Z', weightKg: 90.9, notes: '' },
                    { timestamp: '2025-09-27T10:51:00.000Z', weightKg: 89.7, notes: '' }
                ];

                const vialData = {
                    startDate: '2025-09-13',
                    initialVolumeMl: 1,
                    concentrationMgPerMl: 10,
                    currentVolumeMl: 0,
                    usedVolumeMl: 1,
                    status: 'finished',
                    source: '',
                    notes: 'Reconstituted 10mg with 1mL BAC water'
                };

                // Import vial first (so injections can reference it)
                const vialRes = await fetch(`${API_BASE}/vials`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(vialData)
                });
                if (!vialRes.ok) {
                    const errorText = await vialRes.text();
                    throw new Error(`Failed to import vial: ${vialRes.status} - ${errorText}`);
                }
                const vialResult = await vialRes.json();
                const vialId = vialResult.data.id;

                // Update injection vialIds with the actual created vial ID
                const updatedInjections = injections.map(inj => ({
                    ...inj,
                    vialId: inj.vialId === 'vial-1' ? vialId : null
                }));

                // Import injections
                for (const inj of updatedInjections) {
                    const res = await fetch(`${API_BASE}/injections`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(inj)
                    });
                    if (!res.ok) {
                        const errorText = await res.text();
                        throw new Error(`Failed to import injection: ${res.status} - ${errorText}`);
                    }
                }

                // Import weights
                for (const wt of weights) {
                    const res = await fetch(`${API_BASE}/weights`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(wt)
                    });
                    if (!res.ok) {
                        const errorText = await res.text();
                        throw new Error(`Failed to import weight: ${res.status} - ${errorText}`);
                    }
                }
            }


            async createCloudBackup() {
                try {
                    // Check if authenticated
                    if (!authManager.isAuthenticated()) {
                        alert('Please sign in to use cloud backup.\n\nGo to Settings  Cloud Sync section.');
                        return;
                    }

                    // Show loading state
                    const button = document.getElementById('create-cloud-backup-btn');
                    const originalText = button.textContent;
                    button.textContent = 'Creating backup...';
                    button.disabled = true;

                    // Call API to create backup
                    const result = await apiClient.createBackup();

                    // Update UI with success
                    const timestamp = new Date(result.timestamp).toLocaleString();
                    const counts = result.counts;

                    alert(
                        ` Cloud Backup Created Successfully!\n\n` +
                        `Timestamp: ${timestamp}\n` +
                        `Injections: ${counts.injections}\n` +
                        `Vials: ${counts.vials}\n` +
                        `Weights: ${counts.weights}\n\n` +
                        `Your data is now safely stored in AWS S3.\n` +
                        `Only the 4 most recent backups are kept.`
                    );

                    // Store last backup info in localStorage
                    localStorage.setItem('lastCloudBackup', JSON.stringify({
                        timestamp: result.timestamp,
                        key: result.key
                    }));

                    // Update cloud backup status
                    this.updateCloudBackupStatus();

                    // Reset button
                    button.textContent = originalText;
                    button.disabled = false;

                } catch (error) {
                    console.error('Failed to create cloud backup:', error);

                    // Reset button
                    const button = document.getElementById('create-cloud-backup-btn');
                    button.textContent = 'Backup to Cloud';
                    button.disabled = false;

                    alert(
                        ' Cloud Backup Failed\n\n' +
                        error.message + '\n\n' +
                        'Please check your internet connection and try again.'
                    );
                }
            }

            updateCloudBackupStatus() {
                const statusEl = document.getElementById('cloud-backup-status');
                const timestampEl = document.getElementById('cloud-backup-timestamp');
                const lastDiv = document.getElementById('cloud-backup-last');
                const nextBackupEl = document.getElementById('next-backup-date');

                if (authManager.isAuthenticated()) {
                    statusEl.textContent = ' Ready';
                    statusEl.style.color = 'var(--success-color)';

                    // Check for last backup
                    const lastBackup = localStorage.getItem('lastCloudBackup');
                    if (lastBackup) {
                        const backup = JSON.parse(lastBackup);
                        timestampEl.textContent = new Date(backup.timestamp).toLocaleString();
                        lastDiv.style.display = 'flex';
                    }

                    // Calculate next scheduled backup (next Monday at 9 AM)
                    const nextMonday = this.getNextMonday();
                    if (nextBackupEl) {
                        nextBackupEl.textContent = nextMonday.toLocaleString('en-US', {
                            weekday: 'long',
                            month: 'short',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                    }
                } else {
                    statusEl.textContent = 'Not authenticated';
                    statusEl.style.color = 'var(--text-muted)';
                    lastDiv.style.display = 'none';
                }
            }

            getNextMonday() {
                const now = new Date();
                const dayOfWeek = now.getDay();
                const daysUntilMonday = dayOfWeek === 0 ? 1 : (8 - dayOfWeek);

                const nextMonday = new Date(now);
                nextMonday.setDate(now.getDate() + daysUntilMonday);
                nextMonday.setHours(9, 0, 0, 0);

                return nextMonday;
            }

            async checkAutoBackup() {
                // Only run if authenticated
                if (!authManager.isAuthenticated()) {
                    return;
                }

                const lastBackup = localStorage.getItem('lastCloudBackup');
                const now = new Date();

                // Check if it's Monday and between 9 AM and 10 AM
                const dayOfWeek = now.getDay();
                const hour = now.getHours();

                if (dayOfWeek !== 1 || hour !== 9) {
                    // Not Monday morning, skip
                    return;
                }

                // If we have a last backup, check if it was within the last 7 days
                if (lastBackup) {
                    const backup = JSON.parse(lastBackup);
                    const lastBackupDate = new Date(backup.timestamp);
                    const daysSinceLastBackup = (now - lastBackupDate) / (1000 * 60 * 60 * 24);

                    if (daysSinceLastBackup < 7) {
                        console.log('Auto-backup skipped: Recent backup exists');
                        return;
                    }
                }

                // Check if we already did an auto-backup today
                const lastAutoBackup = localStorage.getItem('lastAutoBackupDate');
                if (lastAutoBackup) {
                    const lastAutoDate = new Date(lastAutoBackup);
                    if (lastAutoDate.toDateString() === now.toDateString()) {
                        console.log('Auto-backup already done today');
                        return;
                    }
                }

                console.log('Performing automatic weekly backup...');

                // Create backup silently
                try {
                    const result = await apiClient.createBackup();

                    // Store last backup info
                    localStorage.setItem('lastCloudBackup', JSON.stringify({
                        timestamp: result.timestamp,
                        key: result.key
                    }));

                    // Mark that we did an auto-backup today
                    localStorage.setItem('lastAutoBackupDate', now.toISOString());

                    // Update UI
                    this.updateCloudBackupStatus();

                    console.log('Auto-backup completed successfully');
                } catch (error) {
                    console.error('Auto-backup failed:', error);
                }
            }

            openModal(modalId) {
                const overlay = document.getElementById('modal-overlay');
                const modal = document.getElementById(modalId);

                // Trigger haptic feedback
                this.triggerHaptic('light');

                // Set current date/time for date inputs with smart defaults
                const now = new Date();
                const localDateTime = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);

                if (modalId === 'add-shot-modal') {
                    // Smart default: Use last injection time + frequency
                    const lastInjection = this.data.injections[0];
                    if (lastInjection) {
                        const lastDate = new Date(lastInjection.timestamp);
                        const nextDate = new Date(lastDate.getTime() + this.data.settings.injectionFrequency * 24 * 60 * 60 * 1000);

                        // If next date is in the past or more than a week in future, use current time
                        if (nextDate <= now && nextDate >= new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)) {
                            const nextDateTime = new Date(nextDate.getTime() - nextDate.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                            document.getElementById('shot-date').value = nextDateTime;

                            // Pre-fill last dose if available
                            const lastDose = document.getElementById('shot-dose');
                            if (lastDose && lastInjection.dose_mg) {
                                lastDose.value = lastInjection.dose_mg;
                            }
                        } else {
                            document.getElementById('shot-date').value = localDateTime;
                        }
                    } else {
                        document.getElementById('shot-date').value = localDateTime;
                    }

                    this.populateVialSelect();
                } else if (modalId === 'add-vial-modal') {
                    document.getElementById('vial-order-date').value = now.toISOString().split('T')[0];
                } else if (modalId === 'activate-vial-modal') {
                    document.getElementById('activate-reconstitution-date').value = localDateTime;
                    this.populateActivateVialDropdown();
                } else if (modalId === 'add-weight-modal') {
                    document.getElementById('weight-date').value = localDateTime;
                }

                overlay.style.display = 'flex';
                modal.style.display = 'block';
                document.body.style.overflow = 'hidden';
            }

            populateActivateVialDropdown() {
                const select = document.getElementById('activate-vial-id');
                select.innerHTML = '<option value="">Select a vial to activate...</option>';

                const dryStockVials = this.data.vials.filter(v => v.status === 'dry_stock');
                dryStockVials.forEach(vial => {
                    const option = document.createElement('option');
                    option.value = vial.vial_id;
                    option.textContent = `${vial.total_mg}mg from ${vial.supplier || 'Unknown'} (${new Date(vial.order_date).toLocaleDateString()})`;
                    select.appendChild(option);
                });
            }

            closeModal() {
                const overlay = document.getElementById('modal-overlay');
                const modals = document.querySelectorAll('.modal');

                overlay.style.display = 'none';
                modals.forEach(modal => modal.style.display = 'none');
                document.body.style.overflow = '';

                // Reset forms
                document.querySelectorAll('form').forEach(form => form.reset());
            }

            populateVialSelect() {
                const select = document.getElementById('shot-vial');
                select.innerHTML = '<option value="">Select vial</option>';

                const activeVials = this.data.vials.filter(v =>
                    v.status === 'active' &&
                    v.remaining_ml > 0 &&
                    new Date(v.expiration_date) > new Date()
                );

                activeVials.forEach(vial => {
                    const option = document.createElement('option');
                    option.value = vial.vial_id;
                    option.textContent = `${vial.total_mg}mg (${vial.concentration_mg_ml.toFixed(1)} mg/ml) - ${vial.remaining_ml.toFixed(1)}ml left`;
                    select.appendChild(option);
                });

                if (activeVials.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No active vials available';
                    option.disabled = true;
                    select.appendChild(option);
                }
            }

            async handleAddShot() {
                const form = document.getElementById('add-shot-form');
                const formData = new FormData(form);

                const injection = {
                    timestamp: document.getElementById('shot-date').value,
                    dose_mg: parseFloat(document.getElementById('shot-dose').value),
                    injection_site: document.getElementById('shot-site').value,
                    vial_id: document.getElementById('shot-vial').value,
                    weight_kg: document.getElementById('shot-weight').value ?
                        parseFloat(document.getElementById('shot-weight').value) : null,
                    notes: document.getElementById('shot-notes').value
                };

                // Add weight entry if provided
                if (injection.weight_kg) {
                    await this.addWeight({
                        timestamp: injection.timestamp,
                        weight_kg: injection.weight_kg,
                        source: 'manual'
                    });
                }

                await this.addInjection(injection);

                // Delay modal close to show save indicator
                setTimeout(() => {
                    this.closeModal();
                }, 300);
            }

            async handleAddVial() {
                const orderDate = document.getElementById('vial-order-date').value;
                const supplier = document.getElementById('vial-supplier').value;
                const totalMg = parseFloat(document.getElementById('vial-mg').value);
                const quantity = parseInt(document.getElementById('vial-quantity').value) || 1;

                if (!orderDate || !totalMg || !quantity) {
                    alert('Please fill in all required fields');
                    return;
                }

                // Add multiple vials to dry stock
                const newVials = [];
                for (let i = 0; i < quantity; i++) {
                    const vial = {
                        vial_id: this.generateId(),
                        order_date: orderDate,
                        supplier: supplier || '',
                        total_mg: totalMg,
                        bac_water_ml: null,
                        concentration_mg_ml: null,
                        reconstitution_date: null,
                        expiration_date: this.calculateExpirationDate(null, orderDate),
                        remaining_ml: 0,
                        doses_used: 0,
                        status: 'dry_stock'
                    };

                    this.data.vials.push(vial);
                    newVials.push(vial);
                }

                this.data.vials.sort((a, b) => new Date(b.order_date) - new Date(a.order_date));
                this.saveData();
                this.updateUI();

                // Sync all new vials to cloud
                if (authManager && authManager.isAuthenticated()) {
                    for (const vial of newVials) {
                        try {
                            await apiClient.createVial({
                                id: vial.vial_id,
                                startDate: vial.order_date,
                                initialVolumeMl: 0,  // Dry stock has no volume yet
                                concentrationMgPerMl: 0,  // No concentration until reconstituted
                                currentVolumeMl: 0,
                                usedVolumeMl: 0,
                                status: vial.status,
                                source: vial.supplier || '',
                                notes: `${totalMg}mg dry stock`
                            });
                            console.log(`Vial ${vial.vial_id} synced to cloud`);
                        } catch (error) {
                            console.error(`Failed to sync vial ${vial.vial_id} to cloud:`, error);
                        }
                    }
                }

                // Delay modal close to show save indicator
                setTimeout(() => {
                    this.closeModal();
                }, 300);
            }

            async handleActivateVial() {
                const vialId = document.getElementById('activate-vial-id').value;
                const bacWaterMl = parseFloat(document.getElementById('activate-bac-water').value);
                const reconstitutionDate = document.getElementById('activate-reconstitution-date').value;

                if (!vialId || !bacWaterMl || !reconstitutionDate) {
                    alert('Please fill in all required fields');
                    return;
                }

                const vial = this.data.vials.find(v => v.vial_id === vialId);
                if (!vial || vial.status !== 'dry_stock') {
                    alert('Invalid vial selected');
                    return;
                }

                // Calculate concentration and expiration
                const concentrationMgMl = vial.total_mg / bacWaterMl;
                const expirationDate = this.calculateExpirationDate(reconstitutionDate, null);

                // Update vial to active status
                vial.bac_water_ml = bacWaterMl;
                vial.concentration_mg_ml = concentrationMgMl;
                vial.reconstitution_date = reconstitutionDate;
                vial.expiration_date = expirationDate;
                vial.remaining_ml = bacWaterMl; // Start with full volume
                vial.status = 'active';

                this.saveData();
                this.updateUI();

                // Sync activated vial to cloud (create/update)
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        await apiClient.createVial({
                            id: vial.vial_id,
                            startDate: vial.reconstitution_date,
                            initialVolumeMl: bacWaterMl,
                            concentrationMgPerMl: concentrationMgMl,
                            currentVolumeMl: vial.remaining_ml,
                            usedVolumeMl: 0,
                            status: vial.status,
                            source: vial.supplier || '',
                            notes: `${vial.total_mg}mg reconstituted`
                        });
                        console.log(`Vial ${vial.vial_id} activation synced to cloud`);
                    } catch (error) {
                        console.error(`Failed to sync vial activation to cloud:`, error);
                    }
                }

                // Delay modal close to show save indicator
                setTimeout(() => {
                    this.closeModal();
                }, 300);
            }

            async handleAddWeight() {
                const weight = {
                    timestamp: document.getElementById('weight-date').value,
                    weight_kg: parseFloat(document.getElementById('weight-kg').value),
                    body_fat_percentage: document.getElementById('weight-body-fat').value ?
                        parseFloat(document.getElementById('weight-body-fat').value) : null,
                    source: 'manual'
                };

                await this.addWeight(weight);

                // Delay modal close to show save indicator
                setTimeout(() => {
                    this.closeModal();
                }, 300);
            }

            createShotListItem(injection) {
                const div = document.createElement('div');
                div.className = 'shot-item';
                div.setAttribute('data-item-id', injection.id);
                div.setAttribute('data-timestamp', injection.timestamp);
                div.innerHTML = `
                    <div class="shot-content">
                        <div class="shot-header">
                            <div class="shot-dose">${injection.dose_mg} mg</div>
                            <div class="shot-date">${this.formatDate(injection.timestamp)}</div>
                        </div>
                        <div class="shot-details">
                            <div>Site: ${injection.injection_site}</div>
                            <div>Weight: ${injection.weight_kg ? injection.weight_kg + ' kg' : 'N/A'}</div>
                        </div>
                    </div>
                    <button class="delete-btn" aria-label="Delete injection" title="Delete this injection">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                            <path d="M10 11v6M14 11v6"/>
                        </svg>
                    </button>
                    <div class="delete-action">Delete</div>
                `;

                // Add swipe to delete handlers
                this.addSwipeToDeleteHandlers(div);

                return div;
            }

            createVialListItem(vial) {
                const div = document.createElement('div');
                div.className = `vial-item ${vial.status}`;
                div.setAttribute('data-item-id', vial.vial_id);
                div.setAttribute('data-timestamp', vial.order_date);

                if (vial.status === 'dry_stock') {
                    div.innerHTML = `
                        <div class="vial-content">
                            <div class="vial-header">
                                <div class="vial-info">
                                    <div class="vial-title">${vial.total_mg}mg Vial</div>
                                    <div class="vial-subtitle">${vial.supplier || 'Unknown Supplier'}</div>
                                    <div class="vial-subtitle">Ordered: ${this.formatDate(vial.order_date)}</div>
                                </div>
                                <div class="vial-status dry_stock">Dry Stock</div>
                            </div>
                            <div class="vial-details">
                                <div class="vial-detail-row">
                                    <span>Status:</span>
                                    <span>Ready for activation with BAC water</span>
                                </div>
                                <div class="vial-detail-row">
                                    <span>Powder Expires:</span>
                                    <span>${this.formatDate(vial.expiration_date)}</span>
                                </div>
                            </div>
                        </div>
                        <button class="delete-btn" aria-label="Delete vial" title="Delete this vial">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                                <path d="M10 11v6M14 11v6"/>
                            </svg>
                        </button>
                    `;
                    return div;
                }

                // Handle active and other statuses
                const now = new Date();
                const expirationDate = new Date(vial.expiration_date);
                const isExpired = expirationDate < now;
                const daysUntilExpiry = Math.ceil((expirationDate - now) / (1000 * 60 * 60 * 24));

                let status = vial.status;
                let statusText = vial.status === 'active' ? 'Active' : vial.status;

                if (vial.status === 'active') {
                    if (isExpired) {
                        status = 'expired';
                        statusText = 'Expired';
                    } else if (daysUntilExpiry <= 3) {
                        status = 'expiring';
                        statusText = `${daysUntilExpiry}d left`;
                    } else if (vial.remaining_ml <= 0) {
                        status = 'empty';
                        statusText = 'Empty';
                    }
                }

                // Calculate remaining doses based on default dose from settings
                const defaultDose = this.data.settings.defaultDose || 2.0;
                const remainingDoses = vial.concentration_mg_ml ? ((vial.remaining_ml * vial.concentration_mg_ml) / defaultDose).toFixed(1) : 0;

                div.innerHTML = `
                    <div class="vial-content">
                        <div class="vial-header">
                            <div class="vial-info">
                                <div class="vial-title">${vial.total_mg}mg Vial</div>
                                <div class="vial-subtitle">${vial.supplier || 'Unknown Supplier'}</div>
                                <div class="vial-subtitle">Ordered: ${this.formatDate(vial.order_date)}</div>
                            </div>
                            <div class="vial-status ${status}">${statusText}</div>
                        </div>
                        <div class="vial-details">
                            ${vial.concentration_mg_ml ? `
                            <div class="vial-detail-row">
                                <span>Concentration:</span>
                                <span>${vial.concentration_mg_ml.toFixed(1)} mg/ml</span>
                            </div>
                            <div class="vial-detail-row">
                                <span>Remaining:</span>
                                <span>${vial.remaining_ml.toFixed(2)} ml (${remainingDoses} doses)</span>
                            </div>
                            <div class="vial-detail-row">
                                <span>Reconstituted:</span>
                                <span>${this.formatDate(vial.reconstitution_date)}</span>
                            </div>
                            ` : `
                            <div class="vial-detail-row">
                                <span>Status:</span>
                                <span>Ready for activation with BAC water</span>
                            </div>
                            `}
                            <div class="vial-detail-row">
                                <span>Expires:</span>
                                <span>${this.formatDate(vial.expiration_date)}</span>
                            </div>
                            ${vial.concentration_mg_ml ? `
                            <div class="vial-detail-row">
                                <span>Doses Used:</span>
                                <span>${vial.doses_used}</span>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    <button class="delete-btn" aria-label="Delete vial" title="Delete this vial">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                            <path d="M10 11v6M14 11v6"/>
                        </svg>
                    </button>
                `;
                return div;
            }

            updateSupplyForecast() {
                // Calculate total remaining supply based on remaining_ml in each vial
                const now = new Date();

                // Get all active vials that are in stock
                const activeVials = this.data.vials.filter(v => {
                    const isNotExpired = new Date(v.expiration_date) > now;
                    const isNotEmpty = v.status !== 'empty' && v.status !== 'finished';
                    const hasConcentration = v.concentration_mg_ml > 0;
                    return v.status === 'active' && isNotExpired && isNotEmpty && hasConcentration;
                });

                // Get all dry stock vials
                const dryStockVials = this.data.vials.filter(v => {
                    const isNotExpired = new Date(v.expiration_date) > now;
                    return v.status === 'dry_stock' && isNotExpired;
                });

                // Calculate total remaining supply from active vials
                let totalSupplyMg = 0;
                activeVials.forEach(vial => {
                    const remainingMg = vial.remaining_ml * vial.concentration_mg_ml;
                    totalSupplyMg += remainingMg;
                    console.log(`Vial ${vial.vial_id} (active): ${remainingMg.toFixed(1)}mg remaining (${vial.remaining_ml.toFixed(2)}ml @ ${vial.concentration_mg_ml}mg/ml)`);
                });

                // Add dry stock vials (full amount)
                dryStockVials.forEach(vial => {
                    totalSupplyMg += vial.total_mg;
                    console.log(`Vial ${vial.vial_id} (dry_stock): ${vial.total_mg}mg available`);
                });

                console.log(`Total remaining supply: ${totalSupplyMg.toFixed(1)}mg (${activeVials.length} active + ${dryStockVials.length} dry stock)`);

                // Get planned dose from input
                const plannedDoseInput = document.getElementById('planned-dose');
                const plannedWeeklyDose = parseFloat(plannedDoseInput?.value || 4.0);

                // Calculate duration - use ceiling for conservative estimate
                const weeksRemaining = plannedWeeklyDose > 0 ? Math.floor(totalSupplyMg / plannedWeeklyDose) : 0;
                const daysRemaining = Math.floor((totalSupplyMg / plannedWeeklyDose) * 7);

                // Calculate run out date
                const runOutDate = new Date();
                runOutDate.setDate(runOutDate.getDate() + daysRemaining);

                // Calculate reorder date (2 weeks before running out)
                const reorderDays = Math.max(0, daysRemaining - 14);

                // Update display
                document.getElementById('total-supply').textContent = `${totalSupplyMg.toFixed(1)} mg`;
                document.getElementById('supply-duration').textContent = `${weeksRemaining} weeks (${daysRemaining} days)`;
                document.getElementById('run-out-date').textContent = daysRemaining > 0 ? runOutDate.toLocaleDateString() : 'No supply';
                document.getElementById('reorder-days').textContent = reorderDays > 0 ? `${reorderDays} days` : 'Order now!';

                // Update colors based on supply levels
                const supplyDurationElement = document.getElementById('supply-duration');
                const runOutElement = document.getElementById('run-out-date');
                const reorderElement = document.getElementById('reorder-days');

                if (daysRemaining < 7) {
                    supplyDurationElement.style.color = '#FF3B30'; // Red
                    runOutElement.style.color = '#FF3B30';
                    reorderElement.style.color = '#FF3B30';
                } else if (daysRemaining < 21) {
                    supplyDurationElement.style.color = '#FF9500'; // Orange
                    runOutElement.style.color = '#FF9500';
                    reorderElement.style.color = '#FF9500';
                } else {
                    supplyDurationElement.style.color = '#34C759'; // Green
                    runOutElement.style.color = '#34C759';
                    reorderElement.style.color = '#34C759';
                }
            }

            updateMedicationChart() {
                // Keeping old function for compatibility - now calls updateSupplyForecast
                this.updateSupplyForecast();
                return;

                // Check if Chart.js is loaded
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not loaded, skipping chart update');
                    return;
                }

                // Destroy existing chart if it exists
                if (this.charts.medicationChart) {
                    this.charts.medicationChart.destroy();
                }

                if (this.data.injections.length === 0) {
                    // Show empty state
                    ctx.fillStyle = '#888888';
                    ctx.font = '16px -apple-system, BlinkMacSystemFont, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('No injection data yet', canvas.width / 2, canvas.height / 2);
                    return;
                }

                const chartData = this.generateMedicationLevelData();

                this.charts.medicationChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: chartData.labels,
                        datasets: [{
                            label: 'Medication Level',
                            data: chartData.levels,
                            borderColor: '#007AFF',
                            backgroundColor: 'rgba(0, 122, 255, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: '#007AFF',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2,
                            pointRadius: 4
                        }, {
                            label: 'Projected Level',
                            data: chartData.projectedLevels,
                            borderColor: '#007AFF',
                            backgroundColor: 'transparent',
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff',
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(42, 42, 42, 0.9)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#333333',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: 11
                                    }
                                }
                            },
                            y: {
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: 11
                                    },
                                    callback: function(value) {
                                        return value.toFixed(1) + ' mg';
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Medication Level (mg)',
                                    color: '#cccccc'
                                }
                            }
                        }
                    }
                });
            }

            generateMedicationLevelData() {
                const now = new Date();
                const startDate = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000)); // 30 days ago
                const endDate = new Date(now.getTime() + (14 * 24 * 60 * 60 * 1000)); // 14 days in future

                const labels = [];
                const levels = [];
                const projectedLevels = [];

                // Generate data points every 6 hours
                for (let date = new Date(startDate); date <= endDate; date = new Date(date.getTime() + 6 * 60 * 60 * 1000)) {
                    const level = this.calculateCurrentMedicationLevel(date.toISOString());
                    const isProjected = date > now;

                    labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));

                    if (isProjected) {
                        levels.push(null);
                        projectedLevels.push(level);
                    } else {
                        levels.push(level);
                        projectedLevels.push(null);
                    }
                }

                return { labels, levels, projectedLevels };
            }

            updateWeightChart(view = 'combined') {
                // Check if Chart.js is loaded
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not loaded, skipping weight chart update');
                    return;
                }

                // Update both charts
                this.updateShotsWithWeightChart();
                this.updateWeightOnlyChart();
            }

            updateShotsWithWeightChart() {
                const canvas = document.getElementById('shots-weight-chart');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // Destroy existing chart if it exists
                if (this.charts.shotsWeightChart) {
                    this.charts.shotsWeightChart.destroy();
                }

                // Filter data based on selected time range
                const now = new Date();
                let cutoffDate = null;
                if (this.timeRange !== 'all') {
                    cutoffDate = new Date(now.getTime() - this.timeRange * 24 * 60 * 60 * 1000);
                }

                const sortedWeights = [...this.data.weights]
                    .filter(w => this.timeRange === 'all' || new Date(w.timestamp) >= cutoffDate)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                const sortedInjections = [...this.data.injections]
                    .filter(i => this.timeRange === 'all' || new Date(i.timestamp) >= cutoffDate)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                // Filter to only show injections that have a matching weight (within 24 hours)
                const injectionsWithWeights = sortedInjections.filter(injection => {
                    const injDate = new Date(injection.timestamp);
                    return sortedWeights.some(weight => {
                        const weightDate = new Date(weight.timestamp);
                        const timeDiff = Math.abs(weightDate - injDate);
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        return hoursDiff <= 24;
                    });
                });

                // Filter weights to only show those that have a matching injection
                const weightsWithInjections = sortedWeights.filter(weight => {
                    const weightDate = new Date(weight.timestamp);
                    return injectionsWithWeights.some(injection => {
                        const injDate = new Date(injection.timestamp);
                        const timeDiff = Math.abs(weightDate - injDate);
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        return hoursDiff <= 24;
                    });
                });

                if (injectionsWithWeights.length === 0 || weightsWithInjections.length === 0) {
                    // Show empty state
                    const container = canvas.parentElement;
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"></div>
                            <h3>No shots with weight data yet</h3>
                            <p>Add weight entries on the same day as your shots to see them here</p>
                        </div>
                    `;
                    return;
                }

                // Ensure canvas exists for chart
                if (!canvas.parentElement.querySelector('canvas')) {
                    const container = canvas.parentElement;
                    container.innerHTML = '<canvas id="shots-weight-chart"></canvas>';
                }

                // Detect mobile screen for responsive chart configuration
                const isMobile = window.innerWidth <= 480;
                const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;

                // Dynamic font sizing based on screen size
                const fontSize = isMobile ? {
                    legend: 11,
                    tick: 10,
                    title: 11
                } : isTablet ? {
                    legend: 11,
                    tick: 10,
                    title: 12
                } : {
                    legend: 12,
                    tick: 11,
                    title: 12
                };

                // Build datasets - only show weights that have matching injections
                const colorPalette = ['#FF6B6B', '#FF9500', '#34C759', '#5AC8FA', '#007AFF', '#AF52DE'];
                const pointColors = weightsWithInjections.map((w, idx) => colorPalette[idx % colorPalette.length]);

                const datasets = [{
                    label: 'Weight (kg)',
                    data: weightsWithInjections.map(w => ({
                        x: w.timestamp,
                        y: w.weight_kg
                    })),
                    borderColor: '#AF52DE',
                    backgroundColor: 'transparent',
                    fill: false,
                    tension: 0.4,
                    yAxisID: 'y',
                    pointRadius: isMobile ? 6 : 5,
                    pointHoverRadius: isMobile ? 8 : 7,
                    pointHitRadius: isMobile ? 14 : 12,
                    pointBackgroundColor: pointColors,
                    pointBorderColor: pointColors,
                    pointBorderWidth: 2,
                    segment: {
                        borderColor: (ctx) => {
                            if (!ctx.p0DataIndex || ctx.p0DataIndex >= pointColors.length - 1) return colorPalette[0];
                            return pointColors[ctx.p0DataIndex];
                        }
                    }
                }];

                // Custom plugin to draw dose labels - only for injections with matching weights
                const doseLabelsPlugin = {
                    id: 'doseLabels',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const xScale = chart.scales.x;
                        const yScale = chart.scales.y;

                        if (!injectionsWithWeights.length) return;

                        // Calculate data density for adaptive label sizing
                        const chartWidth = xScale.right - xScale.left;
                        const avgSpacing = injectionsWithWeights.length > 1 ? chartWidth / injectionsWithWeights.length : chartWidth;

                        // Since we only show shots with weights (weekly), keep labels large and readable
                        // Use consistent sizing with minimal density-based reduction
                        let fontSize, padding, pillHeight, yOffset;
                        const labelFormat = 'full'; // Always show "mg" suffix

                        if (avgSpacing < 40) {
                            // Dense mode (many data points)
                            fontSize = isMobile ? 11 : 14;
                            padding = isMobile ? 5 : 8;
                            pillHeight = isMobile ? 18 : 22;
                            yOffset = isMobile ? 24 : 30;
                        } else {
                            // Normal mode (comfortable spacing)
                            fontSize = isMobile ? 12 : 15;
                            padding = isMobile ? 6 : 9;
                            pillHeight = isMobile ? 20 : 24;
                            yOffset = isMobile ? 28 : 36;
                        }

                        ctx.save();
                        ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';

                        // Draw a label for each injection that has a matching weight
                        injectionsWithWeights.forEach((injection, index) => {
                            const injDate = new Date(injection.timestamp);
                            const x = xScale.getPixelForValue(injDate);

                            // Find the matching weight to position the label above it
                            const matchingWeight = weightsWithInjections.find(weight => {
                                const weightDate = new Date(weight.timestamp);
                                const timeDiff = Math.abs(weightDate - injDate);
                                const hoursDiff = timeDiff / (1000 * 60 * 60);
                                return hoursDiff <= 24;
                            });

                            // Position above the matching weight point
                            const y = yScale.getPixelForValue(matchingWeight.weight_kg);

                            // Always show full label with "mg" suffix for clarity
                            const label = `${injection.dose_mg}mg`;

                            // No staggering needed since we only show shots with weights (naturally spaced)
                            const staggerOffset = 0;

                            // Draw background pill with colorful gradient
                            const textWidth = ctx.measureText(label).width;
                            const pillWidth = textWidth + padding * 2;
                            const pillX = x - pillWidth / 2;
                            const pillY = y - yOffset - staggerOffset;

                            // Cycle through color palette for variety
                            const color = colorPalette[index % colorPalette.length];
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.roundRect(pillX, pillY, pillWidth, pillHeight, pillHeight / 2);
                            ctx.fill();

                            // Draw text
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillText(label, x, pillY + pillHeight - 3);
                        });

                        ctx.restore();
                    }
                };

                // Pass plugin directly to chart instance instead of global registration
                this.charts.shotsWeightChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    plugins: [doseLabelsPlugin],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                top: 35,
                                left: 10,
                                right: 10,
                                bottom: 5
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff',
                                    font: {
                                        size: fontSize.legend
                                    },
                                    padding: isMobile ? 8 : 12,
                                    boxWidth: isMobile ? 30 : 40
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(42, 42, 42, 0.95)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#333333',
                                borderWidth: 1,
                                padding: isMobile ? 10 : 12,
                                titleFont: {
                                    size: isMobile ? 12 : 13
                                },
                                bodyFont: {
                                    size: isMobile ? 12 : 13
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'day',
                                    displayFormats: {
                                        day: isMobile ? 'M/d' : 'MMM d'
                                    }
                                },
                                // Add padding on both sides for visibility (2 days on each side)
                                min: weightsWithInjections.length > 0 ?
                                    new Date(new Date(weightsWithInjections[0].timestamp).getTime() - 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    undefined,
                                max: weightsWithInjections.length > 0 ?
                                    new Date(new Date(weightsWithInjections[weightsWithInjections.length - 1].timestamp).getTime() + 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    new Date().toISOString(),
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : isTablet ? 8 : 10,
                                    maxRotation: isMobile ? 45 : 0,
                                    minRotation: isMobile ? 45 : 0
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : 8,
                                    callback: function(value) {
                                        return value.toFixed(1);
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Weight (kg)',
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.title
                                    }
                                },
                                beginAtZero: false,
                                grace: '5%'
                            }
                        }
                    }
                });
            }

            updateWeightOnlyChart() {
                const canvas = document.getElementById('weight-only-chart');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // Destroy existing chart if it exists
                if (this.charts.weightOnlyChart) {
                    this.charts.weightOnlyChart.destroy();
                }

                // Filter data based on selected time range
                const now = new Date();
                let cutoffDate = null;
                if (this.timeRange !== 'all') {
                    cutoffDate = new Date(now.getTime() - this.timeRange * 24 * 60 * 60 * 1000);
                }

                const sortedWeights = [...this.data.weights]
                    .filter(w => this.timeRange === 'all' || new Date(w.timestamp) >= cutoffDate)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                if (sortedWeights.length === 0) {
                    // Show empty state
                    const container = canvas.parentElement;
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"></div>
                            <h3>No weight data yet</h3>
                            <p>Start tracking your progress by adding your first weight entry</p>
                            <button class="btn-primary" onclick="app.openModal('add-weight-modal')">Add Weight</button>
                        </div>
                    `;
                    return;
                }

                // Ensure canvas exists for chart
                if (!canvas.parentElement.querySelector('canvas')) {
                    const container = canvas.parentElement;
                    container.innerHTML = '<canvas id="weight-only-chart"></canvas>';
                }

                // Detect mobile screen for responsive chart configuration
                const isMobile = window.innerWidth <= 480;
                const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;

                // Dynamic font sizing based on screen size
                const fontSize = isMobile ? {
                    legend: 11,
                    tick: 10,
                    title: 11
                } : isTablet ? {
                    legend: 11,
                    tick: 10,
                    title: 12
                } : {
                    legend: 12,
                    tick: 11,
                    title: 12
                };

                // Build datasets - show all weights
                const colorPalette = ['#FF6B6B', '#FF9500', '#34C759', '#5AC8FA', '#007AFF', '#AF52DE'];
                const pointColors = sortedWeights.map((w, idx) => colorPalette[idx % colorPalette.length]);

                const datasets = [{
                    label: 'Weight (kg)',
                    data: sortedWeights.map(w => ({
                        x: w.timestamp,
                        y: w.weight_kg
                    })),
                    borderColor: '#AF52DE',
                    backgroundColor: 'transparent',
                    fill: false,
                    tension: 0.4,
                    yAxisID: 'y',
                    pointRadius: isMobile ? 6 : 5,
                    pointHoverRadius: isMobile ? 8 : 7,
                    pointHitRadius: isMobile ? 14 : 12,
                    pointBackgroundColor: pointColors,
                    pointBorderColor: pointColors,
                    pointBorderWidth: 2,
                    segment: {
                        borderColor: (ctx) => {
                            if (!ctx.p0DataIndex || ctx.p0DataIndex >= pointColors.length - 1) return colorPalette[0];
                            return pointColors[ctx.p0DataIndex];
                        }
                    }
                }];

                // Create chart without dose labels plugin
                this.charts.weightOnlyChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                top: 15,
                                left: 10,
                                right: 10,
                                bottom: 5
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff',
                                    font: {
                                        size: fontSize.legend
                                    },
                                    padding: isMobile ? 8 : 12,
                                    boxWidth: isMobile ? 30 : 40
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(42, 42, 42, 0.95)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#333333',
                                borderWidth: 1,
                                padding: isMobile ? 10 : 12,
                                titleFont: {
                                    size: isMobile ? 12 : 13
                                },
                                bodyFont: {
                                    size: isMobile ? 12 : 13
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'day',
                                    displayFormats: {
                                        day: isMobile ? 'M/d' : 'MMM d'
                                    }
                                },
                                // Add padding on both sides for visibility (2 days on each side)
                                min: sortedWeights.length > 0 ?
                                    new Date(new Date(sortedWeights[0].timestamp).getTime() - 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    undefined,
                                max: sortedWeights.length > 0 ?
                                    new Date(new Date(sortedWeights[sortedWeights.length - 1].timestamp).getTime() + 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    new Date().toISOString(),
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : isTablet ? 8 : 10,
                                    maxRotation: isMobile ? 45 : 0,
                                    minRotation: isMobile ? 45 : 0
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : 8,
                                    callback: function(value) {
                                        return value.toFixed(1);
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Weight (kg)',
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.title
                                    }
                                },
                                beginAtZero: false,
                                grace: '5%'
                            }
                        }
                    }
                });
            }

            // Helper function: Convert kg to lb
            kgToLbs(kg) {
                return kg * 2.20462;
            }

            // Helper function: Convert lb to kg
            lbsToKg(lbs) {
                return lbs / 2.20462;
            }

            // Helper function: Get date range for display
            getDateRangeText(weights) {
                if (!weights || weights.length === 0) return '';

                const sorted = [...weights].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const start = new Date(sorted[0].timestamp);
                const end = new Date(sorted[sorted.length - 1].timestamp);

                const formatOptions = { month: 'short', day: 'numeric', year: 'numeric' };
                return `${start.toLocaleDateString('en-US', formatOptions)} - ${end.toLocaleDateString('en-US', formatOptions)}`;
            }

            updateWeightStats() {
                // Get weights for current time range
                const cutoffDate = this.timeRange === 'all' ? new Date(0) :
                    new Date(Date.now() - this.timeRange * 24 * 60 * 60 * 1000);

                const filteredWeights = this.data.weights.filter(w =>
                    this.timeRange === 'all' || new Date(w.timestamp) >= cutoffDate
                );

                // Update date range display
                const dateRangeEl = document.getElementById('date-range-display');
                if (dateRangeEl) {
                    dateRangeEl.textContent = this.getDateRangeText(filteredWeights);
                }

                if (filteredWeights.length < 2) {
                    // Set defaults if not enough data
                    document.getElementById('total-change').textContent = '0 kg';
                    document.getElementById('current-weight').textContent = '0 kg';
                    document.getElementById('current-bmi').textContent = '--';
                    document.getElementById('percent-change').textContent = '0%';
                    document.getElementById('weekly-avg').textContent = '0 kg/wk';
                    document.getElementById('goal-progress').textContent = '--';
                    return;
                }

                const sortedWeights = [...filteredWeights].sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                );

                const firstWeight = sortedWeights[0];
                const lastWeight = sortedWeights[sortedWeights.length - 1];

                // Safety check for undefined weights
                if (!firstWeight || !lastWeight || !lastWeight.weight_kg || !firstWeight.weight_kg) {
                    document.getElementById('total-change').textContent = '0 kg';
                    document.getElementById('current-weight').textContent = '0 kg';
                    document.getElementById('current-bmi').textContent = '--';
                    document.getElementById('percent-change').textContent = '0%';
                    document.getElementById('weekly-avg').textContent = '0 kg/wk';
                    document.getElementById('goal-progress').textContent = '--';
                    return;
                }

                // Calculate metrics in kg
                const weightChangeKg = lastWeight.weight_kg - firstWeight.weight_kg;
                const currentWeightKg = lastWeight.weight_kg;
                const startWeightKg = firstWeight.weight_kg;

                // 1. Total change (in kg)
                const totalChangeText = weightChangeKg >= 0 ?
                    `+${Math.abs(weightChangeKg).toFixed(1)} kg` :
                    `${weightChangeKg.toFixed(1)} kg`;
                document.getElementById('total-change').textContent = totalChangeText;

                // 2. Current weight (in kg)
                document.getElementById('current-weight').textContent = `${currentWeightKg.toFixed(1)} kg`;

                // 3. Current BMI
                this.updateBMI();

                // 4. Percent change
                const percentChange = (weightChangeKg / startWeightKg) * 100;
                const percentText = percentChange >= 0 ?
                    `+${percentChange.toFixed(0)}%` :
                    `${percentChange.toFixed(0)}%`;
                document.getElementById('percent-change').textContent = percentText;

                // 5. Weekly average (kg/wk)
                const daysDiff = (new Date(lastWeight.timestamp) - new Date(firstWeight.timestamp)) / (1000 * 60 * 60 * 24);
                const weeks = daysDiff / 7;
                const weeklyAvgKg = weeks > 0 ? (weightChangeKg / weeks) : 0;
                const weeklyText = weeklyAvgKg >= 0 ?
                    `+${weeklyAvgKg.toFixed(1)} kg/wk` :
                    `${weeklyAvgKg.toFixed(1)} kg/wk`;
                document.getElementById('weekly-avg').textContent = weeklyText;

                // 6. Goal progress (%)
                if (this.data.settings.goalWeight) {
                    const goalWeightKg = this.data.settings.goalWeight;
                    const totalToLose = startWeightKg - goalWeightKg;
                    const lostSoFar = startWeightKg - currentWeightKg;
                    const progress = totalToLose > 0 ? (lostSoFar / totalToLose) * 100 : 0;
                    document.getElementById('goal-progress').textContent = `${Math.max(0, Math.min(100, progress)).toFixed(0)}%`;
                } else {
                    document.getElementById('goal-progress').textContent = '--';
                }

                // Color coding for total change
                const totalChangeEl = document.getElementById('total-change');
                if (weightChangeKg < 0) {
                    totalChangeEl.style.color = '#34C759'; // Green for weight loss
                } else if (weightChangeKg > 0) {
                    totalChangeEl.style.color = '#FF9500'; // Orange for weight gain
                } else {
                    totalChangeEl.style.color = 'var(--text-primary)';
                }

                // Color coding for percent change
                const percentEl = document.getElementById('percent-change');
                if (percentChange < 0) {
                    percentEl.style.color = '#34C759';
                } else if (percentChange > 0) {
                    percentEl.style.color = '#FF9500';
                } else {
                    percentEl.style.color = 'var(--text-primary)';
                }

                // Color coding for weekly average
                const weeklyEl = document.getElementById('weekly-avg');
                if (weeklyAvgKg < 0) {
                    weeklyEl.style.color = '#34C759';
                } else if (weeklyAvgKg > 0) {
                    weeklyEl.style.color = '#FF9500';
                } else {
                    weeklyEl.style.color = 'var(--text-primary)';
                }
            }

            updateBMI() {
                const bmiElement = document.getElementById('current-bmi');

                if (this.data.weights.length === 0 || !this.data.settings.heightCm) {
                    bmiElement.textContent = '--';
                    bmiElement.style.color = 'var(--text-primary)';
                    return;
                }

                const sortedWeights = [...this.data.weights].sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                );
                const lastWeight = sortedWeights[sortedWeights.length - 1];
                const heightM = this.data.settings.heightCm / 100;
                const bmi = lastWeight.weight_kg / (heightM * heightM);

                bmiElement.textContent = bmi.toFixed(1);

                // Color code BMI
                if (bmi < 18.5) {
                    bmiElement.style.color = '#007AFF'; // Blue - underweight
                } else if (bmi < 25) {
                    bmiElement.style.color = '#34C759'; // Green - normal
                } else if (bmi < 30) {
                    bmiElement.style.color = '#FF9500'; // Orange - overweight
                } else {
                    bmiElement.style.color = '#FF3B30'; // Red - obese
                }
            }

            updateGoalProgress() {
                const goalCard = document.getElementById('goal-progress-card');

                // Hide card if no goal weight or insufficient weight data
                if (!this.data.settings.goalWeightKg || this.data.weights.length < 2) {
                    goalCard.style.display = 'none';
                    return;
                }

                const sortedWeights = [...this.data.weights].sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                );

                const startWeight = sortedWeights[0].weight_kg;
                const currentWeight = sortedWeights[sortedWeights.length - 1].weight_kg;
                const goalWeight = this.data.settings.goalWeightKg;

                // Check if goal is already reached
                if (currentWeight <= goalWeight) {
                    goalCard.style.display = 'block';
                    document.getElementById('goal-start-weight').textContent = startWeight.toFixed(1);
                    document.getElementById('goal-target-weight').textContent = goalWeight.toFixed(1);
                    document.getElementById('goal-progress-percent').textContent = '100';
                    document.getElementById('goal-progress-bar').style.width = '100%';
                    document.getElementById('goal-remaining').textContent = '0 kg';
                    document.getElementById('goal-weekly-rate').textContent = '--';
                    document.getElementById('goal-eta-date').textContent = 'Achieved!';
                    document.getElementById('goal-message').textContent = ' Congratulations! You\'ve reached your goal!';
                    document.getElementById('goal-message').style.background = 'rgba(52, 199, 89, 0.2)';
                    return;
                }

                // Calculate progress
                const totalToLose = startWeight - goalWeight;
                const alreadyLost = startWeight - currentWeight;
                const remaining = currentWeight - goalWeight;
                const progressPercent = Math.max(0, Math.min(100, (alreadyLost / totalToLose) * 100));

                // Calculate weekly rate (last 4 weeks)
                const fourWeeksAgo = new Date();
                fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);
                const recentWeights = sortedWeights.filter(w =>
                    new Date(w.timestamp) >= fourWeeksAgo
                );

                let weeklyRate = 0;
                let etaText = '--';

                if (recentWeights.length >= 2) {
                    const oldestRecent = recentWeights[0];
                    const newestRecent = recentWeights[recentWeights.length - 1];
                    const daysDiff = (new Date(newestRecent.timestamp) - new Date(oldestRecent.timestamp)) / (1000 * 60 * 60 * 24);
                    const weightDiff = oldestRecent.weight_kg - newestRecent.weight_kg;

                    if (daysDiff > 0) {
                        weeklyRate = (weightDiff / daysDiff) * 7;

                        // Calculate ETA
                        if (weeklyRate > 0) {
                            const weeksToGoal = remaining / weeklyRate;
                            const etaDate = new Date();
                            etaDate.setDate(etaDate.getDate() + (weeksToGoal * 7));

                            // Format date based on how far away it is
                            if (weeksToGoal < 8) {
                                etaText = `${Math.ceil(weeksToGoal)} weeks`;
                            } else {
                                etaText = etaDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                            }
                        } else {
                            etaText = '--';
                        }
                    }
                }

                // Update UI
                goalCard.style.display = 'block';
                document.getElementById('goal-start-weight').textContent = startWeight.toFixed(1);
                document.getElementById('goal-target-weight').textContent = goalWeight.toFixed(1);
                document.getElementById('goal-progress-percent').textContent = progressPercent.toFixed(0);
                document.getElementById('goal-progress-bar').style.width = progressPercent + '%';
                document.getElementById('goal-remaining').textContent = remaining.toFixed(1) + ' kg';
                document.getElementById('goal-weekly-rate').textContent = weeklyRate > 0 ?
                    '-' + weeklyRate.toFixed(2) + ' kg' : '--';
                document.getElementById('goal-eta-date').textContent = etaText;

                // Update message based on progress
                const messageEl = document.getElementById('goal-message');
                if (progressPercent >= 75) {
                    messageEl.textContent = ' Almost there! You\'re in the home stretch!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.15)';
                } else if (progressPercent >= 50) {
                    messageEl.textContent = ' Great progress! You\'re halfway to your goal!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.1)';
                } else if (progressPercent >= 25) {
                    messageEl.textContent = ' Keep going! You\'re making steady progress!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.1)';
                } else if (weeklyRate > 0) {
                    messageEl.textContent = ' You\'re on track! Stay consistent!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.1)';
                } else {
                    messageEl.textContent = ' Keep tracking to see your progress!';
                    messageEl.style.background = 'rgba(128, 128, 128, 0.1)';
                    messageEl.style.color = 'var(--text-secondary)';
                }
            }

            showSettingSaveIndicator(inputElement) {
                if (!inputElement) return;
                const wrapper = inputElement.closest('.setting-input-wrapper');
                if (!wrapper) return;

                const indicator = wrapper.querySelector('.save-indicator');
                if (!indicator) return;

                // Show checkmark
                indicator.classList.add('show');
                indicator.style.color = '#34C759';

                // Hide after 2 seconds
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            }

            showSettingsSavedNotification() {
                // Debounce: Clear existing timeout
                if (this.settingsSaveTimeout) {
                    clearTimeout(this.settingsSaveTimeout);
                }

                // Set new timeout to show notification after 1 second
                this.settingsSaveTimeout = setTimeout(() => {
                    if (window.deleteManager && window.deleteManager.notificationManager) {
                        window.deleteManager.notificationManager.show('Settings saved successfully', 'success');
                    }
                }, 1000);
            }

            updateWeightsList() {
                const weightsList = document.getElementById('weights-list');
                weightsList.innerHTML = '';

                if (this.data.weights.length === 0) {
                    weightsList.innerHTML = '<p style="text-align: center; color: var(--text-muted); padding: 24px;">No weight entries yet</p>';
                    return;
                }

                // Filter out invalid weights first
                const validWeights = this.data.weights.filter(w => w && w.weight_kg && w.timestamp);

                const sortedWeights = [...validWeights].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                sortedWeights.forEach(weight => {
                    const weightItem = this.createWeightListItem(weight);
                    if (weightItem && weightItem.hasChildNodes()) {
                        weightsList.appendChild(weightItem);
                    }
                });
            }

            createWeightListItem(weight) {
                // Safety check for invalid weight data
                if (!weight || !weight.weight_kg) {
                    console.warn('Invalid weight data:', weight);
                    return document.createElement('div');
                }

                const div = document.createElement('div');
                div.className = 'weight-item';
                div.setAttribute('data-item-id', weight.timestamp);
                div.setAttribute('data-timestamp', weight.timestamp);
                div.innerHTML = `
                    <div class="weight-content">
                        <div class="shot-header">
                            <div class="shot-dose">${weight.weight_kg.toFixed(1)} kg</div>
                            <div class="shot-date">${this.formatDate(weight.timestamp)}</div>
                        </div>
                        ${weight.body_fat_percentage ? `
                        <div class="shot-details">
                            <div>Body Fat: ${weight.body_fat_percentage}%</div>
                        </div>
                        ` : ''}
                    </div>
                    <button class="delete-btn" aria-label="Delete weight entry" title="Delete this weight entry">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                            <path d="M10 11v6M14 11v6"/>
                        </svg>
                    </button>
                `;
                return div;
            }

            updateInventoryStats() {
                const activeVials = this.data.vials.filter(v =>
                    v.status === 'active' &&
                    v.remaining_ml > 0 &&
                    new Date(v.expiration_date) > new Date()
                );

                const dryStockVials = this.data.vials.filter(v =>
                    v.status === 'dry_stock' &&
                    new Date(v.expiration_date) > new Date()
                );

                const expiredVials = this.data.vials.filter(v =>
                    new Date(v.expiration_date) < new Date()
                );

                const defaultDose = this.data.settings.defaultDose || 2.0;
                let totalDoses = 0;
                let totalMgUsed = 0;

                // Count doses from active vials
                activeVials.forEach(vial => {
                    const dosesInVial = (vial.remaining_ml * vial.concentration_mg_ml) / defaultDose;
                    totalDoses += dosesInVial;
                });

                // Count doses from dry stock vials (full vials)
                dryStockVials.forEach(vial => {
                    const dosesInVial = vial.total_mg / defaultDose;
                    totalDoses += dosesInVial;
                });

                this.data.vials.forEach(vial => {
                    totalMgUsed += vial.doses_used * defaultDose;
                });

                // Calculate days remaining based on dose day
                const daysRemaining = this.calculateDaysRemaining(totalDoses);


                // Update basic stats
                document.getElementById('total-stock').textContent = totalDoses.toFixed(1);
                document.getElementById('days-remaining').textContent = daysRemaining;
                // Cost fields removed - no longer tracking costs

                // Update colors based on stock levels
                const stockElement = document.getElementById('total-stock');
                const daysElement = document.getElementById('days-remaining');

                if (totalDoses < 5 || daysRemaining < 14) {
                    stockElement.style.color = '#FF3B30'; // Red for low stock
                    daysElement.style.color = '#FF3B30';
                } else if (totalDoses < 10 || daysRemaining < 30) {
                    stockElement.style.color = '#FF9500'; // Orange for medium stock
                    daysElement.style.color = '#FF9500';
                } else {
                    stockElement.style.color = '#34C759'; // Green for good stock
                    daysElement.style.color = '#34C759';
                }

                // Update analytics
                this.updateInventoryAnalytics(totalDoses, daysRemaining, expiredVials);
            }

            updateInventoryAnalytics(totalDoses, daysRemaining, expiredVials) {
                // Reorder Alert
                let reorderAlert = "Stock levels look good";
                let reorderColor = '#34C759';

                if (totalDoses < 5 || daysRemaining < 14) {
                    reorderAlert = " Critical - Order immediately!";
                    reorderColor = '#FF3B30';
                } else if (totalDoses < 8 || daysRemaining < 21) {
                    reorderAlert = " Low stock - Order soon";
                    reorderColor = '#FF9500';
                } else if (totalDoses < 12 || daysRemaining < 30) {
                    reorderAlert = " Consider ordering";
                    reorderColor = '#FF9500';
                }

                const reorderElement = document.getElementById('reorder-alert');
                reorderElement.textContent = reorderAlert;
                reorderElement.style.color = reorderColor;

                // Usage Rate - calculated from default dose and injection frequency
                const defaultDose = this.data.settings.defaultDose || 2.0;
                const injectionFrequency = this.data.settings.injectionFrequency || 7;
                const dosesPerWeek = 7 / injectionFrequency;
                const mgPerWeek = defaultDose * dosesPerWeek;
                const usageRate = `${mgPerWeek.toFixed(1)} mg/week`;
                document.getElementById('usage-rate').textContent = usageRate;

                // Waste Tracking
                let wasteText = "No expired vials";
                let wasteColor = '#34C759';

                if (expiredVials.length > 0) {
                    const expiredMg = expiredVials.reduce((sum, vial) => {
                        return sum + (vial.remaining_ml * vial.concentration_mg_ml);
                    }, 0);
                    wasteText = `${expiredVials.length} expired (${expiredMg.toFixed(0)}mg lost)`;
                    wasteColor = '#FF3B30';
                }

                const wasteElement = document.getElementById('waste-tracking');
                wasteElement.textContent = wasteText;
                wasteElement.style.color = wasteColor;

                // Next Order Suggestion
                let nextOrderText = "Order in 30+ days";
                let nextOrderColor = '#34C759';

                if (daysRemaining <= 14) {
                    nextOrderText = "Order now!";
                    nextOrderColor = '#FF3B30';
                } else if (daysRemaining <= 30) {
                    nextOrderText = `Order in ${Math.max(0, daysRemaining - 14)} days`;
                    nextOrderColor = '#FF9500';
                } else {
                    const orderInDays = Math.max(daysRemaining - 21, 1);
                    nextOrderText = `Order in ${orderInDays} days`;
                }

                const nextOrderElement = document.getElementById('next-order');
                nextOrderElement.textContent = nextOrderText;
                nextOrderElement.style.color = nextOrderColor;
            }

            // ====================================
            // COUNTDOWN FUNCTIONALITY
            // ====================================

            startCountdownTimer() {
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                }

                this.countdownInterval = setInterval(() => {
                    this.updateCountdown();
                }, 1000);
            }

            updateCountdown() {
                if (this.data.injections.length === 0) {
                    document.getElementById('next-shot-day').textContent = 'No shots recorded';
                    document.getElementById('next-shot-date').textContent = '';
                    document.getElementById('next-shot-time').textContent = '';
                    this.updateCountdownProgress(0);
                    return;
                }

                const now = new Date();
                const lastInjection = this.getMostRecentInjection();
                const lastShot = new Date(lastInjection.timestamp);

                // Calculate next shot based on injection frequency
                const nextShot = new Date(lastShot);
                nextShot.setDate(nextShot.getDate() + this.data.settings.injectionFrequency);

                // Format the date display
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

                const dayName = dayNames[nextShot.getDay()];
                const monthName = monthNames[nextShot.getMonth()];
                const date = nextShot.getDate();

                // Format time
                let hours = nextShot.getHours();
                const minutes = nextShot.getMinutes();
                const ampm = hours >= 12 ? 'PM' : 'AM';
                hours = hours % 12;
                hours = hours ? hours : 12; // 0 should be 12
                const timeString = `${hours}:${minutes.toString().padStart(2, '0')} ${ampm}`;

                document.getElementById('next-shot-day').textContent = dayName;
                document.getElementById('next-shot-date').textContent = `${monthName} ${date}`;
                document.getElementById('next-shot-time').textContent = timeString;

                // Calculate progress and update colors
                const timeDiff = nextShot.getTime() - now.getTime();
                const totalTime = this.data.settings.injectionFrequency * 24 * 60 * 60 * 1000;
                const elapsedTime = now.getTime() - lastShot.getTime();
                const progress = Math.min(100, (elapsedTime / totalTime) * 100);

                this.updateCountdownProgress(progress);

                // Update colors based on timing
                const dayElement = document.getElementById('next-shot-day');
                const dateElement = document.getElementById('next-shot-date');

                if (timeDiff <= 0) {
                    // Shot is overdue
                    dayElement.style.color = '#FF3B30';
                    dateElement.style.color = '#FF3B30';
                    dayElement.textContent = 'OVERDUE';
                    dateElement.textContent = '';
                } else if (timeDiff <= 24 * 60 * 60 * 1000) {
                    // Due within 24 hours
                    dayElement.style.color = '#FF9500';
                    dateElement.style.color = '#FF9500';
                } else {
                    // Normal timing
                    dayElement.style.color = 'var(--accent-color)';
                    dateElement.style.color = 'var(--text-primary)';
                }
            }

            updateCountdownProgress(percentage) {
                const circle = document.getElementById('countdown-circle');
                const circumference = 2 * Math.PI * 90; // radius = 90
                const offset = circumference - (percentage / 100) * circumference;
                circle.style.strokeDashoffset = offset;
            }

            // ====================================
            // GOOGLE DRIVE INTEGRATION
            // ====================================

            async initGoogleDrive() {
                // Google API client ID (you'll need to replace this with your own)
                this.CLIENT_ID = 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com';
                this.API_KEY = 'YOUR_GOOGLE_API_KEY';
                this.DISCOVERY_DOCS = ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'];
                this.SCOPES = 'https://www.googleapis.com/auth/drive.appdata';

                this.loadGoogleAPI();
            }

            loadGoogleAPI() {
                const script = document.createElement('script');
                script.src = 'https://apis.google.com/js/api.js';
                script.onload = () => this.handleGoogleAPILoad();
                document.body.appendChild(script);
            }

            handleGoogleAPILoad() {
                gapi.load('client:auth2', () => {
                    gapi.client.init({
                        apiKey: this.API_KEY,
                        clientId: this.CLIENT_ID,
                        discoveryDocs: this.DISCOVERY_DOCS,
                        scope: this.SCOPES
                    }).then(() => {
                        // Listen for sign-in state changes
                        gapi.auth2.getAuthInstance().isSignedIn.listen((isSignedIn) => {
                            this.handleGoogleSignInStatus(isSignedIn);
                        });

                        // Handle initial sign-in state
                        this.handleGoogleSignInStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
                    });
                });
            }

            handleGoogleSignInStatus(isSignedIn) {
                const connectBtn = document.getElementById('google-drive-btn');
                if (isSignedIn) {
                    connectBtn.textContent = 'Disconnect Google Drive';
                    connectBtn.classList.add('connected');
                    this.data.settings.googleDriveConnected = true;
                    this.syncToGoogleDrive();
                } else {
                    connectBtn.textContent = 'Connect Google Drive';
                    connectBtn.classList.remove('connected');
                    this.data.settings.googleDriveConnected = false;
                }
                this.saveData();
            }

            async syncToGoogleDrive() {
                if (!this.data.settings.googleDriveConnected) {
                    console.log('Google Drive not connected');
                    return;
                }

                try {
                    const boundary = '-------314159265358979323846';
                    const delimiter = "\r\n--" + boundary + "\r\n";
                    const close_delim = "\r\n--" + boundary + "--";

                    const metadata = {
                        'name': 'injection_data.json',
                        'mimeType': 'application/json',
                        'parents': ['appDataFolder']
                    };

                    const multipartRequestBody =
                        delimiter +
                        'Content-Type: application/json\r\n\r\n' +
                        JSON.stringify(metadata) +
                        delimiter +
                        'Content-Type: application/json\r\n\r\n' +
                        JSON.stringify(this.data) +
                        close_delim;

                    // Check if file exists
                    const response = await gapi.client.drive.files.list({
                        'spaces': 'appDataFolder',
                        'fields': 'files(id, name)',
                        'pageSize': 10
                    });

                    const files = response.result.files;
                    let fileId = null;

                    if (files && files.length > 0) {
                        fileId = files[0].id;
                    }

                    if (fileId) {
                        // Update existing file
                        await gapi.client.request({
                            'path': `/upload/drive/v3/files/${fileId}`,
                            'method': 'PATCH',
                            'params': {'uploadType': 'multipart'},
                            'headers': {
                                'Content-Type': 'multipart/related; boundary="' + boundary + '"'
                            },
                            'body': multipartRequestBody
                        });
                        console.log('Data synced to Google Drive');
                    } else {
                        // Create new file
                        await gapi.client.request({
                            'path': '/upload/drive/v3/files',
                            'method': 'POST',
                            'params': {'uploadType': 'multipart'},
                            'headers': {
                                'Content-Type': 'multipart/related; boundary="' + boundary + '"'
                            },
                            'body': multipartRequestBody
                        });
                        console.log('Data uploaded to Google Drive');
                    }

                    this.data.settings.lastSync = new Date().toISOString();
                    this.updateSyncStatus();
                } catch (error) {
                    console.error('Error syncing to Google Drive:', error);
                }
            }

            async loadFromGoogleDrive() {
                if (!this.data.settings.googleDriveConnected) return;

                try {
                    const response = await gapi.client.drive.files.list({
                        'spaces': 'appDataFolder',
                        'fields': 'files(id, name)',
                        'pageSize': 10
                    });

                    const files = response.result.files;
                    if (files && files.length > 0) {
                        const file = await gapi.client.drive.files.get({
                            'fileId': files[0].id,
                            'alt': 'media'
                        });

                        const cloudData = JSON.parse(file.body);

                        // Merge cloud data with local data (prefer newer)
                        if (cloudData.settings && cloudData.settings.lastSync) {
                            const cloudTime = new Date(cloudData.settings.lastSync);
                            const localTime = this.data.settings.lastSync ? new Date(this.data.settings.lastSync) : new Date(0);

                            if (cloudTime > localTime) {
                                this.data = cloudData;
                                await this.saveData();
                                this.updateUI();
                                console.log('Loaded data from Google Drive');
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error loading from Google Drive:', error);
                }
            }

            updateSyncStatus() {
                if (this.data.settings.lastSync) {
                    const lastSync = new Date(this.data.settings.lastSync);
                    const syncStatus = document.createElement('div');
                    syncStatus.className = 'sync-status';
                    syncStatus.textContent = `Last synced: ${lastSync.toLocaleString()}`;

                    const settingsContainer = document.querySelector('#settings-tab .container');
                    const existingStatus = settingsContainer.querySelector('.sync-status');
                    if (existingStatus) {
                        existingStatus.textContent = syncStatus.textContent;
                    } else {
                        settingsContainer.appendChild(syncStatus);
                    }
                }
            }

            // ====================================
            // WITHINGS HEALTH API INTEGRATION
            // ====================================

            connectWithings() {
                // Withings OAuth 2.0 configuration
                // Replace with your actual Withings Client ID from developer.withings.com
                const WITHINGS_CLIENT_ID = 'YOUR_WITHINGS_CLIENT_ID';

                // Check if client ID has been configured
                if (WITHINGS_CLIENT_ID === 'YOUR_WITHINGS_CLIENT_ID') {
                    alert('Withings integration not configured. Please update WITHINGS_CLIENT_ID with your actual client ID from developer.withings.com');
                    return;
                }
                const WITHINGS_REDIRECT_URI = window.location.origin + '/withings-callback';
                const WITHINGS_AUTH_URL = 'https://account.withings.com/oauth2_user/authorize2';

                // Generate state for security
                const state = Math.random().toString(36).substring(2, 15);
                sessionStorage.setItem('withings_state', state);

                // Build authorization URL
                const params = new URLSearchParams({
                    response_type: 'code',
                    client_id: WITHINGS_CLIENT_ID,
                    scope: 'user.metrics',
                    redirect_uri: WITHINGS_REDIRECT_URI,
                    state: state
                });

                const authUrl = `${WITHINGS_AUTH_URL}?${params.toString()}`;

                // For demo purposes, show configuration instructions
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-header">
                        <h3 class="modal-title">Connect Withings Health</h3>
                        <button class="modal-close" onclick="this.parentElement.parentElement.remove(); document.getElementById('modal-overlay').style.display='none';">&times;</button>
                    </div>
                    <div class="modal-content">
                        <p>To enable Withings integration:</p>
                        <ol>
                            <li>Register your app at <a href="https://developer.withings.com" target="_blank">developer.withings.com</a></li>
                            <li>Get your Client ID and Secret</li>
                            <li>Update the WITHINGS_CLIENT_ID in this app</li>
                            <li>Configure OAuth redirect URL</li>
                        </ol>
                        <p>Once configured, this will allow automatic import of:</p>
                        <ul>
                            <li>Weight measurements</li>
                            <li>Body fat percentage</li>
                            <li>BMI calculations</li>
                            <li>Historical data</li>
                        </ul>
                        <button class="btn-primary" onclick="window.open('${authUrl}', '_blank')">Proceed to Withings</button>
                    </div>
                `;

                document.getElementById('modal-overlay').style.display = 'flex';
                document.getElementById('modal-overlay').appendChild(modal);
            }

            async handleWithingsCallback(code) {
                // This would handle the OAuth callback
                // Exchange code for access token
                // Store token securely
                // Fetch user data
                console.log('Withings callback handling for code:', code);

                // For production, implement token exchange and data fetching
                this.data.settings.withingsConnected = true;
                await this.saveData();
                this.fetchWithingsData();
            }

            async fetchWithingsData() {
                if (!this.data.settings.withingsConnected) return;

                try {
                    // In production, this would use the Withings API
                    // For now, simulate the API response structure
                    const mockWithingsData = {
                        body: {
                            measuregrps: [
                                {
                                    date: Math.floor(Date.now() / 1000),
                                    measures: [
                                        {
                                            value: 82500, // 82.5 kg
                                            type: 1, // Weight
                                            unit: -3 // kg
                                        },
                                        {
                                            value: 185, // 18.5%
                                            type: 6, // Fat percentage
                                            unit: -1
                                        }
                                    ]
                                }
                            ]
                        }
                    };

                    // Process Withings data
                    mockWithingsData.body.measuregrps.forEach(group => {
                        const timestamp = new Date(group.date * 1000).toISOString();
                        let weight_kg = null;
                        let body_fat_percentage = null;

                        group.measures.forEach(measure => {
                            if (measure.type === 1) { // Weight
                                weight_kg = measure.value * Math.pow(10, measure.unit);
                            } else if (measure.type === 6) { // Fat percentage
                                body_fat_percentage = measure.value * Math.pow(10, measure.unit);
                            }
                        });

                        if (weight_kg) {
                            // Check if we already have this weight entry
                            const existingEntry = this.data.weights.find(w =>
                                Math.abs(new Date(w.timestamp) - new Date(timestamp)) < 60000 // Within 1 minute
                            );

                            if (!existingEntry) {
                                this.addWeight({
                                    timestamp: timestamp,
                                    weight_kg: weight_kg,
                                    body_fat_percentage: body_fat_percentage,
                                    source: 'withings'
                                });
                            }
                        }
                    });

                    console.log('Withings data fetched and processed');
                } catch (error) {
                    console.error('Error fetching Withings data:', error);
                }
            }

            // ====================================
            // PWA FUNCTIONALITY
            // ====================================

            registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('/sw.js')
                        .then(registration => {
                            console.log('Service Worker registered successfully:', registration.scope);
                        })
                        .catch(error => {
                            console.log('Service Worker registration failed:', error);
                        });
                }
            }

            requestNotificationPermission() {
                if ('Notification' in window && navigator.serviceWorker) {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            console.log('Notification permission granted');
                        }
                    });
                }
            }

            scheduleNotification(title, body, delayInMs) {
                if ('serviceWorker' in navigator && 'PushManager' in window) {
                    setTimeout(() => {
                        navigator.serviceWorker.ready.then(registration => {
                            registration.showNotification(title, {
                                body: body,
                                icon: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="64" height="64"%3E%3Crect width="64" height="64" fill="%231a1a1a"/%3E%3Ctext x="50%25" y="50%25" font-family="sans-serif" font-size="16" fill="white" text-anchor="middle" dominant-baseline="central"%3ESR%3C/text%3E%3C/svg%3E',
                                vibrate: [100, 50, 100],
                                tag: 'injection-reminder',
                                requireInteraction: true,
                                actions: [
                                    {
                                        action: 'open-app',
                                        title: 'Open App',
                                        icon: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="24" height="24"%3E%3Crect width="24" height="24" fill="%23007AFF"/%3E%3C/svg%3E'
                                    },
                                    {
                                        action: 'dismiss',
                                        title: 'Dismiss',
                                        icon: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="24" height="24"%3E%3Crect width="24" height="24" fill="%23888888"/%3E%3C/svg%3E'
                                    }
                                ]
                            });
                        });
                    }, delayInMs);
                }
            }

            setupInjectionReminders() {
                if (!this.data.settings.notifications.injectionDue) return;

                // Clear any existing reminders
                this.clearScheduledReminders();

                if (this.data.injections.length === 0) return;

                const lastInjection = this.getMostRecentInjection();
                const lastShot = new Date(lastInjection.timestamp);
                const nextShot = new Date(lastShot);
                nextShot.setDate(nextShot.getDate() + this.data.settings.injectionFrequency);

                const now = new Date();
                const timeDiff = nextShot.getTime() - now.getTime();

                // Schedule 24-hour reminder
                const reminderTime = timeDiff - (24 * 60 * 60 * 1000); // 24 hours before
                if (reminderTime > 0) {
                    const reminderDate = new Date(now.getTime() + reminderTime);
                    this.scheduleNotification(
                        'Injection Reminder',
                        `Your next injection is due tomorrow (${nextShot.toLocaleDateString()})`,
                        reminderTime
                    );
                    console.log(`24-hour reminder scheduled for: ${reminderDate.toLocaleString()}`);
                }

                // Schedule injection due notification
                if (timeDiff > 0) {
                    this.scheduleNotification(
                        'Injection Due Now!',
                        `Time for your injection (${nextShot.toLocaleDateString()})`,
                        timeDiff
                    );
                    console.log(`Injection due notification scheduled for: ${nextShot.toLocaleString()}`);
                }

                // Schedule overdue reminder (2 hours after due time)
                const overdueTime = timeDiff + (2 * 60 * 60 * 1000); // 2 hours after due
                if (overdueTime > 0) {
                    this.scheduleNotification(
                        'Injection Overdue',
                        'Your injection was due 2 hours ago. Please take your injection.',
                        overdueTime
                    );
                    console.log(`Overdue reminder scheduled for: ${new Date(now.getTime() + overdueTime).toLocaleString()}`);
                }
            }

            checkVialExpirations() {
                if (!this.data.settings.notifications.vialExpiring) return;

                const now = new Date();
                const activeVials = this.data.vials.filter(v => v.status === 'active');

                activeVials.forEach(vial => {
                    const reconDate = new Date(vial.startDate);
                    const expiryDate = new Date(reconDate);
                    expiryDate.setDate(expiryDate.getDate() + 28);
                    const daysUntilExpiry = Math.ceil((expiryDate - now) / (1000 * 60 * 60 * 24));

                    // Notify 3 days before expiration
                    if (daysUntilExpiry === 3) {
                        this.scheduleNotification(
                            'Vial Expiring Soon',
                            `Your active vial will expire in ${daysUntilExpiry} days (${expiryDate.toLocaleDateString()})`,
                            100
                        );
                    }

                    // Notify on expiration day
                    if (daysUntilExpiry === 0) {
                        this.scheduleNotification(
                            'Vial Expired Today',
                            'Your active vial expires today. Please prepare a new vial.',
                            100
                        );
                    }
                });
            }

            checkLowStock() {
                if (!this.data.settings.notifications.lowStock) return;

                const activeVials = this.data.vials.filter(v => v.status === 'active');
                const totalDoses = activeVials.reduce((sum, vial) => {
                    const dosesRemaining = (vial.currentVolumeMl / vial.initialVolumeMl) *
                                         (vial.initialVolumeMl * vial.concentrationMgPerMl / (this.data.settings.defaultDose || 2.0));
                    return sum + dosesRemaining;
                }, 0);

                // Alert if less than 2 doses remaining
                if (totalDoses < 2 && totalDoses > 0) {
                    this.scheduleNotification(
                        'Low Stock Alert',
                        `Only ${Math.floor(totalDoses)} doses remaining. Consider ordering more vials.`,
                        100
                    );
                }
            }

            scheduleWeeklySummary() {
                if (!this.data.settings.notifications.weeklySummary) return;

                // Calculate next Monday at 9 AM
                const now = new Date();
                const dayOfWeek = now.getDay();
                const daysUntilMonday = dayOfWeek === 0 ? 1 : (8 - dayOfWeek);
                const nextMonday = new Date(now);
                nextMonday.setDate(now.getDate() + daysUntilMonday);
                nextMonday.setHours(9, 0, 0, 0);

                const delay = nextMonday - now;

                if (delay > 0) {
                    setTimeout(() => {
                        this.sendWeeklySummary();
                        // Reschedule for next week
                        this.scheduleWeeklySummary();
                    }, delay);
                }
            }

            sendWeeklySummary() {
                const lastWeek = new Date();
                lastWeek.setDate(lastWeek.getDate() - 7);

                const recentInjections = this.data.injections.filter(inj =>
                    new Date(inj.timestamp) > lastWeek
                );

                const recentWeights = this.data.weights.filter(w =>
                    new Date(w.timestamp) > lastWeek
                );

                let summary = `Weekly Summary:\n`;
                summary += `Injections: ${recentInjections.length}\n`;

                if (recentWeights.length > 0) {
                    const sortedWeights = [...recentWeights].sort((a, b) =>
                        new Date(a.timestamp) - new Date(b.timestamp)
                    );
                    const weightChange = sortedWeights[sortedWeights.length - 1].weightKg - sortedWeights[0].weightKg;
                    summary += `Weight change: ${weightChange >= 0 ? '+' : ''}${weightChange.toFixed(1)} kg`;
                }

                this.scheduleNotification(
                    'Weekly Progress Summary',
                    summary,
                    100
                );
            }

            clearScheduledReminders() {
                // Clear all existing timeouts (simplified approach)
                // In a production app, you'd store timeout IDs and clear them specifically
                console.log('Clearing existing reminders...');
            }

            testNotification() {
                if (!('Notification' in window)) {
                    alert('Notifications are not supported in this browser.');
                    return;
                }

                if (Notification.permission === 'denied') {
                    alert('Notifications are blocked. Please enable notifications in your browser settings.');
                    return;
                }

                if (Notification.permission === 'default') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            this.showTestNotification();
                        }
                    });
                } else {
                    this.showTestNotification();
                }
            }

            showTestNotification() {
                // Enhanced notification with actions
                this.showEnhancedNotification({
                    title: 'Test Notification',
                    body: 'Your notification system is working correctly!',
                    icon: '/icon-192.png',
                    badge: '/badge-72.png',
                    actions: [
                        { action: 'open', title: ' Open App' },
                        { action: 'dismiss', title: ' Dismiss' }
                    ]
                });
            }

            // Enhanced notification with actions (Android/Desktop)
            showEnhancedNotification(options) {
                if (!('Notification' in window) || Notification.permission !== 'granted') {
                    return;
                }

                // Basic notification for browsers without action support
                if (!('actions' in Notification.prototype)) {
                    new Notification(options.title, {
                        body: options.body,
                        icon: options.icon,
                        badge: options.badge
                    });
                    return;
                }

                // Enhanced notification with actions
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.ready.then(registration => {
                        registration.showNotification(options.title, {
                            body: options.body,
                            icon: options.icon || '/icon-192.png',
                            badge: options.badge || '/badge-72.png',
                            actions: options.actions || [],
                            vibrate: options.vibrate || [200, 100, 200],
                            tag: options.tag || 'default',
                            requireInteraction: options.requireInteraction || false,
                            data: options.data || {}
                        });
                    });
                } else {
                    // Fallback for browsers without service worker
                    new Notification(options.title, {
                        body: options.body,
                        icon: options.icon,
                        badge: options.badge
                    });
                }
            }

            // Confetti animations
            triggerConfetti(type = 'default') {
                if (typeof confetti === 'undefined') return;

                switch (type) {
                    case 'milestone':
                        // Milestone achievement - big celebration
                        confetti({
                            particleCount: 100,
                            spread: 70,
                            origin: { y: 0.6 },
                            colors: ['#007AFF', '#34C759', '#FF9500']
                        });
                        break;

                    case 'goal':
                        // Weight loss goal - shower from top
                        const duration = 3 * 1000;
                        const animationEnd = Date.now() + duration;
                        const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 10000 };

                        function randomInRange(min, max) {
                            return Math.random() * (max - min) + min;
                        }

                        const interval = setInterval(function() {
                            const timeLeft = animationEnd - Date.now();

                            if (timeLeft <= 0) {
                                return clearInterval(interval);
                            }

                            const particleCount = 50 * (timeLeft / duration);
                            confetti(Object.assign({}, defaults, {
                                particleCount,
                                origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
                            }));
                            confetti(Object.assign({}, defaults, {
                                particleCount,
                                origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
                            }));
                        }, 250);
                        break;

                    case 'ontrack':
                        // Adheren ce milestone - small celebration
                        confetti({
                            particleCount: 50,
                            angle: 60,
                            spread: 55,
                            origin: { x: 0 },
                            colors: ['#34C759', '#00C853']
                        });
                        confetti({
                            particleCount: 50,
                            angle: 120,
                            spread: 55,
                            origin: { x: 1 },
                            colors: ['#34C759', '#00C853']
                        });
                        break;

                    default:
                        // Default celebration
                        confetti({
                            particleCount: 30,
                            spread: 60,
                            origin: { y: 0.7 }
                        });
                }
            }

            // Check for milestones and trigger celebrations
            checkMilestones() {
                const totalInjections = this.data.injections.length;
                const weights = this.data.weights;

                // Injection milestones
                if ([10, 25, 50, 100].includes(totalInjections)) {
                    this.triggerConfetti('milestone');
                    this.showEnhancedNotification({
                        title: ` ${totalInjections} Injections Milestone!`,
                        body: `You've completed ${totalInjections} injections. Great progress!`,
                        tag: 'milestone-' + totalInjections,
                        requireInteraction: true
                    });
                }

                // Weight loss milestones (if we have enough data)
                if (weights.length >= 2) {
                    const sorted = [...weights].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    const firstWeight = sorted[0].weight_kg;
                    const currentWeight = sorted[sorted.length - 1].weight_kg;
                    const loss = firstWeight - currentWeight;

                    // 5kg, 10kg, 15kg, 20kg milestones
                    const milestones = [5, 10, 15, 20, 25, 30];
                    milestones.forEach(target => {
                        if (loss >= target && !localStorage.getItem(`milestone-${target}kg`)) {
                            localStorage.setItem(`milestone-${target}kg`, 'true');
                            this.triggerConfetti('goal');
                            this.showEnhancedNotification({
                                title: ` ${target}kg Weight Loss!`,
                                body: `Amazing progress! You've lost ${loss.toFixed(1)}kg total!`,
                                tag: 'weightloss-' + target,
                                requireInteraction: true,
                                actions: [
                                    { action: 'view', title: ' View Progress' }
                                ]
                            });
                        }
                    });
                }

                // Perfect adherence week
                const now = new Date();
                const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                const weekInjections = this.data.injections.filter(i => new Date(i.timestamp) >= oneWeekAgo);
                const expectedInjections = Math.floor(7 / this.data.settings.injectionFrequency);

                if (weekInjections.length >= expectedInjections && expectedInjections > 0) {
                    const weekKey = `week-${now.getFullYear()}-${now.getMonth()}-${Math.floor(now.getDate() / 7)}`;
                    if (!localStorage.getItem(`adherence-${weekKey}`)) {
                        localStorage.setItem(`adherence-${weekKey}`, 'true');
                        this.triggerConfetti('ontrack');
                    }
                }
            }

            // ====================================
            // DATA INTEGRITY VALIDATION
            // ====================================

            validateDataIntegrity() {
                const issues = [];

                // Check vial integrity
                this.data.vials.forEach(vial => {
                    // Check if vial has been used more than its capacity
                    if (vial.status === 'active' && vial.concentration_mg_ml > 0) {
                        const totalUsedMg = vial.doses_used * (vial.total_mg / (vial.bac_water_ml * vial.concentration_mg_ml));
                        const calculatedRemainingMg = vial.total_mg - totalUsedMg;
                        const reportedRemainingMg = vial.remaining_ml * vial.concentration_mg_ml;

                        if (Math.abs(calculatedRemainingMg - reportedRemainingMg) > 0.1) {
                            issues.push(`Vial ${vial.vial_id}: Calculated remaining (${calculatedRemainingMg.toFixed(1)}mg) doesn't match reported (${reportedRemainingMg.toFixed(1)}mg)`);
                        }
                    }

                    // Check for impossible remaining volumes
                    if (vial.remaining_ml < 0) {
                        issues.push(`Vial ${vial.vial_id}: Negative remaining volume (${vial.remaining_ml}ml)`);
                    }

                    // Check for vials marked as empty but still have volume
                    if (vial.status === 'empty' && vial.remaining_ml > 0) {
                        issues.push(`Vial ${vial.vial_id}: Marked as empty but has ${vial.remaining_ml}ml remaining`);
                    }

                    // Check for expired active vials
                    if (vial.status === 'active' && new Date(vial.expiration_date) < new Date()) {
                        issues.push(`Vial ${vial.vial_id}: Marked as active but expired on ${new Date(vial.expiration_date).toLocaleDateString()}`);
                    }
                });

                // Check injection integrity
                this.data.injections.forEach(injection => {
                    // Only validate vial reference if injection has a vial_id (null is valid)
                    if (injection.vial_id && injection.vial_id !== 'null') {
                        const vial = this.data.vials.find(v => v.vial_id === injection.vial_id);
                        if (!vial) {
                            issues.push(`Injection ${injection.id}: References non-existent vial ${injection.vial_id}`);
                        }
                    }
                });

                if (issues.length > 0) {
                    console.warn('Data integrity issues found:', issues);
                    return issues;
                } else {
                    console.log('Data integrity check passed ');
                    return [];
                }
            }
        }

        // ====================================
        // NOTIFICATION SYSTEM
        // ====================================

        class SimpleNotificationManager {
            constructor() {
                this.container = null;
            }

            initialize() {
                this.container = document.getElementById('notification-container');
            }

            show(type, message) {
                if (!this.container) this.initialize();

                const notification = document.createElement('div');
                notification.className = `notification ${type}`;

                const icons = {
                    'success': '',
                    'error': '',
                    'warning': '',
                    'info': ''
                };

                const titles = {
                    'success': 'Success',
                    'error': 'Error',
                    'warning': 'Warning',
                    'info': 'Info'
                };

                notification.innerHTML = `
                    <div class="notification-icon">${icons[type] || ''}</div>
                    <div class="notification-content">
                        <div class="notification-title">${titles[type] || 'Notification'}</div>
                        <div class="notification-message">${message}</div>
                    </div>
                    <button class="notification-close" aria-label="Close"></button>
                `;

                this.container.appendChild(notification);

                const closeBtn = notification.querySelector('.notification-close');
                closeBtn.onclick = () => this.hide(notification);

                setTimeout(() => this.hide(notification), 3000);
            }

            hide(notification) {
                notification.classList.add('hiding');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }

            success(message) { this.show('success', message); }
            error(message) { this.show('error', message); }
            warning(message) { this.show('warning', message); }
            info(message) { this.show('info', message); }
        }

        // ====================================
        // DELETE MANAGER
        // ====================================

        class SimpleDeleteManager {
            constructor() {
                this.undoStack = [];
                this.maxUndoStack = 20;
                this.notificationManager = new SimpleNotificationManager();
                this.undoButton = null;
            }

            initialize() {
                this.notificationManager.initialize();
                this.undoButton = document.getElementById('undo-button');

                if (this.undoButton) {
                    this.undoButton.onclick = () => this.undoLastDelete();
                }
            }

            enableDeleteForShots() {
                const setupDeleteButtons = () => {
                    const shotItems = document.querySelectorAll('.shot-item');
                    shotItems.forEach(item => {
                        const deleteBtn = item.querySelector('.delete-btn');
                        if (deleteBtn && !deleteBtn.dataset.initialized) {
                            deleteBtn.dataset.initialized = 'true';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteShot(item, itemId, timestamp);
                            };
                        }
                    });
                };

                // Run immediately and after any UI update
                setupDeleteButtons();
                const observer = new MutationObserver(() => setupDeleteButtons());
                observer.observe(document.getElementById('shots-list'), {
                    childList: true,
                    subtree: true
                });
            }

            enableDeleteForVials() {
                const setupDeleteButtons = () => {
                    const vialItems = document.querySelectorAll('.vial-item');
                    vialItems.forEach(item => {
                        const deleteBtn = item.querySelector('.delete-btn');
                        if (deleteBtn && !deleteBtn.dataset.initialized) {
                            deleteBtn.dataset.initialized = 'true';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteVial(item, itemId, timestamp);
                            };
                        }
                    });
                };

                setupDeleteButtons();
                const observer = new MutationObserver(() => setupDeleteButtons());
                observer.observe(document.getElementById('vials-list'), {
                    childList: true,
                    subtree: true
                });
            }

            enableDeleteForWeights() {
                const setupDeleteButtons = () => {
                    const weightItems = document.querySelectorAll('.weight-item');
                    weightItems.forEach(item => {
                        const deleteBtn = item.querySelector('.delete-btn');
                        if (deleteBtn && !deleteBtn.dataset.initialized) {
                            deleteBtn.dataset.initialized = 'true';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteWeight(item, timestamp);
                            };
                        }
                    });
                };

                setupDeleteButtons();
                const observer = new MutationObserver(() => setupDeleteButtons());
                observer.observe(document.getElementById('weights-list'), {
                    childList: true,
                    subtree: true
                });
            }

            async handleDeleteShot(element, shotId, timestamp) {
                if (!confirm('Delete this injection?')) {
                    return;
                }

                // Find and delete the injection
                const index = app.data.injections.findIndex(inj => inj.id === shotId);
                if (index === -1) {
                    this.notificationManager.error('Injection not found');
                    return;
                }

                const deletedInjection = app.data.injections[index];

                // Add to undo stack
                this.undoStack.push({
                    type: 'injection',
                    data: deletedInjection,
                    index: index,
                    timestamp: Date.now()
                });

                if (this.undoStack.length > this.maxUndoStack) {
                    this.undoStack.shift();
                }

                // Remove from app data
                app.data.injections.splice(index, 1);

                // Save and update UI
                app.saveData();
                app.updateUI();

                // Animate out
                element.style.opacity = '0';
                element.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (element.parentNode) {
                        element.remove();
                    }
                }, 300);

                this.notificationManager.success('Injection deleted');
                this.showUndoButton();
            }

            async handleDeleteVial(element, vialId, timestamp) {
                // Check if vial has been used for any injections
                const hasInjections = app.data.injections.some(inj => inj.vial_id === vialId);

                if (hasInjections) {
                    if (!confirm('This vial has been used for injections. Delete anyway? (Injections will remain)')) {
                        return;
                    }
                }

                if (!hasInjections && !confirm('Delete this vial?')) {
                    return;
                }

                const index = app.data.vials.findIndex(v => v.vial_id === vialId);
                if (index === -1) {
                    this.notificationManager.error('Vial not found');
                    return;
                }

                const deletedVial = app.data.vials[index];

                // Mark as pending deletion to prevent sync from re-adding
                app._pendingDeletions.add(vialId);
                console.log(`Added ${vialId} to pending deletions`);

                // Add to undo stack
                this.undoStack.push({
                    type: 'vial',
                    data: deletedVial,
                    index: index,
                    timestamp: Date.now()
                });

                if (this.undoStack.length > this.maxUndoStack) {
                    this.undoStack.shift();
                }

                // Remove from app data
                app.data.vials.splice(index, 1);

                // Save and update UI
                app.saveData();
                app.updateUI();

                // Sync deletion to cloud
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        await apiClient.deleteVial(vialId);
                        console.log('Vial deleted from cloud successfully');
                        // Remove from pending deletions after successful cloud deletion
                        app._pendingDeletions.delete(vialId);
                        console.log(`Removed ${vialId} from pending deletions`);
                    } catch (error) {
                        console.error('Failed to delete vial from cloud:', error);
                        // Keep in pending deletions for 30 seconds then remove
                        setTimeout(() => {
                            app._pendingDeletions.delete(vialId);
                            console.log(`Removed ${vialId} from pending deletions after timeout`);
                        }, 30000);
                    }
                } else {
                    // Not authenticated, remove from pending after 5 seconds
                    setTimeout(() => {
                        app._pendingDeletions.delete(vialId);
                    }, 5000);
                }

                // Animate out
                element.style.opacity = '0';
                element.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (element.parentNode) {
                        element.remove();
                    }
                }, 300);

                this.notificationManager.success('Vial deleted');
                this.showUndoButton();
            }

            async handleDeleteWeight(element, timestamp) {
                if (!confirm('Delete this weight entry?')) {
                    return;
                }

                const index = app.data.weights.findIndex(w => w.timestamp === timestamp);
                if (index === -1) {
                    this.notificationManager.error('Weight entry not found');
                    return;
                }

                const deletedWeight = app.data.weights[index];

                // Add to undo stack
                this.undoStack.push({
                    type: 'weight',
                    data: deletedWeight,
                    index: index,
                    timestamp: Date.now()
                });

                if (this.undoStack.length > this.maxUndoStack) {
                    this.undoStack.shift();
                }

                // Remove from app data
                app.data.weights.splice(index, 1);

                // Save and update UI
                app.saveData();
                app.updateUI();

                // Animate out
                element.style.opacity = '0';
                element.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (element.parentNode) {
                        element.remove();
                    }
                }, 300);

                this.notificationManager.success('Weight entry deleted');
                this.showUndoButton();
            }

            showUndoButton() {
                if (this.undoButton) {
                    this.undoButton.classList.add('show');
                    setTimeout(() => {
                        this.undoButton.classList.remove('show');
                    }, 5000);
                }
            }

            async undoLastDelete() {
                if (this.undoStack.length === 0) {
                    this.notificationManager.warning('Nothing to undo');
                    return;
                }

                const operation = this.undoStack.pop();

                // Remove from pending deletions if present
                const itemId = operation.type === 'vial' ? operation.data.vial_id :
                               operation.type === 'injection' ? operation.data.id :
                               operation.data.timestamp;
                if (app._pendingDeletions.has(itemId)) {
                    app._pendingDeletions.delete(itemId);
                    console.log(`Removed ${itemId} from pending deletions (undo)`);
                }

                // Restore locally
                switch (operation.type) {
                    case 'injection':
                        app.data.injections.splice(operation.index, 0, operation.data);
                        break;
                    case 'vial':
                        app.data.vials.splice(operation.index, 0, operation.data);
                        break;
                    case 'weight':
                        app.data.weights.splice(operation.index, 0, operation.data);
                        break;
                }

                app.saveData();
                app.updateUI();

                // Sync restoration to cloud
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        switch (operation.type) {
                            case 'injection':
                                await apiClient.createInjection({
                                    id: operation.data.id,
                                    timestamp: operation.data.timestamp,
                                    doseMg: operation.data.dose_mg,
                                    site: operation.data.injection_site,
                                    vialId: operation.data.vial_id,
                                    notes: operation.data.notes || ''
                                });
                                console.log('Undone injection synced to cloud');
                                break;
                            case 'vial':
                                await apiClient.createVial({
                                    id: operation.data.vial_id,
                                    startDate: operation.data.order_date,
                                    initialVolumeMl: operation.data.bac_water_ml,
                                    concentrationMgPerMl: operation.data.concentration_mg_per_ml,
                                    currentVolumeMl: operation.data.current_volume_ml,
                                    usedVolumeMl: operation.data.used_volume_ml,
                                    status: operation.data.status,
                                    source: operation.data.supplier || '',
                                    notes: operation.data.notes || ''
                                });
                                console.log('Undone vial synced to cloud');
                                break;
                            case 'weight':
                                await apiClient.createWeight({
                                    timestamp: operation.data.timestamp,
                                    weightKg: operation.data.weight_kg,
                                    source: operation.data.source || 'manual',
                                    notes: operation.data.notes || ''
                                });
                                console.log('Undone weight synced to cloud');
                                break;
                        }
                    } catch (error) {
                        console.error('Failed to sync undo to cloud:', error);
                        this.notificationManager.warning('Restored locally but cloud sync failed');
                    }
                }

                const typeNames = {
                    'injection': 'Injection',
                    'vial': 'Vial',
                    'weight': 'Weight entry'
                };
                this.notificationManager.success(`${typeNames[operation.type]} restored`);

                if (this.undoButton) {
                    this.undoButton.classList.remove('show');
                }
            }
        }

        // ====================================
        // RESILIENT BACKUP SYSTEM
        // ====================================

        class ResilientBackupManager {
            constructor() {
                this.storageKey = 'injection_data';
                this.dbName = 'RetatrutideDB';
                this.dbVersion = 1;
                this.storeName = 'appData';
                this.db = null;
            }

            async initialize() {
                // Initialize IndexedDB
                await this.initIndexedDB();

                console.log('Resilient backup system initialized');
            }

            initIndexedDB() {
                return new Promise((resolve) => {
                    if (!window.indexedDB) {
                        console.warn('IndexedDB not available');
                        resolve(null);
                        return;
                    }

                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = () => {
                        console.error('IndexedDB open failed');
                        resolve(null);
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        console.log('IndexedDB initialized');
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const objectStore = db.createObjectStore(this.storeName, { keyPath: 'key' });
                            objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            }

            async saveData(data) {
                // Save to localStorage
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(data));
                } catch (error) {
                    console.error('Failed to save to localStorage:', error);
                }

                // Save to IndexedDB as fallback
                if (this.db) {
                    await this.saveToIndexedDB(data);
                }

                return true;
            }

            async saveToIndexedDB(data) {
                if (!this.db) return false;

                return new Promise((resolve) => {
                    try {
                        const transaction = this.db.transaction([this.storeName], 'readwrite');
                        const objectStore = transaction.objectStore(this.storeName);

                        const record = {
                            key: this.storageKey,
                            data: data,
                            timestamp: Date.now(),
                            date: new Date().toISOString()
                        };

                        const request = objectStore.put(record);
                        request.onsuccess = () => resolve(true);
                        request.onerror = () => resolve(false);
                    } catch (error) {
                        console.error('IndexedDB save error:', error);
                        resolve(false);
                    }
                });
            }

            async loadData() {
                // Try localStorage first
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) {
                        return JSON.parse(stored);
                    }
                } catch (error) {
                    console.error('Failed to load from localStorage:', error);
                }

                // Try IndexedDB as fallback
                if (this.db) {
                    return await this.loadFromIndexedDB();
                }

                return null;
            }

            async loadFromIndexedDB() {
                if (!this.db) return null;

                return new Promise((resolve) => {
                    try {
                        const transaction = this.db.transaction([this.storeName], 'readonly');
                        const objectStore = transaction.objectStore(this.storeName);
                        const request = objectStore.get(this.storageKey);

                        request.onsuccess = () => {
                            if (request.result) {
                                resolve(request.result.data);
                            } else {
                                resolve(null);
                            }
                        };

                        request.onerror = () => resolve(null);
                    } catch (error) {
                        console.error('IndexedDB load error:', error);
                        resolve(null);
                    }
                });
            }

        }

        // ====================================
        // INITIALIZE APPLICATION
        // ====================================

        let app;
        let deleteManager;
        let backupManager;

        document.addEventListener('DOMContentLoaded', async function() {
            app = new InjectionTracker();
            app.registerServiceWorker();
            app.requestNotificationPermission();

            // Initialize backup system
            backupManager = new ResilientBackupManager();
            await backupManager.initialize();

            // Initialize delete functionality
            deleteManager = new SimpleDeleteManager();
            deleteManager.initialize();
            deleteManager.enableDeleteForShots();
            deleteManager.enableDeleteForVials();
            deleteManager.enableDeleteForWeights();

            // Initialize cloud integration
            apiClient.initialize(authManager);
            // Legacy cloud storage disabled - using direct API sync instead
            // await cloudStorage.initialize(authManager, apiClient, app.storage);
            migrationWizard.initialize(authManager, apiClient);

            // Set up auth state change listener (after all initializations)
            setupAuthStateListener();

            // Handle URL parameters for PWA shortcuts
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('action') === 'add_shot') {
                setTimeout(() => app.openModal('add-shot-modal'), 500);
            } else if (urlParams.get('tab')) {
                const tab = urlParams.get('tab');
                setTimeout(() => {
                    document.querySelector(`[data-tab="${tab}"]`)?.click();
                }, 500);
            }
        });

        // Update UI based on auth state
        function updateAuthUI(user) {
            const authButton = document.getElementById('auth-button');
            const userInfo = document.getElementById('user-info');

            if (user) {
                // User is signed in
                if (authButton) {
                    authButton.textContent = 'Sign Out';
                    authButton.onclick = () => authManager.signOut();
                }
                if (userInfo) {
                    userInfo.textContent = `Signed in as ${user.displayName || user.email}`;
                    userInfo.style.display = 'block';
                }
            } else {
                // User is signed out
                if (authButton) {
                    authButton.textContent = 'Sign In with Google';
                    authButton.onclick = async () => {
                        authButton.textContent = 'Redirecting...';
                        authButton.disabled = true;
                        try {
                            await authManager.signInWithGoogle();
                            // Page will redirect, so no need to reset button state
                        } catch (error) {
                            console.error('Sign in error:', error);
                            authButton.textContent = 'Sign In with Google';
                            authButton.disabled = false;
                            alert(error.message || 'Failed to sign in. Please try again.');
                        }
                    };
                }
                if (userInfo) {
                    userInfo.style.display = 'none';
                }
            }
        }

        // Auth state listener setup function
        function setupAuthStateListener() {
            const authGate = document.getElementById('auth-gate');
            const authGateButton = document.getElementById('auth-gate-button');
            const appContent = document.getElementById('app-content');
            let lastAuthUserId = null;  // Track last known user to prevent duplicate syncs

            // Sign in handler for auth gate
            if (authGateButton) {
                authGateButton.addEventListener('click', async () => {
                    authGateButton.textContent = 'Redirecting to Google...';
                    authGateButton.disabled = true;
                    try {
                        await authManager.signInWithGoogle();
                        // Note: Page will redirect, so code after this won't execute
                    } catch (error) {
                        console.error('Sign in error:', error);
                        authGateButton.textContent = 'Sign In with Google';
                        authGateButton.disabled = false;
                        // Show the detailed error message
                        alert(error.message || 'Failed to sign in. Please try again.');
                    }
                });
            }

            // Show/hide content based on auth state
            authManager.onAuthStateChange((user) => {
            if (user) {
                // Check if this is a new auth state (not just a token refresh)
                const isNewAuth = lastAuthUserId !== user.uid;
                lastAuthUserId = user.uid;

                // User signed in - show app, hide gate
                authGate.style.display = 'none';
                appContent.style.display = 'block';
                updateAuthUI(user);

                // Enable cloud backup button
                const cloudBackupBtn = document.getElementById('create-cloud-backup-btn');
                if (cloudBackupBtn) {
                    cloudBackupBtn.disabled = false;
                }

                // Only run these on actual sign-in, not on token refresh
                if (isNewAuth && app) {
                    console.log('New auth detected, syncing data...');

                    // Update cloud backup status
                    app.updateCloudBackupStatus();

                    // Check if auto-backup is needed
                    app.checkAutoBackup();

                    // Sync data from cloud (protected by guard)
                    app.syncFromCloud();

                    // Trigger migration wizard
                    setTimeout(() => {
                        migrationWizard.autoStart();
                    }, 1000);
                }
            } else {
                // User signed out - reset tracking and show gate
                lastAuthUserId = null;
                authGate.style.display = 'flex';
                appContent.style.display = 'none';

                // Reset auth gate button to initial state
                if (authGateButton) {
                    authGateButton.textContent = 'Sign In with Google';
                    authGateButton.disabled = false;
                }

                // Disable cloud backup button
                const cloudBackupBtn = document.getElementById('create-cloud-backup-btn');
                if (cloudBackupBtn) {
                    cloudBackupBtn.disabled = true;
                }

                // Update cloud backup status
                if (app) {
                    app.updateCloudBackupStatus();
                }
            }
            });
        }
    </script>
    </div> <!-- Close app-content -->
</body>
</html>