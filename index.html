<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta name="googlebot" content="noindex, nofollow">
    <title>Injection Tracker</title>

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Injection Tracker">
    <meta name="description" content="Comprehensive injection tracker with vial management and weight tracking">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Crect width='32' height='32' fill='%231a1a1a'/%3E%3Ctext x='50%25' y='50%25' font-family='sans-serif' font-size='16' fill='white' text-anchor='middle' dominant-baseline='central'%3ESR%3C/text%3E%3C/svg%3E">

    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- Confetti for celebrations -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <!-- Firebase Configuration -->
    <script>
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyDkdbPPZ2pySDOWBhAsSWzkfyYWvR0jlO8",
            authDomain: "reta-tracker.firebaseapp.com",
            projectId: "reta-tracker",
            storageBucket: "reta-tracker.firebasestorage.app",
            messagingSenderId: "273148192362",
            appId: "1:273148192362:web:c3011ac8cf76a3611e0c13"
        };
        firebase.initializeApp(firebaseConfig);
    </script>

    <!-- Test mode detection BEFORE loading auth-manager -->
    <script>
        // Set flag IMMEDIATELY if in test mode on localhost, before any modules load
        const urlParams = new URLSearchParams(window.location.search);
        const isTestMode = urlParams.get('test') === 'true';
        const isLocalhost = window.location.hostname === 'localhost' ||
                            window.location.hostname === '127.0.0.1';

        if (isTestMode && isLocalhost) {
            console.log('[EARLY INIT] Test mode detected on localhost - setting SKIP_AUTH_INIT flag');
            window.SKIP_AUTH_INIT = true;
        } else if (isTestMode && !isLocalhost) {
            console.warn('[EARLY INIT] Test mode parameter detected on production - IGNORING for security');
        }
    </script>

    <!-- Cloud Integration Modules -->
    <script src="js/auth-manager.js"></script>
    <script src="js/api-client.js"></script>
    <script src="js/sync-queue.js"></script>
    <script src="js/cloud-storage.js"></script>
    <script src="js/migration-wizard.js"></script>

    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: #0a0a0a;
            --secondary-bg: #1a1a1a;
            --card-bg: #2a2a2a;
            --border-color: #333333;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #888888;
            --accent-color: #007AFF;
            --success-color: #34C759;
            --warning-color: #FF9500;
            --danger-color: #FF3B30;
            --border-radius: 12px;
            --border-radius-sm: 8px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
            padding-bottom: 80px;
            line-height: 1.5;
        }

        /* Header Styles */
        #app-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
            height: 60px;
            backdrop-filter: blur(10px);
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-md);
            height: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        .menu-btn, .add-shot-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 18px;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .add-shot-btn {
            background-color: var(--accent-color);
            color: white;
            font-weight: 600;
            font-size: 14px;
            padding: var(--spacing-sm) var(--spacing-md);
        }

        .menu-btn:hover, .add-shot-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .add-shot-btn:hover {
            background-color: #0056b3;
        }

        .date-display {
            font-weight: 600;
            font-size: 16px;
            color: var(--text-primary);
        }

        /* Phase 1B: Sync Status Indicator */
        .sync-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 16px;
            background-color: var(--card-bg);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .sync-status:hover {
            background-color: var(--border-color);
        }

        .sync-status.synced {
            background-color: rgba(52, 199, 89, 0.15);
        }

        .sync-status.syncing {
            background-color: rgba(255, 149, 0, 0.15);
        }

        .sync-status.pending {
            background-color: rgba(255, 204, 0, 0.15);
        }

        .sync-status.error {
            background-color: rgba(255, 59, 48, 0.15);
        }

        .sync-status.offline {
            background-color: rgba(136, 136, 136, 0.15);
        }

        .sync-icon {
            font-size: 14px;
            display: inline-block;
            transition: transform 0.3s;
        }

        .sync-status.syncing .sync-icon {
            animation: spin 1s linear infinite;
        }

        .sync-text {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .sync-status.synced .sync-text {
            color: var(--success-color);
        }

        .sync-status.syncing .sync-text {
            color: var(--warning-color);
        }

        .sync-status.pending .sync-text {
            color: var(--warning-color);
        }

        .sync-status.error .sync-text {
            color: var(--danger-color);
        }

        .sync-status.offline .sync-text {
            color: var(--text-muted);
        }

        .sync-badge {
            display: none;
            min-width: 18px;
            height: 18px;
            padding: 0 4px;
            background-color: var(--danger-color);
            color: white;
            font-size: 10px;
            font-weight: 700;
            border-radius: 9px;
            line-height: 18px;
            text-align: center;
        }

        .sync-badge:not(:empty) {
            display: inline-block;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Sync Queue Modal */
        .sync-queue-modal {
            display: none;
            position: fixed;
            top: 60px;
            right: 10px;
            width: 350px;
            max-height: 500px;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            overflow: hidden;
            flex-direction: column;
        }

        .sync-queue-modal.open {
            display: flex;
        }

        .sync-queue-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sync-queue-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
        }

        .sync-queue-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sync-queue-body {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
        }

        .sync-queue-empty {
            text-align: center;
            padding: var(--spacing-xl);
            color: var(--text-muted);
        }

        .sync-queue-item {
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            background-color: var(--card-bg);
            border-radius: var(--border-radius-sm);
            border-left: 3px solid var(--border-color);
        }

        .sync-queue-item.pending {
            border-left-color: var(--warning-color);
        }

        .sync-queue-item.completed {
            border-left-color: var(--success-color);
            opacity: 0.6;
        }

        .sync-queue-item.failed {
            border-left-color: var(--danger-color);
        }

        .sync-queue-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-xs);
        }

        .sync-queue-item-type {
            font-weight: 600;
            font-size: 14px;
        }

        .sync-queue-item-status {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
        }

        .sync-queue-item-status.pending {
            background-color: rgba(255, 149, 0, 0.2);
            color: var(--warning-color);
        }

        .sync-queue-item-status.completed {
            background-color: rgba(52, 199, 89, 0.2);
            color: var(--success-color);
        }

        .sync-queue-item-status.failed {
            background-color: rgba(255, 59, 48, 0.2);
            color: var(--danger-color);
        }

        .sync-queue-item-details {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-xs);
        }

        .sync-queue-item-error {
            font-size: 12px;
            color: var(--danger-color);
            margin-top: var(--spacing-xs);
        }

        .sync-queue-item-actions {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        .sync-queue-item-retry {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: var(--border-radius-sm);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .sync-queue-footer {
            padding: var(--spacing-md);
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: var(--spacing-sm);
        }

        .sync-queue-footer button {
            flex: 1;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            border: none;
            font-weight: 600;
            cursor: pointer;
        }

        .sync-queue-clear-completed {
            background-color: var(--card-bg);
            color: var(--text-primary);
        }

        .sync-queue-clear-failed {
            background-color: var(--danger-color);
            color: white;
        }

        /* Phase 3: Validation Status Indicators */
        .validation-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            margin-left: 8px;
            vertical-align: middle;
        }

        .validation-icon {
            font-size: 16px;
            line-height: 1;
        }

        .validation-success .validation-icon {
            color: var(--success-color);
        }

        .validation-warning .validation-icon {
            color: var(--warning-color);
        }

        .validation-error .validation-icon {
            color: var(--danger-color);
        }

        /* Validation tooltip */
        .validation-tooltip {
            position: relative;
            cursor: help;
        }

        .validation-tooltip .tooltip-content {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .validation-tooltip:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        .validation-tooltip .tooltip-content::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }

        /* Stat card validation enhancement */
        .stat-card .stat-value-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .stat-card.has-validation-issue {
            border-left: 3px solid var(--warning-color);
        }

        .stat-card.has-validation-error {
            border-left: 3px solid var(--danger-color);
        }

        /* Validation summary in sync status modal */
        .validation-summary {
            padding: 12px;
            background-color: rgba(255, 204, 0, 0.1);
            border-radius: 8px;
            margin-bottom: 16px;
            display: none;
        }

        .validation-summary.show {
            display: block;
        }

        .validation-summary-title {
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--warning-color);
        }

        .validation-summary-list {
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .validation-summary-list li {
            margin-left: 20px;
            margin-bottom: 4px;
        }

        /* Main Content */
        #main-content {
            margin-top: 60px;
            min-height: calc(100vh - 140px);
        }

        .container {
            padding: var(--spacing-lg) var(--spacing-md);
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Responsive design */
        @media (min-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .results-stats {
                grid-template-columns: repeat(4, 1fr);
            }

            .inventory-stats {
                grid-template-columns: repeat(4, 1fr);
            }

            .chart-container, .supply-forecast-container {
                padding: var(--spacing-xl);
            }

            .chart-container canvas {
                max-height: 600px;
            }

            .shot-item, .vial-item {
                padding: var(--spacing-lg);
            }

            .form-container {
                max-width: 600px;
                margin: 0 auto;
            }

            .countdown-container {
                max-width: 600px;
                margin: 0 auto var(--spacing-lg);
            }
        }

        /* Tablet specific */
        @media (min-width: 768px) and (max-width: 1024px) {
            .container {
                max-width: 90%;
            }
        }

        /* Large desktop */
        @media (min-width: 1200px) {
            .tab-content {
                max-width: 1000px;
                margin: 0 auto;
            }
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: calc(100vh - 140px);
            font-size: 18px;
            color: var(--text-secondary);
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
        }

        .stat-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            text-align: center;
            transition: background-color 0.2s;
            min-width: 0; /* Allow cards to shrink */
        }

        .stat-card:hover {
            background-color: #353535;
        }

        .stat-value {
            font-size: clamp(20px, 4vw, 24px); /* Fluid typography */
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-muted);
            font-weight: 500;
        }

        /* Chart Container */
        .chart-container, .supply-forecast-container {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .chart-container h3, .supply-forecast-container h3 {
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
        }

        .chart-container canvas {
            max-height: 450px;
            min-height: 300px;
            width: 100% !important;
            height: 400px !important;
        }

        .chart-section {
            margin-bottom: var(--spacing-xl);
        }

        .chart-section-title {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
            padding-left: var(--spacing-md);
        }

        .supply-forecast {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .forecast-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-color);
        }

        .forecast-row:last-child {
            border-bottom: none;
        }

        .forecast-label {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .forecast-value {
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
        }

        .forecast-input-group {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .forecast-input {
            width: 60px;
            padding: var(--spacing-xs);
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            font-size: 16px;
            font-weight: 600;
            text-align: center;
        }

        .forecast-unit {
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Countdown Container */
        .countdown-container {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            text-align: center;
        }

        .countdown-container h3 {
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
        }

        .countdown-circle {
            position: relative;
            display: inline-block;
        }

        .countdown-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .next-shot-day {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-color);
            line-height: 1;
        }

        .next-shot-date {
            font-size: 32px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 4px 0;
        }

        .next-shot-time {
            font-size: 18px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .countdown-progress {
            width: 200px;
            height: 200px;
        }

        .countdown-progress circle {
            transition: stroke-dashoffset 1s ease;
        }

        /* Buttons */
        .btn-primary, .btn-secondary {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md) var(--spacing-lg);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: var(--spacing-sm);
        }

        .btn-secondary {
            background-color: var(--card-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-primary:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        .btn-secondary:hover {
            background-color: #353535;
        }

        /* Shots List */
        .shots-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
        }

        .shots-header h2 {
            font-size: 24px;
            font-weight: 700;
        }

        .shots-list, .weights-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .shot-item, .weight-item {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
            position: relative;
        }

        .shot-item:hover, .weight-item:hover {
            background-color: #353535;
        }

        .shot-content, .weight-content {
            flex: 1;
        }

        .shot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .shot-dose {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-color);
        }

        .shot-date {
            font-size: 14px;
            color: var(--text-muted);
        }

        .shot-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Results Header */
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .results-header h2 {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }

        .add-shot-btn-results {
            background-color: transparent;
            color: var(--accent-color);
            border: none;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            padding: 8px 0;
        }

        .add-shot-btn-results:hover {
            opacity: 0.7;
        }

        /* Time Period Segmented Control */
        .time-period-control {
            display: flex;
            background-color: #3a3a3a;
            border-radius: 10px;
            padding: 2px;
            margin-bottom: 24px;
        }

        .period-btn {
            flex: 1;
            background-color: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .period-btn.active {
            background-color: #505050;
            color: var(--text-primary);
        }

        .period-btn:hover:not(.active) {
            color: var(--text-primary);
        }

        /* Weight Change Section */
        .weight-change-section {
            margin-bottom: 24px;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title h3 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .section-icon {
            width: 24px;
            height: 24px;
            color: var(--text-secondary);
        }

        .date-range {
            font-size: 14px;
            color: var(--text-muted);
        }

        /* Results Stats Grid (2x3) */
        .results-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        .result-card {
            background-color: #3a3a3a;
            border: 1px solid #4a4a4a;
            border-radius: 12px;
            padding: 16px;
        }

        .result-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .metric-icon {
            width: 16px;
            height: 16px;
            stroke-width: 2.5;
        }

        .result-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Old results-stats for backward compatibility */
        .results-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
        }

        /* Inventory */
        .inventory-header {
            margin-bottom: var(--spacing-lg);
        }

        .vials-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
        }

        .vial-item {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
            position: relative;
        }

        .vial-content {
            flex: 1;
        }

        .vial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .vial-status {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .vial-status.active {
            background-color: var(--success-color);
            color: white;
        }

        .vial-status.expired {
            background-color: var(--danger-color);
            color: white;
        }

        .vial-status.expiring {
            background-color: var(--warning-color);
            color: white;
        }

        .vial-status.empty {
            background-color: var(--text-muted);
            color: white;
        }

        .vial-status.dry_stock {
            background-color: var(--warning-color);
            color: var(--bg-color);
        }

        .vial-item.dry_stock {
            border-left: 4px solid var(--warning-color);
        }

        /* Delete Button Styles */
        .delete-btn {
            background-color: transparent;
            border: 2px solid var(--danger-color);
            color: var(--danger-color);
            border-radius: var(--border-radius-sm);
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .delete-btn:hover {
            background-color: var(--danger-color);
            color: white;
            opacity: 1;
            transform: scale(1.05);
        }

        .delete-btn:active {
            transform: scale(0.95);
        }

        .delete-btn svg {
            width: 20px;
            height: 20px;
        }

        .edit-btn {
            background-color: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            border-radius: var(--border-radius-sm);
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            margin-right: 8px;
        }

        .edit-btn:hover {
            background-color: var(--primary-color);
            color: white;
            opacity: 1;
            transform: scale(1.05);
        }

        .edit-btn:active {
            transform: scale(0.95);
        }

        .edit-btn svg {
            width: 20px;
            height: 20px;
        }

        .vial-info {
            flex: 1;
        }

        .vial-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .vial-subtitle {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 2px;
        }

        .vial-details {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .vial-detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .vial-detail-row span:first-child {
            color: var(--text-muted);
            font-weight: 500;
        }

        .vial-detail-row span:last-child {
            color: var(--text-secondary);
            font-weight: 600;
        }

        .inventory-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
        }


        .inventory-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            text-align: center;
        }

        .inventory-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--warning-color);
            margin-bottom: var(--spacing-xs);
        }

        .inventory-label {
            font-size: 14px;
            color: var(--text-muted);
        }

        /* Settings */
        .settings-section {
            margin-bottom: var(--spacing-xl);
        }

        .settings-section h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
        }

        .settings-section label {
            display: block;
            margin-bottom: var(--spacing-md);
            color: var(--text-secondary);
        }

        .settings-section select,
        .settings-section input[type="number"],
        .settings-section input[type="text"] {
            width: 100%;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            color: var(--text-primary);
            font-size: 16px;
            margin-top: var(--spacing-sm);
        }

        .settings-section input[type="checkbox"] {
            width: auto;
            margin-left: var(--spacing-sm);
            transform: scale(1.2);
        }

        .btn-secondary.connected {
            background-color: var(--success-color);
            color: white;
        }

        .setting-input-wrapper {
            position: relative;
        }

        .save-indicator {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%) scale(0.8);
            font-size: 13px;
            font-weight: 600;
            color: #34C759;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            white-space: nowrap;
        }

        .save-indicator.show {
            opacity: 1;
            transform: translateY(-50%) scale(1);
        }

        @keyframes saveTextPulse {
            0%, 100% { opacity: 1; transform: translateY(-50%) scale(1); }
            50% { opacity: 0.7; transform: translateY(-50%) scale(0.95); }
        }

        .save-indicator.show {
            animation: saveTextPulse 0.6s ease-in-out;
        }

        .sync-status {
            margin-top: var(--spacing-md);
            padding: var(--spacing-md);
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .modal-content {
            padding: var(--spacing-lg);
        }

        .modal-content p,
        .modal-content li {
            color: var(--text-secondary);
            margin-bottom: var(--spacing-sm);
        }

        .modal-content a {
            color: var(--accent-color);
            text-decoration: none;
        }

        .modal-content a:hover {
            text-decoration: underline;
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--secondary-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: var(--spacing-sm) 0;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .nav-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            transition: color 0.2s;
            min-width: 60px;
        }

        .nav-btn.active {
            color: var(--accent-color);
        }

        .nav-btn:hover {
            color: var(--text-primary);
        }

        .nav-btn.active:hover {
            color: var(--accent-color);
        }

        .nav-icon {
            width: 24px;
            height: 24px;
            margin-bottom: var(--spacing-xs);
            stroke: currentColor;
        }

        .nav-btn.active .nav-icon {
            stroke: var(--accent-color);
        }

        .nav-label {
            font-size: 12px;
            font-weight: 500;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-xl);
            margin: var(--spacing-md);
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Migration Modal Styles */
        #migration-modal .modal-content {
            max-width: 500px;
        }

        .migration-summary {
            background: var(--card-bg);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-lg) 0;
        }

        .migration-summary h3 {
            margin-bottom: var(--spacing-sm);
        }

        .migration-summary ul {
            list-style: none;
            margin: var(--spacing-sm) 0;
        }

        .migration-summary li {
            padding: var(--spacing-xs) 0;
        }

        .migration-actions {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--card-bg);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: var(--spacing-md);
        }

        .progress-fill {
            height: 100%;
            background: var(--success-color);
            transition: width 0.3s ease;
            width: 0%;
        }

        .migration-success,
        .migration-error {
            text-align: center;
            padding: var(--spacing-lg);
        }

        .migration-stats {
            background: var(--card-bg);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
        }

        .migration-stats p {
            padding: var(--spacing-xs) 0;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
        }

        .modal-title {
            font-size: 20px;
            font-weight: 700;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
            padding: var(--spacing-xs);
        }

        /* Form Styles */
        .form-group {
            margin-bottom: var(--spacing-lg);
        }

        .form-group label {
            display: block;
            margin-bottom: var(--spacing-sm);
            color: var(--text-secondary);
            font-weight: 500;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            color: var(--text-primary);
            font-size: 16px;
            transition: border-color 0.2s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Enhanced Responsive Design */

        /* Mobile First - Small phones (320px - 480px) */
        @media (max-width: 480px) {
            :root {
                --spacing-sm: 8px;
                --spacing-md: 12px;
                --spacing-lg: 16px;
                --spacing-xl: 20px;
            }

            body {
                font-size: 14px;
            }

            .container {
                padding: var(--spacing-md) var(--spacing-sm);
            }

            .stats-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-sm);
            }

            .header-content {
                padding: 0 var(--spacing-sm);
                flex-wrap: wrap;
                gap: var(--spacing-sm);
            }

            header h1 {
                font-size: 20px;
            }

            .tab-nav {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
            }

            .tab-nav::-webkit-scrollbar {
                display: none;
            }

            .tab-button {
                min-width: 80px;
                padding: 10px 12px;
                font-size: 13px;
                white-space: nowrap;
            }

            .shot-details {
                grid-template-columns: 1fr;
            }

            .results-stats,
            .inventory-stats {
                grid-template-columns: 1fr;
            }

            .results-stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .result-card {
                padding: 12px;
            }

            .result-value {
                font-size: 20px;
            }

            .period-btn {
                font-size: 12px;
                padding: 6px 12px;
            }

            .section-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .modal-content {
                margin: var(--spacing-sm);
                max-width: calc(100% - 32px);
                padding: var(--spacing-lg);
            }

            .btn-primary,
            .btn-secondary {
                padding: 12px 16px;
                font-size: 14px;
                min-height: 44px; /* Touch-friendly */
            }

            input,
            select,
            textarea {
                min-height: 44px; /* Touch-friendly */
                font-size: 16px; /* Prevent iOS zoom */
            }

            .notification-container {
                right: 10px;
                left: 10px;
                max-width: calc(100% - 20px);
            }

            .notification {
                min-width: unset;
                width: 100%;
            }

            .chart-container canvas {
                max-height: 400px !important;
                min-height: 350px !important;
            }

            .chart-container,
            .supply-forecast-container {
                padding: var(--spacing-md) 8px;
                margin-left: -4px;
                margin-right: -4px;
            }

            .stat-label {
                font-size: 12px;
            }

            .card,
            .vial-card,
            .result-card {
                padding: var(--spacing-md);
            }
        }

        /* Tablets and small laptops (481px - 768px) */
        @media (min-width: 481px) and (max-width: 768px) {
            .container {
                padding: var(--spacing-lg) var(--spacing-md);
                max-width: 95%;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .shot-details {
                grid-template-columns: repeat(2, 1fr);
            }

            .results-stats,
            .inventory-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-content {
                max-width: 90%;
            }

            .tab-button {
                min-width: 90px;
            }
        }

        /* Medium devices (769px - 1024px) */
        @media (min-width: 769px) and (max-width: 1024px) {
            .container {
                max-width: 90%;
            }

            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .tab-button {
                min-width: 100px;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .btn-primary,
            .btn-secondary,
            .tab-button,
            button {
                min-height: 44px;
                min-width: 44px;
            }

            .modal-close {
                min-width: 44px;
                min-height: 44px;
                font-size: 24px;
            }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .modal-content {
                max-height: 90vh;
                overflow-y: auto;
            }

            header {
                padding: var(--spacing-sm) 0;
            }
        }

        /* Print styles */
        @media print {
            header,
            .tab-nav,
            .modal,
            .notification-container,
            #undo-button {
                display: none !important;
            }

            .tab-content {
                display: block !important;
            }
        }

        /* Loading Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 2s infinite;
        }

        /* Notification System */
        #notification-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .notification {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 16px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: slideInRight 0.3s ease-out;
            min-width: 300px;
        }

        .notification.success {
            border-left: 4px solid var(--success-color);
        }

        .notification.error {
            border-left: 4px solid var(--danger-color);
        }

        .notification.warning {
            border-left: 4px solid var(--warning-color);
        }

        .notification.info {
            border-left: 4px solid var(--accent-color);
        }

        .notification.saving {
            border-left: 4px solid var(--accent-color);
        }

        .notification-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .notification-content {
            flex: 1;
        }

        .notification-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        .notification-message {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .notification-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-close:hover {
            color: var(--text-primary);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification.hiding {
            animation: slideOutRight 0.3s ease-in forwards;
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Undo Button */
        #undo-button {
            position: fixed;
            bottom: 100px;
            right: 20px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 9999;
            display: none;
        }

        #undo-button:hover {
            background-color: #0066CC;
        }

        #undo-button.show {
            display: block;
            animation: slideInUp 0.3s ease-out;
        }

        @keyframes slideInUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Save Indicator Animations */
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translateX(-50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }
        }

        @keyframes fadeOutScale {
            from {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }
            to {
                opacity: 0;
                transform: translateX(-50%) scale(0.8);
            }
        }

        /* Utility Classes */
        .text-center { text-align: center; }
        .text-left { text-align: left; }
        .text-right { text-align: right; }
        .mb-0 { margin-bottom: 0; }
        .mb-sm { margin-bottom: var(--spacing-sm); }
        .mb-md { margin-bottom: var(--spacing-md); }
        .mb-lg { margin-bottom: var(--spacing-lg); }
        .hidden { display: none !important; }
        .flex { display: flex; }
        .flex-column { flex-direction: column; }
        .justify-between { justify-content: space-between; }
        .align-center { align-items: center; }

        /* Empty States */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-xl) var(--spacing-md);
            text-align: center;
            min-height: 300px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: var(--spacing-md);
            opacity: 0.5;
        }

        .empty-state h3 {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
        }

        .empty-state p {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: var(--spacing-lg);
            max-width: 300px;
        }

        /* Floating Action Button (FAB) */
        .fab {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #007AFF, #0051a8);
            color: white;
            border: none;
            font-size: 28px;
            font-weight: 300;
            line-height: 1;
            box-shadow: 0 4px 16px rgba(0, 122, 255, 0.4);
            z-index: 99;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fab:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 122, 255, 0.5);
        }

        .fab:active {
            transform: scale(0.95);
        }

        /* Form Validation */
        .form-group input:invalid:not(:focus):not(:placeholder-shown),
        .form-group select:invalid:not(:focus) {
            border-color: var(--danger-color);
        }

        .form-group input:valid:not(:focus):not(:placeholder-shown):not([type="datetime-local"]):not([type="date"]),
        .form-group select:valid:not(:focus):not([value=""]) {
            border-color: var(--success-color);
        }

        .field-error {
            color: var(--danger-color);
            font-size: 12px;
            margin-top: 4px;
            display: none;
        }

        .form-group.error .field-error {
            display: block;
        }

        /* Pull to Refresh Indicator - Disabled due to UX issues */
        .pull-to-refresh {
            display: none !important;  /* Completely hidden */
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            background: var(--card-bg);
            padding: 12px 24px;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s;
            z-index: 1001;
            align-items: center;
            gap: 8px;
        }

        .pull-to-refresh.active {
            transform: translateX(-50%) translateY(10px);
        }

        .pull-to-refresh-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Time Range Selector - Removed, now using .period-btn styles defined above */

        /* Swipe to Delete */
        .shot-item, .weight-item, .vial-item {
            position: relative;
            transition: transform 0.3s;
        }

        .shot-item.swiping, .weight-item.swiping, .vial-item.swiping {
            transition: none;
        }

        .delete-action {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 80px;
            background: var(--danger-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .shot-item.swiped .delete-action,
        .weight-item.swiped .delete-action,
        .vial-item.swiped .delete-action {
            opacity: 1;
        }

        /* Animated Transitions */
        .tab-content {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Offline Indicator */
        .offline-indicator {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--warning-color);
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            z-index: 10002;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .offline-indicator.show {
            display: block;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100%);
            }
            to {
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Weekly Insights Card */
        .insight-card {
            background: linear-gradient(135deg, var(--card-bg) 0%, #2d2d2d 100%);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .insight-card h3 {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
        }

        .insight-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-color);
        }

        .insight-stat:last-child {
            border-bottom: none;
        }

        .insight-label {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .insight-value {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 700;
        }

        .insight-trend {
            color: var(--success-color);
            font-size: 14px;
            font-weight: 600;
        }

        .insight-trend.negative {
            color: var(--danger-color);
        }

        /* Loading Spinner */
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        /* Countdown Timer Enhancements */
        .countdown-circle {
            cursor: pointer;
            user-select: none;
        }

        .countdown-circle:active {
            transform: scale(0.98);
        }

        .countdown-pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.02);
            }
        }
    </style>
</head>
<body>
    <!-- Authentication Gate -->
    <div id="auth-gate" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%); padding: 20px;">
        <div style="text-align: center; max-width: 400px;">
            <h1 style="font-size: 32px; margin-bottom: 16px; background: linear-gradient(135deg, #007AFF 0%, #0051a8 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                Retatrutide Tracker
            </h1>
            <p style="color: #888888; margin-bottom: 32px; font-size: 16px;">
                Please sign in to access your tracking data
            </p>
            <button id="auth-gate-button" style="background: linear-gradient(135deg, #007AFF 0%, #0051a8 100%); color: white; border: none; padding: 16px 32px; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3); transition: transform 0.2s, box-shadow 0.2s; min-width: 200px; touch-action: manipulation; -webkit-tap-highlight-color: rgba(0, 122, 255, 0.3);">
                Sign In with Google
            </button>
            <p style="color: #666666; margin-top: 32px; font-size: 12px;">
                This is a private application. No data is shared publicly.
            </p>
        </div>
    </div>

    <!-- Application Content (hidden until authenticated) -->
    <div id="app-content" style="display: none;">
        <!-- Notification Container -->
        <div id="notification-container"></div>

        <!-- Undo Button -->
        <button id="undo-button"> Undo Delete</button>

        <!-- Save Indicator -->
        <div id="save-indicator" style="position: fixed; top: 70px; left: 50%; transform: translateX(-50%); background-color: #34C759; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 600; display: none; z-index: 10001; box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3);">
             Saved
        </div>

        <!-- Offline Indicator -->
        <div id="offline-indicator" class="offline-indicator">
             Offline - Changes saved locally
        </div>

        <!-- Floating Action Button -->
        <button id="fab-button" class="fab" title="Quick Add Shot">+</button>

        <!-- Header -->
        <header id="app-header">
        <div class="header-content">
            <button id="menu-btn" class="menu-btn"></button>
            <!-- Phase 1B: Sync Status Indicator -->
            <div id="sync-status" class="sync-status" title="Click to view sync queue">
                <span class="sync-icon"></span>
                <span class="sync-text">Synced</span>
                <span class="sync-badge" id="sync-badge"></span>
            </div>
            <div class="date-display" id="current-date"></div>
            <button id="add-shot-btn" class="add-shot-btn">+ Shot</button>
        </div>
    </header>

    <!-- Phase 1B: Sync Queue Modal -->
    <div id="sync-queue-modal" class="sync-queue-modal">
        <div class="sync-queue-header">
            <h3>Sync Queue</h3>
            <button id="sync-queue-close" class="sync-queue-close"></button>
        </div>
        <div class="sync-queue-body" id="sync-queue-body">
            <div class="sync-queue-empty">No pending operations</div>
        </div>
        <div class="sync-queue-footer">
            <button id="sync-queue-clear-completed" class="sync-queue-clear-completed">Clear Completed</button>
            <button id="sync-queue-clear-failed" class="sync-queue-clear-failed">Clear Failed</button>
        </div>
    </div>

    <!-- Main Content Area -->
    <main id="main-content">
        <div class="loading" id="loading-screen">
            Loading Injection Tracker...
        </div>

        <!-- Summary Tab -->
        <div id="summary-tab" class="tab-content" style="display: none;">
            <div class="container">
                <!-- Weekly Insights Card -->
                <div id="weekly-insights" class="insight-card" style="display: none;">
                    <h3>This Week's Progress</h3>
                    <div class="insight-stat">
                        <span class="insight-label">Weight Change</span>
                        <span class="insight-value" id="insight-weight-change">--</span>
                        <span class="insight-trend" id="insight-weight-trend">--</span>
                    </div>
                    <div class="insight-stat">
                        <span class="insight-label">Adherence</span>
                        <span class="insight-value" id="insight-adherence">--</span>
                        <span class="insight-trend" id="insight-adherence-trend">--</span>
                    </div>
                    <div class="insight-stat">
                        <span class="insight-label">Avg Dose</span>
                        <span class="insight-value" id="insight-avg-dose">--</span>
                        <span class="insight-trend">--</span>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="total-shots">0</div>
                        <div class="stat-label">Total Shots</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="last-dose">0 mg</div>
                        <div class="stat-label">Last Dose</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="current-level">0%</div>
                        <div class="stat-label">Level at Last Shot</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="next-shot">0 days</div>
                        <div class="stat-label">Next Shot</div>
                    </div>
                </div>

                <div class="countdown-container">
                    <h3>Next Shot Due</h3>
                    <div class="countdown-circle">
                        <div class="countdown-content">
                            <div class="next-shot-day" id="next-shot-day">Saturday</div>
                            <div class="next-shot-date" id="next-shot-date">Jan 1</div>
                            <div class="next-shot-time" id="next-shot-time">8:00 AM</div>
                        </div>
                        <svg class="countdown-progress" width="200" height="200">
                            <circle cx="100" cy="100" r="90" stroke="#333333" stroke-width="8" fill="none"/>
                            <circle id="countdown-circle" cx="100" cy="100" r="90" stroke="#007AFF" stroke-width="8"
                                    fill="none" stroke-linecap="round" transform="rotate(-90 100 100)"
                                    stroke-dasharray="565.48" stroke-dashoffset="0"/>
                        </svg>
                    </div>
                </div>

                <div class="supply-forecast-container">
                    <h3>Supply Forecast</h3>
                    <div class="supply-forecast">
                        <div class="forecast-row">
                            <span class="forecast-label">Total Supply:</span>
                            <span class="forecast-value" id="total-supply">0 mg</span>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Planned Weekly Dose:</span>
                            <div class="forecast-input-group">
                                <input type="number" id="planned-dose" step="0.5" min="0" max="20" value="4.0" class="forecast-input">
                                <span class="forecast-unit">mg</span>
                            </div>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Supply Will Last:</span>
                            <div class="stat-value-container">
                                <span class="forecast-value" id="supply-duration">0 weeks</span>
                                <span id="supply-duration-validation-indicator"></span>
                            </div>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Estimated Run Out Date:</span>
                            <div class="stat-value-container">
                                <span class="forecast-value" id="run-out-date">--</span>
                                <span id="run-out-date-validation-indicator"></span>
                            </div>
                        </div>
                        <div class="forecast-row">
                            <span class="forecast-label">Days Until Reorder:</span>
                            <div class="stat-value-container">
                                <span class="forecast-value" id="reorder-days">--</span>
                                <span id="reorder-days-validation-indicator"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Shots Tab -->
        <div id="shots-tab" class="tab-content" style="display: none;">
            <div class="container">
                <div class="shots-header">
                    <h2>Shot History</h2>
                    <button id="add-shot-modal-btn" class="btn-primary">Add Shot</button>
                </div>
                <div id="shots-list" class="shots-list"></div>
            </div>
        </div>

        <!-- Results Tab -->
        <div id="results-tab" class="tab-content" style="display: none;">
            <div class="container">
                <!-- Results Header -->
                <div class="results-header">
                    <h2>Results</h2>
                    <button class="add-shot-btn-results" onclick="app.showAddInjectionModal()">
                        + Add shot
                    </button>
                </div>

                <!-- Time Period Segmented Control -->
                <div class="time-period-control">
                    <button class="period-btn active" data-months="1">1 month</button>
                    <button class="period-btn" data-months="3">3 months</button>
                    <button class="period-btn" data-months="6">6 months</button>
                    <button class="period-btn" data-months="all">All time</button>
                </div>

                <!-- Shots with Weight Chart -->
                <div class="chart-section">
                    <h3 class="chart-section-title">Shots with Weight</h3>
                    <div class="chart-container" id="shots-weight-chart-view">
                        <canvas id="shots-weight-chart"></canvas>
                    </div>
                </div>

                <!-- Weight Only Chart -->
                <div class="chart-section">
                    <h3 class="chart-section-title">Weight Trend</h3>
                    <div class="chart-container" id="weight-only-chart-view">
                        <canvas id="weight-only-chart"></canvas>
                    </div>
                </div>

                <div id="table-view" class="table-view" style="display: none;">
                    <div id="weight-table"></div>
                </div>

                <!-- Weight Change Section -->
                <div class="weight-change-section">
                    <div class="section-header">
                        <div class="section-title">
                            <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                                <path d="M2 17l10 5 10-5M2 12l10 5 10-5"/>
                            </svg>
                            <h3>Weight Change</h3>
                        </div>
                        <div class="date-range" id="date-range-display">Sep 27, 2025 - Oct 29</div>
                    </div>

                    <!-- Metric Cards Grid (2x3) -->
                    <div class="results-stats-grid">
                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                                </svg>
                                Total change
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="total-change">-11.3 kg</div>
                                <span id="total-change-validation-indicator"></span>
                            </div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                                    <circle cx="12" cy="7" r="4"/>
                                </svg>
                                Current BMI
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="current-bmi">--</div>
                                <span id="bmi-validation-indicator"></span>
                            </div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M12 6v6l4 2"/>
                                </svg>
                                Weight
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="current-weight">94.5 kg</div>
                                <span id="current-weight-validation-indicator"></span>
                            </div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <text x="12" y="16" text-anchor="middle" fill="currentColor" font-size="10">%</text>
                                </svg>
                                Percent
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="percent-change">-11%</div>
                                <span id="percent-change-validation-indicator"></span>
                            </div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 2v20M17 12H7M17 7H7M17 17H7"/>
                                </svg>
                                Weekly avg
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="weekly-avg">-2.5 kg/wk</div>
                                <span id="weekly-avg-validation-indicator"></span>
                            </div>
                        </div>

                        <div class="result-card">
                            <div class="result-label">
                                <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/>
                                </svg>
                                Progress
                            </div>
                            <div class="stat-value-container">
                                <div class="result-value" id="goal-progress">52%</div>
                                <span id="goal-progress-validation-indicator"></span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Goal Progress Card -->
                <div id="goal-progress-card" style="display: none; margin-top: 24px; background: linear-gradient(135deg, var(--card-bg) 0%, #2d2d2d 100%); border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: var(--spacing-lg);">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Goal Progress</h3>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-sm);">
                        <span style="color: var(--text-secondary); font-size: 14px;">
                            <span id="goal-start-weight">--</span> kg  <span id="goal-target-weight">--</span> kg
                        </span>
                        <span style="color: var(--text-primary); font-weight: 600; font-size: 16px;">
                            <span id="goal-progress-percent">0</span>%
                        </span>
                    </div>
                    <div style="width: 100%; height: 8px; background: var(--border-color); border-radius: 4px; overflow: hidden; margin-bottom: var(--spacing-md);">
                        <div id="goal-progress-bar" style="height: 100%; background: linear-gradient(90deg, var(--accent-color), #34C759); width: 0%; transition: width 0.5s ease;"></div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: var(--spacing-md);">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 4px;">Remaining</div>
                            <div style="color: var(--text-primary); font-weight: 600; font-size: 16px;" id="goal-remaining">-- kg</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 4px;">Weekly Avg</div>
                            <div style="color: var(--text-primary); font-weight: 600; font-size: 16px;" id="goal-weekly-rate">-- kg</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 4px;">Est. Date</div>
                            <div style="color: var(--text-primary); font-weight: 600; font-size: 16px;" id="goal-eta-date">--</div>
                        </div>
                    </div>
                    <p id="goal-message" style="margin-top: var(--spacing-md); padding: var(--spacing-sm); background: rgba(52, 199, 89, 0.1); border-radius: 6px; color: var(--success-color); font-size: 14px; text-align: center;">
                        Keep up the great work!
                    </p>
                </div>

                <h3 style="margin-top: 32px; margin-bottom: 16px;">Weight History</h3>
                <div id="weights-list" class="weights-list"></div>
            </div>
        </div>

        <!-- Inventory Tab -->
        <div id="inventory-tab" class="tab-content" style="display: none;">
            <div class="container">
                <h2>Vial Management</h2>
                <div class="inventory-header">
                    <button id="add-vial-btn" class="btn-primary">Add Vials to Stock</button>
                    <button id="activate-vial-btn" class="btn-secondary">Activate Vial</button>
                </div>
                <div id="vials-list" class="vials-list"></div>
                <div class="inventory-stats">
                    <div class="inventory-card">
                        <div class="inventory-value" id="total-stock">0</div>
                        <div class="inventory-label">Doses in Stock</div>
                    </div>
                    <div class="inventory-card">
                        <div class="inventory-value" id="days-remaining">0</div>
                        <div class="inventory-label">Days Remaining</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Tab -->
        <div id="settings-tab" class="tab-content" style="display: none;">
            <div class="container">
                <h2>Settings</h2>

                <!-- Cloud Sync Section -->
                <div class="settings-section" style="background: linear-gradient(135deg, var(--accent-color) 0%, #0051a8 100%); border-radius: var(--border-radius); padding: var(--spacing-lg); margin-bottom: var(--spacing-lg);">
                    <h3 style="margin-bottom: var(--spacing-sm);"> Cloud Sync</h3>
                    <p id="user-info" style="display: none; margin-bottom: var(--spacing-md); opacity: 0.9;"></p>
                    <button id="auth-button" class="btn-primary" style="width: 100%; background: white; color: var(--accent-color); font-weight: 600;">
                        Sign In with Google
                    </button>
                    <p style="margin-top: var(--spacing-sm); font-size: 0.85em; opacity: 0.8;">
                        Sign in to sync your data across devices and enable automatic backups
                    </p>
                </div>

                <div class="settings-section">
                    <h3>Injection Schedule</h3>
                    <label>
                        Injection Frequency:
                        <div class="setting-input-wrapper">
                            <select id="injection-frequency">
                                <option value="7">Weekly</option>
                                <option value="14">Bi-weekly</option>
                                <option value="21">Every 3 weeks</option>
                                <option value="28">Monthly</option>
                            </select>
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <label>
                        Default Dose (mg):
                        <div class="setting-input-wrapper">
                            <input type="number" id="default-dose" step="0.1" min="0" max="50" value="2.0">
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <label>
                        Injection Day:
                        <div class="setting-input-wrapper">
                            <select id="day-of-dose">
                                <option value="0">Sunday</option>
                                <option value="1">Monday</option>
                                <option value="2">Tuesday</option>
                                <option value="3">Wednesday</option>
                                <option value="4">Thursday</option>
                                <option value="5">Friday</option>
                                <option value="6" selected>Saturday</option>
                            </select>
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <label>
                        Height (cm):
                        <div class="setting-input-wrapper">
                            <input type="number" id="user-height" step="0.1" min="0" max="300" placeholder="Enter height">
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                    <label>
                        Goal Weight (kg):
                        <div class="setting-input-wrapper">
                            <input type="number" id="goal-weight" step="0.1" min="0" max="300" placeholder="Enter goal weight">
                            <span class="save-indicator">Saved</span>
                        </div>
                    </label>
                </div>
                <div class="settings-section">
                    <h3>Data Management</h3>
                    <button id="export-data-btn" class="btn-secondary">Export Data</button>
                    <button id="import-data-btn" class="btn-secondary">Import Data from File</button>
                </div>
                <div class="settings-section">
                    <h3> Cloud Backup</h3>
                    <div id="cloud-backup-info" style="margin-bottom: 16px; padding: 12px; background-color: var(--secondary-bg); border-radius: var(--border-radius-sm);">
                        <p style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">
                            Store a secure backup of all your data in the cloud (AWS S3).
                        </p>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span>Status:</span>
                            <span id="cloud-backup-status">Not authenticated</span>
                        </div>
                        <div id="cloud-backup-last" style="display: none; justify-content: space-between; margin-bottom: 8px;">
                            <span>Last Cloud Backup:</span>
                            <span id="cloud-backup-timestamp">Never</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-muted);">
                            <span>Next Auto-Backup:</span>
                            <span id="next-backup-date">-</span>
                        </div>
                    </div>
                    <button id="create-cloud-backup-btn" class="btn-primary" style="margin-bottom: 8px;" disabled>
                        Backup to Cloud
                    </button>
                    <p style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">
                         Cloud backups: Auto-backup every Monday at 9 AM. Keeps only 4 most recent backups. Sign in required.
                    </p>
                </div>

                <!-- Version Information -->
                <div class="settings-section">
                    <h3>Version Information</h3>
                    <div style="background-color: var(--secondary-bg); border-radius: var(--border-radius-sm); padding: 12px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px;">
                            <span style="color: var(--text-secondary);">Frontend:</span>
                            <span id="frontend-version" style="font-family: monospace; color: var(--text-primary);">-</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 14px;">
                            <span style="color: var(--text-secondary);">Backend:</span>
                            <span id="backend-version" style="font-family: monospace; color: var(--text-primary);">-</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Bottom Navigation -->
    <nav id="bottom-nav" class="bottom-nav">
        <button class="nav-btn active" data-tab="summary">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <path d="M3 9h18M9 21V9"/>
            </svg>
            <span class="nav-label">Summary</span>
        </button>
        <button class="nav-btn" data-tab="shots">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 2l4 4-4 4M10 8l-2 2 2 2"/>
                <path d="M22 6H10a8 8 0 00-8 8v0a2 2 0 002 2h10"/>
                <circle cx="18" cy="18" r="3"/>
            </svg>
            <span class="nav-label">Shots</span>
        </button>
        <button class="nav-btn" data-tab="results">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 3v18h18"/>
                <path d="M18 17l-5-5-4 4-4-7"/>
            </svg>
            <span class="nav-label">Results</span>
        </button>
        <button class="nav-btn" data-tab="inventory">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 16V8a2 2 0 00-1-1.73l-7-4a2 2 0 00-2 0l-7 4A2 2 0 003 8v8a2 2 0 001 1.73l7 4a2 2 0 002 0l7-4A2 2 0 0021 16z"/>
                <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
                <line x1="12" y1="22.08" x2="12" y2="12"/>
            </svg>
            <span class="nav-label">Inventory</span>
        </button>
        <button class="nav-btn" data-tab="settings">
            <svg class="nav-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.25m4.24 4.24l4.24 4.25M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.25"/>
            </svg>
            <span class="nav-label">Settings</span>
        </button>
    </nav>

    <!-- Modals -->
    <div id="modal-overlay" class="modal-overlay" style="display: none;">
        <!-- Add Shot Modal -->
        <div id="add-shot-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Add New Shot</h3>
                <button class="modal-close" data-modal="add-shot-modal">&times;</button>
            </div>
            <form id="add-shot-form">
                <div class="form-group">
                    <label for="shot-date">Date & Time</label>
                    <input type="datetime-local" id="shot-date" required>
                </div>
                <div class="form-group">
                    <label for="shot-dose">Dose (mg)</label>
                    <input type="number" id="shot-dose" step="0.1" min="0" max="50" required>
                </div>
                <div class="form-group">
                    <label for="shot-site">Injection Site</label>
                    <select id="shot-site" required>
                        <option value="">Select injection site</option>
                        <option value="left_thigh">Left Thigh</option>
                        <option value="right_thigh">Right Thigh</option>
                        <option value="left_arm">Left Arm</option>
                        <option value="right_arm">Right Arm</option>
                        <option value="abdomen_left">Abdomen Left</option>
                        <option value="abdomen_right">Abdomen Right</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="shot-vial">Vial</label>
                    <select id="shot-vial" required>
                        <option value="">Select vial</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="shot-notes">Notes - Optional</label>
                    <textarea id="shot-notes" placeholder="Side effects, timing, etc."></textarea>
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Add Shot</button>
                    <button type="button" class="btn-secondary" data-modal="add-shot-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Add Vial Modal -->
        <div id="add-vial-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Add New Vials to Dry Stock</h3>
                <button class="modal-close" data-modal="add-vial-modal">&times;</button>
            </div>
            <form id="add-vial-form">
                <div class="form-group">
                    <label for="vial-order-date">Order Date</label>
                    <input type="date" id="vial-order-date" required>
                </div>
                <div class="form-group">
                    <label for="vial-supplier">Supplier</label>
                    <input type="text" id="vial-supplier" placeholder="Pharmacy name">
                </div>
                <div class="form-group">
                    <label for="vial-mg">mg per Vial</label>
                    <input type="number" id="vial-mg" step="0.1" min="0" required placeholder="10" value="10">
                </div>
                <div class="form-group">
                    <label for="vial-quantity">Number of Vials</label>
                    <input type="number" id="vial-quantity" min="1" required placeholder="2" value="1">
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Add to Dry Stock</button>
                    <button type="button" class="btn-secondary" data-modal="add-vial-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Edit Vial Modal -->
        <div id="edit-vial-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Edit Vial</h3>
                <button class="modal-close" data-modal="edit-vial-modal">&times;</button>
            </div>
            <form id="edit-vial-form">
                <input type="hidden" id="edit-vial-id">
                <div class="form-group">
                    <label for="edit-vial-order-date">Order Date</label>
                    <input type="date" id="edit-vial-order-date" required>
                </div>
                <div class="form-group">
                    <label for="edit-vial-supplier">Supplier</label>
                    <input type="text" id="edit-vial-supplier" placeholder="Pharmacy name">
                </div>
                <div class="form-group">
                    <label for="edit-vial-mg">mg per Vial</label>
                    <input type="number" id="edit-vial-mg" step="0.1" min="0" required placeholder="10">
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Save Changes</button>
                    <button type="button" class="btn-secondary" data-modal="edit-vial-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Activate Vial Modal -->
        <div id="activate-vial-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Activate Vial</h3>
                <button class="modal-close" data-modal="activate-vial-modal">&times;</button>
            </div>
            <form id="activate-vial-form">
                <div class="form-group">
                    <label for="activate-vial-id">Select Vial to Activate</label>
                    <select id="activate-vial-id" required>
                        <option value="">Select a vial to activate...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="activate-bac-water">BAC Water (ml)</label>
                    <input type="number" id="activate-bac-water" step="0.1" min="0" required placeholder="1.0" value="1.0">
                </div>
                <div class="form-group">
                    <label for="activate-reconstitution-date">Reconstitution Date & Time</label>
                    <input type="datetime-local" id="activate-reconstitution-date" required>
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Activate Vial</button>
                    <button type="button" class="btn-secondary" data-modal="activate-vial-modal">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Add Weight Modal -->
        <div id="add-weight-modal" class="modal" style="display: none;">
            <div class="modal-header">
                <h3 class="modal-title">Add Weight Entry</h3>
                <button class="modal-close" data-modal="add-weight-modal">&times;</button>
            </div>
            <form id="add-weight-form">
                <div class="form-group">
                    <label for="weight-date">Date & Time</label>
                    <input type="datetime-local" id="weight-date" required>
                </div>
                <div class="form-group">
                    <label for="weight-kg">Weight (kg)</label>
                    <input type="number" id="weight-kg" step="0.1" min="0" max="500" required>
                </div>
                <div class="form-group">
                    <label for="weight-body-fat">Body Fat % - Optional</label>
                    <input type="number" id="weight-body-fat" step="0.1" min="0" max="100">
                </div>
                <div class="form-group">
                    <button type="submit" class="btn-primary">Add Weight</button>
                    <button type="button" class="btn-secondary" data-modal="add-weight-modal">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // ====================================
        // VERSION INFORMATION
        // ====================================
        const APP_VERSION = {
            frontend: '1.1.0',
            timestamp: '2025-11-08'
        };

        // ====================================
        // DATA STRUCTURES & STORAGE SYSTEM
        // ====================================

        class InjectionTracker {
            constructor() {
                this.data = {
                    injections: [],
                    vials: [],
                    weights: [],
                    settings: {
                        injectionFrequency: 7,
                        defaultDose: 2.0,
                        dayOfDose: 6, // Saturday (0=Sunday, 6=Saturday)
                        heightCm: null,
                        goalWeightKg: null,
                        units: 'metric',
                        lastSync: null
                    }
                };
                this.charts = {};
                this.timeRange = 30; // Default to 30 days
                this._isSyncing = false;  // Guard against concurrent syncs
                this._lastSyncTime = 0;    // Debounce rapid syncs
                // Phase 1 Fix: Use persistent pending deletions manager instead of in-memory Set
                this._pendingDeletions = this.initPendingDeletions();
                // Phase 1B: Initialize sync queue
                this.syncQueue = null; // Will be initialized after auth
                this.init();
            }

            // Initialize pending deletions manager
            initPendingDeletions() {
                const stored = localStorage.getItem('pending_deletions');
                const deletions = stored ? JSON.parse(stored) : {};

                // Cleanup expired deletions
                const now = Date.now();
                for (const [id, expiryTime] of Object.entries(deletions)) {
                    if (now > expiryTime) {
                        delete deletions[id];
                    }
                }
                localStorage.setItem('pending_deletions', JSON.stringify(deletions));

                // Return object with Set-like interface
                return {
                    deletions,
                    add: (id, ttlMs = 120000) => {
                        deletions[id] = Date.now() + ttlMs;
                        localStorage.setItem('pending_deletions', JSON.stringify(deletions));
                        console.log(`[PendingDeletions] Added ${id} (expires in ${ttlMs/1000}s)`);
                    },
                    has: (id) => {
                        if (!(id in deletions)) return false;
                        if (Date.now() > deletions[id]) {
                            delete deletions[id];
                            localStorage.setItem('pending_deletions', JSON.stringify(deletions));
                            return false;
                        }
                        return true;
                    },
                    delete: (id) => {
                        if (id in deletions) {
                            delete deletions[id];
                            localStorage.setItem('pending_deletions', JSON.stringify(deletions));
                            console.log(`[PendingDeletions] Removed ${id}`);
                        }
                    },
                    clear: () => {
                        Object.keys(deletions).forEach(k => delete deletions[k]);
                        localStorage.setItem('pending_deletions', JSON.stringify(deletions));
                    },
                    size: () => Object.keys(deletions).length
                };
            }

            // Initialize the application
            async init() {
                try {
                    await this.loadData();
                    this.setupEventListeners();
                    this.setupUXEnhancements(); // NEW: Setup all UX improvements
                    this.updateUI();
                    this.startCountdownTimer();
                    this.validateDataIntegrity();
                    this.updateWeeklyInsights(); // NEW: Update insights on load
                } catch (error) {
                    console.error('Error during initialization:', error);
                } finally {
                    // Always hide loading screen, even if there's an error
                    this.hideLoadingScreen();
                }
            }

            // ====================================
            // UX ENHANCEMENTS
            // ====================================

            setupUXEnhancements() {
                this.setupFAB();
                this.setupOfflineIndicator();
                this.setupPullToRefresh();
                this.setupKeyboardShortcuts();
                this.setupTimeRangeSelector();
                this.setupCountdownInteraction();
                this.setupSwipeToDelete();
                this.setupSyncStatusUI(); // Phase 1B: Sync status indicator
            }

            // Floating Action Button (context-aware)
            setupFAB() {
                const fab = document.getElementById('fab-button');
                if (fab) {
                    fab.addEventListener('click', () => {
                        this.triggerHaptic();

                        // Get active tab to determine which modal to open
                        const activeTab = document.querySelector('.nav-btn.active');
                        const currentTab = activeTab ? activeTab.dataset.tab : 'summary';

                        // Open appropriate modal based on current tab
                        switch (currentTab) {
                            case 'shots':
                                this.openModal('add-shot-modal');
                                break;
                            case 'results':
                                this.openModal('add-weight-modal');
                                break;
                            case 'inventory':
                                this.openModal('add-vial-modal');
                                break;
                            case 'summary':
                                // On summary, default to adding a shot
                                this.openModal('add-shot-modal');
                                break;
                            case 'settings':
                                // On settings, hide FAB or default to shot
                                this.openModal('add-shot-modal');
                                break;
                            default:
                                this.openModal('add-shot-modal');
                                break;
                        }
                    });
                }
            }

            // Haptic Feedback
            triggerHaptic(type = 'light') {
                if ('vibrate' in navigator) {
                    const patterns = {
                        light: 10,
                        medium: 20,
                        heavy: 30
                    };
                    navigator.vibrate(patterns[type] || 10);
                }
            }

            // Offline/Online Indicators
            setupOfflineIndicator() {
                const indicator = document.getElementById('offline-indicator');

                window.addEventListener('online', () => {
                    if (indicator) indicator.classList.remove('show');
                    this.showNotification('Back online - syncing data...', 'success');
                    this.syncFromCloud();
                });

                window.addEventListener('offline', () => {
                    if (indicator) indicator.classList.add('show');
                    this.showNotification('Offline - changes saved locally', 'warning');
                });
            }

            // Pull to Refresh (DISABLED - element removed from DOM)
            setupPullToRefresh() {
                // Disabled to prevent "Refreshing..." indicator from appearing
                // Pull-to-refresh functionality removed for better UX
                console.log('Pull-to-refresh disabled');
            }

            // Keyboard Shortcuts
            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Ignore if typing in input/textarea
                    if (e.target.matches('input, textarea')) return;

                    // Cmd/Ctrl + N: New shot
                    if ((e.metaKey || e.ctrlKey) && e.key === 'n') {
                        e.preventDefault();
                        this.triggerHaptic();
                        this.openModal('add-shot-modal');
                    }

                    // Cmd/Ctrl + W: New weight
                    if ((e.metaKey || e.ctrlKey) && e.key === 'w') {
                        e.preventDefault();
                        this.triggerHaptic();
                        this.openModal('add-weight-modal');
                    }

                    // Number keys 1-5: Switch tabs
                    if (/[1-5]/.test(e.key)) {
                        e.preventDefault();
                        const tabs = ['summary', 'shots', 'results', 'inventory', 'settings'];
                        this.switchTab(tabs[parseInt(e.key) - 1]);
                    }
                });
            }

            setupTimeRangeSelector() {
                const buttons = document.querySelectorAll('.period-btn');
                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.triggerHaptic('light');
                        buttons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        const months = btn.dataset.months;
                        // Convert months to days for internal time range
                        if (months === 'all') {
                            this.timeRange = 'all';
                        } else {
                            const monthsNum = parseInt(months);
                            this.timeRange = monthsNum * 30; // Approximate days per month
                        }

                        // Update stats with new time range
                        this.updateWeightStats();

                        // Update chart with new time range (always show combined weight + dose labels)
                        this.updateWeightChart('combined');
                    });
                });
            }

            switchChartView(view) {
                const chartView = document.getElementById('chart-view');
                const tableView = document.getElementById('table-view');

                if (view === 'table') {
                    chartView.style.display = 'none';
                    tableView.style.display = 'block';
                    this.renderWeightTable();
                } else {
                    chartView.style.display = 'block';
                    tableView.style.display = 'none';
                    this.updateWeightChart(view);
                }
            }

            renderWeightTable() {
                const tableDiv = document.getElementById('weight-table');
                if (!tableDiv) return;

                const sortedWeights = [...this.data.weights].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                let html = `
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border-color);">
                                <th style="padding: 12px; text-align: left; color: var(--text-secondary);">Date</th>
                                <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Weight (kg)</th>
                                <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Change</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                sortedWeights.forEach((weight, idx) => {
                    const date = new Date(weight.timestamp).toLocaleDateString();
                    const nextWeight = sortedWeights[idx + 1];
                    const change = nextWeight ? (weight.weight_kg - nextWeight.weight_kg).toFixed(1) : '--';
                    const changeColor = change > 0 ? 'var(--danger-color)' : change < 0 ? 'var(--success-color)' : 'var(--text-secondary)';

                    html += `
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 12px; color: var(--text-primary);">${date}</td>
                            <td style="padding: 12px; text-align: right; color: var(--text-primary); font-weight: 600;">${weight.weight_kg.toFixed(1)}</td>
                            <td style="padding: 12px; text-align: right; color: ${changeColor}; font-weight: 600;">${change !== '--' ? (change > 0 ? '+' : '') + change : '--'}</td>
                        </tr>
                    `;
                });

                html += `
                        </tbody>
                    </table>
                `;

                tableDiv.innerHTML = html;
            }

            // Enhanced Countdown Interaction
            setupCountdownInteraction() {
                const countdown = document.querySelector('.countdown-circle');
                if (countdown) {
                    countdown.addEventListener('click', () => {
                        this.triggerHaptic('medium');
                        this.openModal('add-shot-modal');
                    });
                }
            }

            // Swipe to Delete
            setupSwipeToDelete() {
                // Will be applied to dynamically created list items
                this.swipeToDeleteEnabled = true;
            }

            // Phase 1B: Sync Status UI
            setupSyncStatusUI() {
                const syncStatus = document.getElementById('sync-status');
                const syncQueueModal = document.getElementById('sync-queue-modal');
                const syncQueueClose = document.getElementById('sync-queue-close');
                const clearCompleted = document.getElementById('sync-queue-clear-completed');
                const clearFailed = document.getElementById('sync-queue-clear-failed');

                if (!syncStatus || !syncQueueModal) return;

                // Click sync status to open modal
                syncStatus.addEventListener('click', () => {
                    syncQueueModal.classList.toggle('open');
                    this.updateSyncQueueModal();
                });

                // Close modal
                syncQueueClose.addEventListener('click', () => {
                    syncQueueModal.classList.remove('open');
                });

                // Click outside to close
                document.addEventListener('click', (e) => {
                    if (!syncStatus.contains(e.target) && !syncQueueModal.contains(e.target)) {
                        syncQueueModal.classList.remove('open');
                    }
                });

                // Clear completed button
                clearCompleted.addEventListener('click', () => {
                    if (this.syncQueue) {
                        this.syncQueue.clearCompleted();
                        this.updateSyncQueueModal();
                    }
                });

                // Clear failed button
                clearFailed.addEventListener('click', () => {
                    if (this.syncQueue) {
                        this.syncQueue.clearFailed();
                        this.updateSyncQueueModal();
                    }
                });

                // Listen for queue updates
                window.addEventListener('sync-queue-updated', (e) => {
                    this.updateSyncStatus(e.detail);
                    if (syncQueueModal.classList.contains('open')) {
                        this.updateSyncQueueModal();
                    }
                });

                // Listen for sync failures
                window.addEventListener('sync-failure', (e) => {
                    console.error('[SyncUI] Sync failure:', e.detail);
                    // Could show a toast notification here
                });

                // Update status every 5 seconds
                setInterval(() => {
                    if (this.syncQueue) {
                        const status = this.syncQueue.getStatus();
                        this.updateSyncStatus(status);
                    }
                }, 5000);

                // Initial update
                if (this.syncQueue) {
                    const status = this.syncQueue.getStatus();
                    this.updateSyncStatus(status);
                }
            }

            updateSyncStatus(status) {
                const syncStatusEl = document.getElementById('sync-status');
                const syncText = syncStatusEl.querySelector('.sync-text');
                const syncBadge = document.getElementById('sync-badge');

                if (!syncStatusEl || !syncText || !syncBadge) return;

                // Remove all state classes
                syncStatusEl.classList.remove('synced', 'syncing', 'pending', 'error', 'offline');

                // Determine state
                if (!navigator.onLine) {
                    syncStatusEl.classList.add('offline');
                    syncText.textContent = 'Offline';
                    syncBadge.textContent = status.pending > 0 ? status.pending : '';
                } else if (status.isProcessing) {
                    syncStatusEl.classList.add('syncing');
                    syncText.textContent = 'Syncing...';
                    syncBadge.textContent = '';
                } else if (status.failed > 0) {
                    syncStatusEl.classList.add('error');
                    syncText.textContent = 'Sync Error';
                    syncBadge.textContent = status.failed;
                } else if (status.pending > 0) {
                    syncStatusEl.classList.add('pending');
                    syncText.textContent = `${status.pending} Pending`;
                    syncBadge.textContent = status.pending;
                } else {
                    syncStatusEl.classList.add('synced');
                    syncText.textContent = 'Synced';
                    syncBadge.textContent = '';
                }
            }

            updateSyncQueueModal() {
                const syncQueueBody = document.getElementById('sync-queue-body');
                if (!syncQueueBody || !this.syncQueue) return;

                const operations = this.syncQueue.getOperations();

                if (operations.length === 0) {
                    syncQueueBody.innerHTML = '<div class="sync-queue-empty">No pending operations</div>';
                    return;
                }

                syncQueueBody.innerHTML = operations.map(op => {
                    const entityName = op.entity.charAt(0).toUpperCase() + op.entity.slice(1);
                    const actionName = op.type.charAt(0).toUpperCase() + op.type.slice(1);
                    const timeSince = this.formatTimeSince(op.addedAt);

                    return `
                        <div class="sync-queue-item ${op.status}">
                            <div class="sync-queue-item-header">
                                <span class="sync-queue-item-type">${actionName} ${entityName}</span>
                                <span class="sync-queue-item-status ${op.status}">${op.status}</span>
                            </div>
                            <div class="sync-queue-item-details">
                                ${op.retryCount > 0 ? `Attempt ${op.retryCount + 1}/${this.syncQueue.retryDelays.length}  ` : ''}
                                ${timeSince}
                            </div>
                            ${op.error ? `<div class="sync-queue-item-error">Error: ${op.error}</div>` : ''}
                            ${op.status === 'failed' ? `
                                <div class="sync-queue-item-actions">
                                    <button class="sync-queue-item-retry" onclick="app.retrySyncOperation('${op.id}')">
                                        Retry Now
                                    </button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            }

            retrySyncOperation(operationId) {
                if (this.syncQueue) {
                    this.syncQueue.retryOperation(operationId);
                    this.updateSyncQueueModal();
                }
            }

            formatTimeSince(timestamp) {
                const seconds = Math.floor((Date.now() - timestamp) / 1000);
                if (seconds < 60) return `${seconds}s ago`;
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                return `${hours}h ago`;
            }

            addSwipeToDeleteHandlers(element) {
                if (!this.swipeToDeleteEnabled) return;

                let touchStartX = 0;
                let touchEndX = 0;
                const swipeThreshold = 80;

                element.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    element.classList.add('swiping');
                }, { passive: true });

                element.addEventListener('touchmove', (e) => {
                    touchEndX = e.touches[0].clientX;
                    const swipeDistance = touchStartX - touchEndX;

                    if (swipeDistance > 0 && swipeDistance < 100) {
                        element.style.transform = `translateX(-${swipeDistance}px)`;
                    }
                }, { passive: true });

                element.addEventListener('touchend', () => {
                    element.classList.remove('swiping');
                    const swipeDistance = touchStartX - touchEndX;

                    if (swipeDistance > swipeThreshold) {
                        element.classList.add('swiped');
                        element.style.transform = `translateX(-80px)`;
                        this.triggerHaptic('medium');
                    } else {
                        element.classList.remove('swiped');
                        element.style.transform = '';
                    }

                    touchStartX = 0;
                    touchEndX = 0;
                }, { passive: true });
            }

            // Weekly Insights
            updateWeeklyInsights() {
                const insightsCard = document.getElementById('weekly-insights');
                if (!insightsCard) return;

                const now = new Date();
                const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

                // Get this week's weights
                const weekWeights = this.data.weights.filter(w =>
                    new Date(w.timestamp) >= oneWeekAgo
                ).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                // Get this week's injections
                const weekInjections = this.data.injections.filter(i =>
                    new Date(i.timestamp) >= oneWeekAgo
                );

                if (weekWeights.length < 2 && weekInjections.length === 0) {
                    insightsCard.style.display = 'none';
                    return;
                }

                insightsCard.style.display = 'block';

                // Weight change
                if (weekWeights.length >= 2) {
                    const firstWeight = weekWeights[0].weight_kg;
                    const lastWeight = weekWeights[weekWeights.length - 1].weight_kg;
                    const change = lastWeight - firstWeight;

                    document.getElementById('insight-weight-change').textContent =
                        `${change >= 0 ? '+' : ''}${change.toFixed(1)} kg`;

                    const trendEl = document.getElementById('insight-weight-trend');
                    if (change < 0) {
                        trendEl.textContent = ` ${Math.abs(change).toFixed(1)} kg`;
                        trendEl.classList.remove('negative');
                    } else {
                        trendEl.textContent = ` ${change.toFixed(1)} kg`;
                        trendEl.classList.add('negative');
                    }
                } else {
                    document.getElementById('insight-weight-change').textContent = '--';
                    document.getElementById('insight-weight-trend').textContent = '--';
                }

                // Adherence
                const expectedInjections = Math.floor(7 / this.data.settings.injectionFrequency);
                const adherence = expectedInjections > 0 ?
                    Math.round((weekInjections.length / expectedInjections) * 100) : 0;

                document.getElementById('insight-adherence').textContent =
                    `${adherence}%`;
                document.getElementById('insight-adherence-trend').textContent =
                    adherence >= 100 ? ' On track' : ' Below target';

                // Average dose
                if (weekInjections.length > 0) {
                    const avgDose = weekInjections.reduce((sum, inj) => sum + inj.dose_mg, 0) / weekInjections.length;
                    document.getElementById('insight-avg-dose').textContent =
                        `${avgDose.toFixed(1)} mg`;
                } else {
                    document.getElementById('insight-avg-dose').textContent = '--';
                }
            }

            // ====================================
            // DATA MANAGEMENT
            // ====================================

            async loadData() {
                try {
                    const stored = localStorage.getItem('injectionTrackerData');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.data = { ...this.data, ...data };

                        // Normalize vial data formats (fix mixed camelCase/snake_case)
                        this.normalizeVialData();
                    } else {
                        // Check if we should load sample data (not in test mode)
                        const urlParams = new URLSearchParams(window.location.search);
                        if (!urlParams.get('test')) {
                            // Load sample data for demo purposes
                            this.loadSampleData();
                        }
                    }
                } catch (error) {
                    console.error('Error loading data:', error);
                    // Load sample data if there's an error (unless in test mode)
                    const urlParams = new URLSearchParams(window.location.search);
                    if (!urlParams.get('test')) {
                        this.loadSampleData();
                    }
                }
            }

            /**
             * Normalize vial data to consistent snake_case format
             * Fixes mixed API format (camelCase) and app format (snake_case)
             */
            normalizeVialData() {
                if (!this.data.vials || this.data.vials.length === 0) return;

                this.data.vials = this.data.vials.map(vial => {
                    // If vial is in API format (has 'id' instead of 'vial_id'), convert it
                    if (vial.id && !vial.vial_id) {
                        console.log('Converting vial from API format to app format:', vial.id);
                        return {
                            vial_id: vial.id,
                            order_date: vial.startDate,
                            total_mg: vial.initialVolumeMl * vial.concentrationMgPerMl,
                            bac_water_ml: vial.initialVolumeMl,
                            concentration_mg_per_ml: vial.concentrationMgPerMl,
                            current_volume_ml: vial.currentVolumeMl,
                            used_volume_ml: vial.usedVolumeMl,
                            status: vial.status,
                            supplier: vial.source || '',
                            notes: vial.notes || '',
                            reconstitution_date: vial.startDate
                        };
                    }
                    // Already in correct format, but sync property names (Hotfix)
                    // Ensure both current_volume_ml and remaining_ml are synced
                    if (vial.remaining_ml !== undefined && vial.current_volume_ml === undefined) {
                        vial.current_volume_ml = vial.remaining_ml;
                        console.log(`Synced current_volume_ml for vial ${vial.vial_id || vial.id}`);
                    } else if (vial.current_volume_ml !== undefined && vial.remaining_ml === undefined) {
                        vial.remaining_ml = vial.current_volume_ml;
                        console.log(`Synced remaining_ml for vial ${vial.vial_id || vial.id}`);
                    }

                    // Fix missing expiration dates for dry stock vials
                    if (vial.status === 'dry_stock' && !vial.expiration_date && vial.order_date) {
                        vial.expiration_date = this.calculateExpirationDate(null, vial.order_date);
                        console.log(`Fixed expiration for dry stock vial ${vial.vial_id || vial.id}`);
                    }

                    return vial;
                });

                console.log('Vial data normalized');
            }

            // ====================================
            // VIAL HELPER METHODS (Phase 1 Fix)
            // ====================================

            /**
             * Get vial ID consistently regardless of format
             * Handles both vial_id (frontend) and id (API) formats
             */
            getVialId(vial) {
                return vial.vial_id || vial.id;
            }

            /**
             * Find vial by ID, handling both frontend and API formats
             */
            findVialById(vialId) {
                if (!vialId) return null;
                return this.data.vials.find(v => this.getVialId(v) === vialId);
            }

            // ====================================
            // DATA MERGE HELPER
            // ====================================

            mergeArrays(localData, cloudData, keyField) {
                // Intelligent merge: prefer local data for items not yet in cloud
                const merged = new Map();

                // First, add all cloud items (source of truth for synced data)
                // BUT exclude items that are pending deletion
                cloudData.forEach(item => {
                    const itemId = item[keyField];
                    if (!this._pendingDeletions.has(itemId)) {
                        merged.set(itemId, item);
                    } else {
                        console.log(`Skipping ${itemId} from cloud sync - pending deletion`);
                    }
                });

                // Then add local items that aren't in cloud yet
                // These are likely pending sync or were just added
                localData.forEach(item => {
                    const itemId = item[keyField];
                    const cloudItem = merged.get(itemId);
                    if (!cloudItem && !this._pendingDeletions.has(itemId)) {
                        // Item exists locally but not in cloud - keep it (pending sync)
                        merged.set(itemId, item);
                    }
                    // If item exists in cloud, cloud version is source of truth
                });

                return Array.from(merged.values()).sort(
                    (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
                );
            }

            async syncFromCloud() {
                // Guard against concurrent syncs
                if (this._isSyncing) {
                    console.log('Sync already in progress, skipping...');
                    return;
                }

                // Debounce rapid syncs (wait at least 2 seconds between syncs)
                const now = Date.now();
                if (now - this._lastSyncTime < 2000) {
                    console.log('Sync called too soon after previous sync, skipping...');
                    return;
                }

                // Check if user is authenticated
                if (!authManager || !authManager.isAuthenticated()) {
                    console.log('User not authenticated, skipping cloud sync');
                    return;
                }

                this._isSyncing = true;
                this._lastSyncTime = now;

                try {
                    console.log('Syncing data from cloud...');

                    // Fetch all data from API
                    const [injectionsAPI, weightsAPI, vialsAPI] = await Promise.all([
                        apiClient.getInjections(),
                        apiClient.getWeights(),
                        apiClient.getVials()
                    ]);

                    console.log(`Fetched from cloud: ${injectionsAPI.length} injections, ${weightsAPI.length} weights, ${vialsAPI.length} vials`);

                    // Map API format (camelCase) to app format (snake_case)
                    const cloudInjections = injectionsAPI.map(inj => ({
                        id: inj.id,
                        timestamp: inj.timestamp,
                        dose_mg: inj.doseMg,
                        injection_site: inj.site,
                        vial_id: inj.vialId,
                        notes: inj.notes || ''
                    }));

                    const cloudWeights = weightsAPI.map(wt => ({
                        id: wt.id,
                        timestamp: wt.timestamp,
                        weight_kg: wt.weightKg,
                        notes: wt.notes || ''
                    }));

                    const cloudVials = vialsAPI.map(vial => ({
                        vial_id: vial.id,
                        order_date: vial.startDate,
                        total_mg: vial.initialVolumeMl * vial.concentrationMgPerMl,
                        bac_water_ml: vial.initialVolumeMl,
                        concentration_mg_per_ml: vial.concentrationMgPerMl,
                        current_volume_ml: vial.currentVolumeMl,
                        used_volume_ml: vial.usedVolumeMl,
                        status: vial.status,
                        supplier: vial.source || '',
                        notes: vial.notes || '',
                        reconstitution_date: vial.startDate
                    }));

                    // MERGE cloud data with local data (prevents losing pending items)
                    this.data.injections = this.mergeArrays(this.data.injections, cloudInjections, 'id');
                    this.data.weights = this.mergeArrays(this.data.weights, cloudWeights, 'id');
                    this.data.vials = this.mergeArrays(this.data.vials, cloudVials, 'vial_id');

                    // Save to localStorage (without showing indicator - this is a sync, not a user save)
                    this.saveData(false);

                    // Update UI
                    this.updateUI();

                    console.log('Cloud sync complete');
                } catch (error) {
                    console.error('Error syncing from cloud:', error);
                    // Don't rethrow - sync failures should be silent
                } finally {
                    this._isSyncing = false;
                }
            }

            loadSampleData() {
                const now = new Date();

                // Add a sample vial
                const sampleVial = {
                    order_date: new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 15 days ago
                    supplier: 'Sample Pharmacy',
                    lot_number: 'LOT123456',
                    total_mg: 15,
                    bac_water_ml: 1.5,
                    reconstitution_date: new Date(now.getTime() - 10 * 24 * 60 * 60 * 1000).toISOString() // 10 days ago
                };

                this.addVial(sampleVial);

                // Add sample weights
                for (let i = 0; i < 8; i++) {
                    const weightDate = new Date(now.getTime() - (i * 3.5 * 24 * 60 * 60 * 1000)); // Every 3.5 days
                    this.addWeight({
                        timestamp: weightDate.toISOString(),
                        weight_kg: 85 - (i * 0.3) + (Math.random() * 0.4 - 0.2), // Gradual weight loss with some variation
                        source: 'manual'
                    });
                }

                // Add sample injections (use full vial to make it realistic)
                const sampleDoses = [2.0, 2.5, 3.0, 3.5, 4.0]; // Total = 15mg (use full vial)
                for (let i = 0; i < sampleDoses.length; i++) {
                    const injectionDate = new Date(now.getTime() - (i * 7 * 24 * 60 * 60 * 1000)); // Weekly
                    const vialId = this.data.vials[0]?.vial_id;
                    if (vialId) {
                        this.data.injections.push({
                            id: this.generateId(),
                            timestamp: injectionDate.toISOString(),
                            dose_mg: sampleDoses[i],
                            injection_site: ['right_abdomen', 'left_abdomen', 'right_thigh', 'left_thigh', 'right_arm'][i % 5],
                            vial_id: vialId,
                            weight_kg: null,
                            weight_source: 'manual',
                            notes: i === 0 ? 'Final injection - vial finished' : i === sampleDoses.length - 1 ? 'First injection - starting treatment' : '',
                            medication_level_at_injection: i > 0 ? sampleDoses[i-1] : 0
                        });
                        this.updateVialUsage(vialId, sampleDoses[i]);
                    }
                }

                this.data.injections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Save the sample data to localStorage
                this.saveData();
            }

            async saveData(showIndicator = true) {
                try {
                    if (window.backupManager) {
                        await backupManager.saveData(this.data);
                    } else {
                        // Fallback to simple localStorage if backup manager not ready
                        localStorage.setItem('injectionTrackerData', JSON.stringify(this.data));
                    }
                    if (showIndicator) {
                        this.showSaveIndicator();
                    }
                } catch (error) {
                    console.error('Error saving data:', error);
                }
            }

            showSaveIndicator() {
                const indicator = document.getElementById('save-indicator');
                if (indicator) {
                    indicator.style.display = 'block';
                    indicator.style.animation = 'fadeInScale 0.2s ease-out';

                    clearTimeout(this.saveIndicatorTimeout);
                    this.saveIndicatorTimeout = setTimeout(() => {
                        indicator.style.animation = 'fadeOutScale 0.2s ease-in';
                        setTimeout(() => {
                            indicator.style.display = 'none';
                        }, 200);
                    }, 1500);
                }
            }

            // ====================================
            // INJECTION MANAGEMENT
            // ====================================

            async addInjection(injection) {
                const newInjection = {
                    id: this.generateId(),
                    timestamp: injection.timestamp || new Date().toISOString(),
                    dose_mg: parseFloat(injection.dose_mg),
                    injection_site: injection.injection_site,
                    vial_id: injection.vial_id,
                    weight_kg: injection.weight_kg ? parseFloat(injection.weight_kg) : null,
                    weight_source: injection.weight_source || 'manual',
                    notes: injection.notes || '',
                    medication_level_at_injection: this.calculateCurrentMedicationLevel(injection.timestamp).value || 0
                };

                this.data.injections.push(newInjection);
                this.data.injections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                await this.updateVialUsage(injection.vial_id, injection.dose_mg);
                this.saveData();
                this.updateUI();

                // Check for milestones and celebrate
                this.checkMilestones();

                // Push to sync queue if authenticated (Phase 1B: Reliable sync with retry)
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'create',
                        entity: 'injection',
                        localId: newInjection.id,
                        data: {
                            id: newInjection.id,
                            timestamp: newInjection.timestamp,
                            doseMg: newInjection.dose_mg,
                            site: newInjection.injection_site,
                            vialId: newInjection.vial_id,
                            notes: newInjection.notes
                        }
                    });
                    console.log('Injection added to sync queue');
                }
            }

            async updateVialUsage(vialId, doseMg) {
                const vial = this.findVialById(vialId);
                if (vial) {
                    const doseVolumeML = doseMg / vial.concentration_mg_ml;
                    vial.remaining_ml = Math.max(0, vial.remaining_ml - doseVolumeML);
                    vial.current_volume_ml = vial.remaining_ml; // Sync property for consistency (Hotfix)
                    vial.doses_used++;

                    // Check if vial has less than next required dose
                    const plannedDose = parseFloat(document.getElementById('planned-dose')?.value || 4.0);
                    const remainingMg = vial.remaining_ml * vial.concentration_mg_ml;

                    if (remainingMg < plannedDose && remainingMg > 0) {
                        // Mark vial as empty if it can't provide the next dose
                        vial.status = 'insufficient';
                        vial.remaining_ml = 0;
                        vial.current_volume_ml = 0; // Sync property (Hotfix)
                    } else if (vial.remaining_ml <= 0) {
                        vial.status = 'empty';
                    }

                    // Push vial update to sync queue (Phase 1B: Reliable sync with retry)
                    if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                        this.syncQueue.add({
                            type: 'update',
                            entity: 'vial',
                            localId: vialId,
                            data: {
                                id: vialId,
                                currentVolumeMl: vial.remaining_ml,
                                usedVolumeMl: vial.bac_water_ml - vial.remaining_ml,
                                status: vial.status
                            }
                        });
                        console.log('Vial update added to sync queue');
                    }
                }
            }

            async reverseVialUsage(vialId, doseMg) {
                const vial = this.findVialById(vialId);
                if (!vial) {
                    console.log(`Vial ${vialId} not found for usage reversal`);
                    return;
                }

                const concentration = vial.concentration_mg_per_ml || vial.concentration_mg_ml;
                const doseVolumeML = doseMg / concentration;

                // Add back the dose volume to current_volume_ml
                const newVolume = Math.min(vial.bac_water_ml, vial.current_volume_ml + doseVolumeML);
                vial.current_volume_ml = newVolume;

                // Update used_volume_ml
                vial.used_volume_ml = vial.bac_water_ml - newVolume;

                // Update status based on new remaining amount
                if (vial.current_volume_ml > 0 && (vial.status === 'empty' || vial.status === 'finished')) {
                    vial.status = 'active';
                }

                console.log(`Reversed ${doseMg}mg (${doseVolumeML.toFixed(2)}ml) from vial ${vialId}. New volume: ${newVolume.toFixed(2)}ml`);

                // Save locally
                this.saveData();

                // Sync vial update to cloud if authenticated
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        await apiClient.updateVial(vialId, {
                            currentVolumeMl: vial.current_volume_ml,
                            usedVolumeMl: vial.used_volume_ml,
                            status: vial.status
                        });
                        console.log('Vial usage reversal synced to cloud successfully');
                    } catch (error) {
                        console.error('Failed to sync vial usage reversal to cloud:', error);
                        // Still updated locally, so don't block the user
                    }
                }
            }

            // ====================================
            // VIAL MANAGEMENT
            // ====================================

            async addVial(vial) {
                const concentration = vial.total_mg / vial.bac_water_ml;
                const newVial = {
                    vial_id: this.generateId(),
                    order_date: vial.order_date,
                    supplier: vial.supplier || '',
                    lot_number: vial.lot_number || '',
                    total_mg: parseFloat(vial.total_mg),
                    bac_water_ml: parseFloat(vial.bac_water_ml),
                    concentration_mg_ml: concentration,
                    reconstitution_date: vial.reconstitution_date,
                    expiration_date: this.calculateExpirationDate(vial.reconstitution_date, vial.order_date),
                    remaining_ml: parseFloat(vial.bac_water_ml),
                    doses_used: 0,
                    status: 'active'
                };

                this.data.vials.push(newVial);
                this.data.vials.sort((a, b) => new Date(b.reconstitution_date) - new Date(a.reconstitution_date));
                this.saveData();
                this.updateUI();

                // Push to sync queue if authenticated (Phase 1B: Reliable sync with retry)
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'create',
                        entity: 'vial',
                        localId: newVial.vial_id,
                        data: {
                            id: newVial.vial_id,
                            startDate: newVial.order_date,
                            initialVolumeMl: newVial.bac_water_ml,
                            concentrationMgPerMl: newVial.concentration_mg_ml,
                            currentVolumeMl: newVial.remaining_ml,
                            usedVolumeMl: 0,
                            status: newVial.status,
                            source: newVial.supplier || '',
                            notes: ''
                        }
                    });
                    console.log('Vial added to sync queue');
                }
            }

            calculateExpirationDate(reconstitutionDate, orderDate) {
                if (reconstitutionDate) {
                    // Reconstituted peptide lasts 30 days in refrigerator
                    const date = new Date(reconstitutionDate);
                    date.setDate(date.getDate() + 30);
                    return date.toISOString();
                } else if (orderDate) {
                    // Lyophilized powder lasts 2 years in freezer
                    const date = new Date(orderDate);
                    date.setFullYear(date.getFullYear() + 2);
                    return date.toISOString();
                }
                // Default to 2 years from now
                const date = new Date();
                date.setFullYear(date.getFullYear() + 2);
                return date.toISOString();
            }

            calculateDaysRemaining(totalDoses) {
                if (totalDoses <= 0) return 0;

                const today = new Date();
                const targetDayOfWeek = this.data.settings.dayOfDose || 6; // Default to Saturday
                const injectionFrequency = this.data.settings.injectionFrequency || 7;

                // Find the next dose day from today
                const daysUntilNextDose = (targetDayOfWeek - today.getDay() + 7) % 7;
                const nextDoseDate = new Date(today);
                nextDoseDate.setDate(today.getDate() + daysUntilNextDose);

                // If the next dose day is today and we haven't taken it yet, use today
                // Otherwise, calculate from the next occurrence
                if (daysUntilNextDose === 0) {
                    // Check if we've already dosed today
                    const todayString = today.toISOString().split('T')[0];
                    const dosedToday = this.data.injections.some(inj =>
                        inj.timestamp.startsWith(todayString)
                    );
                    if (!dosedToday) {
                        // Haven't dosed yet today, so start from today
                        nextDoseDate.setTime(today.getTime());
                    } else {
                        // Already dosed today, next dose is in injectionFrequency days
                        nextDoseDate.setDate(today.getDate() + injectionFrequency);
                    }
                }

                // Calculate when the last dose will be taken
                const totalDaysOfMedication = (totalDoses - 1) * injectionFrequency;
                const lastDoseDate = new Date(nextDoseDate);
                lastDoseDate.setDate(nextDoseDate.getDate() + totalDaysOfMedication);

                // Calculate days from today to last dose
                const daysRemaining = Math.ceil((lastDoseDate - today) / (1000 * 60 * 60 * 24));
                return Math.max(0, daysRemaining);
            }

            getActiveVial() {
                const plannedDose = parseFloat(document.getElementById('planned-dose')?.value || 4.0);
                return this.data.vials.find(v => {
                    const remainingMg = v.remaining_ml * v.concentration_mg_ml;
                    return v.status === 'active' &&
                           remainingMg >= plannedDose && // Must have enough for next dose
                           new Date(v.expiration_date) > new Date();
                });
            }

            // ====================================
            // WEIGHT MANAGEMENT
            // ====================================

            async addWeight(weight) {
                const newWeight = {
                    id: this.generateId(),
                    timestamp: weight.timestamp || new Date().toISOString(),
                    weight_kg: parseFloat(weight.weight_kg),
                    weight_lbs: this.kgToLbs(parseFloat(weight.weight_kg)),
                    source: weight.source || 'manual',
                    bmi: weight.bmi || null,
                    body_fat_percentage: weight.body_fat_percentage || null
                };

                this.data.weights.push(newWeight);
                this.data.weights.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                this.saveData();
                this.updateUI();

                // Check for milestones and celebrate
                this.checkMilestones();

                // Push to sync queue if authenticated (Phase 1B: Reliable sync with retry)
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'create',
                        entity: 'weight',
                        localId: newWeight.id,
                        data: {
                            id: newWeight.id,
                            timestamp: newWeight.timestamp,
                            weightKg: newWeight.weight_kg,
                            source: newWeight.source,
                            bmi: newWeight.bmi,
                            bodyFatPercentage: newWeight.body_fat_percentage
                        }
                    });
                    console.log('Weight added to sync queue');
                }
            }

            // ====================================
            // MEDICATION LEVEL CALCULATIONS
            // ====================================

            calculateCurrentMedicationLevel(currentTime = new Date().toISOString()) {
                const medicationHalfLife = 165; // 165 hours (about 7 days) - adjust as needed

                // Phase 2: Validate input data
                const injections = this.data.injections || [];
                if (injections.length === 0) {
                    return {
                        success: false,
                        error: 'No injection data available',
                        value: 0,
                        validCount: 0,
                        totalCount: 0
                    };
                }

                // Validate current time
                const currentTimestamp = new Date(currentTime).getTime();
                if (isNaN(currentTimestamp)) {
                    return {
                        success: false,
                        error: 'Invalid current time',
                        value: 0
                    };
                }

                let totalLevel = 0;
                let validCount = 0;
                let invalidCount = 0;

                injections.forEach(injection => {
                    // Phase 2: Validate injection has required fields
                    if (!injection.timestamp || !injection.dose_mg) {
                        console.warn('[MedicationLevel] Invalid injection:', injection.id,
                            'missing timestamp or dose_mg');
                        invalidCount++;
                        return; // Skip this injection
                    }

                    const injectionTime = new Date(injection.timestamp).getTime();

                    // Validate injection timestamp
                    if (isNaN(injectionTime)) {
                        console.warn('[MedicationLevel] Invalid timestamp for injection:', injection.id);
                        invalidCount++;
                        return;
                    }

                    // Validate dose is positive number
                    const doseMg = parseFloat(injection.dose_mg);
                    if (isNaN(doseMg) || doseMg <= 0) {
                        console.warn('[MedicationLevel] Invalid dose for injection:', injection.id, doseMg);
                        invalidCount++;
                        return;
                    }

                    const hoursElapsed = (currentTimestamp - injectionTime) / (1000 * 60 * 60);

                    if (hoursElapsed >= 0) {
                        const remainingLevel = doseMg * Math.pow(0.5, hoursElapsed / medicationHalfLife);
                        totalLevel += remainingLevel;
                        validCount++;
                    }
                });

                // Return structured result
                return {
                    success: validCount > 0,
                    value: totalLevel,
                    validCount,
                    totalCount: injections.length,
                    invalidCount,
                    warning: invalidCount > 0 ? `${invalidCount} injection(s) skipped due to invalid data` : null
                };
            }

            // ====================================
            // UTILITY FUNCTIONS
            // ====================================

            generateId() {
                return 'id_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            }

            kgToLbs(kg) {
                return kg * 2.20462;
            }

            lbsToKg(lbs) {
                return lbs / 2.20462;
            }

            formatDate(dateString) {
                return new Date(dateString).toLocaleDateString();
            }

            formatDateTime(dateString) {
                return new Date(dateString).toLocaleString();
            }

            // ====================================
            // UI UPDATE FUNCTIONS
            // ====================================

            updateUI() {
                this.updateSummaryTab();
                this.updateShotsTab();
                this.updateResultsTab();
                this.updateInventoryTab();
                this.updateSettingsTab();
            }

            getMostRecentInjection() {
                if (this.data.injections.length === 0) return null;

                return this.data.injections.reduce((mostRecent, current) => {
                    const currentDate = new Date(current.timestamp);
                    const mostRecentDate = new Date(mostRecent.timestamp);
                    return currentDate > mostRecentDate ? current : mostRecent;
                });
            }

            updateSummaryTab() {
                const totalShots = this.data.injections.length;
                const lastInjection = this.getMostRecentInjection();

                // Calculate remaining vial volume after last shot
                let vialRemainingMl = 0;
                if (lastInjection && lastInjection.vial_id) {
                    const vial = this.data.vials.find(v => v.id === lastInjection.vial_id);
                    if (vial) {
                        // Calculate total used from this vial
                        const injectionsFromVial = this.data.injections
                            .filter(inj => inj.vial_id === vial.id)
                            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                        const totalUsedMg = injectionsFromVial.reduce((sum, inj) => sum + inj.dose_mg, 0);
                        const totalUsedMl = totalUsedMg / vial.concentration_mg_ml;
                        vialRemainingMl = 1.0 - totalUsedMl; // Assuming 1ml bac water per vial
                    }
                }

                const nextShotDays = this.calculateNextShotDays();

                document.getElementById('total-shots').textContent = totalShots;
                document.getElementById('last-dose').textContent = lastInjection ?
                    `${lastInjection.dose_mg} mg` : '0 mg';
                document.getElementById('current-level').textContent = `${vialRemainingMl.toFixed(2)} ml`;
                document.getElementById('next-shot').textContent = `${nextShotDays} days`;

                this.updateCountdown();
                this.updateSupplyForecast();
            }

            updateShotsTab() {
                const shotsList = document.getElementById('shots-list');
                shotsList.innerHTML = '';

                // Sort injections by date (newest first) and display
                const sortedInjections = [...this.data.injections].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                sortedInjections.forEach(injection => {
                    const shotItem = this.createShotListItem(injection);
                    shotsList.appendChild(shotItem);
                });
            }

            updateResultsTab() {
                try {
                    this.updateWeightChart();
                } catch (error) {
                    console.error('Error updating weight chart:', error);
                }
                try {
                    this.updateWeightStats();
                } catch (error) {
                    console.error('Error updating weight stats:', error);
                }
                try {
                    this.updateGoalProgress();
                } catch (error) {
                    console.error('Error updating goal progress:', error);
                }
                try {
                    this.updateWeightsList();
                } catch (error) {
                    console.error('Error updating weights list:', error);
                }
            }

            updateInventoryTab() {
                const vialsList = document.getElementById('vials-list');
                vialsList.innerHTML = '';

                // Sort vials: Active first, Dry stock middle, Finished/Expired last
                const sortedVials = [...this.data.vials].sort((a, b) => {
                    const getStatusPriority = (vial) => {
                        // Check if vial is expired, empty, or expiring (finished status)
                        const now = new Date();
                        const expDate = vial.expiration_date ? new Date(vial.expiration_date) : null;
                        const isExpired = expDate && expDate < now;
                        const isEmpty = vial.remaining_ml <= 0;

                        if (vial.status === 'active' && !isExpired && !isEmpty) return 1; // Active at top
                        if (vial.status === 'dry_stock') return 2; // Dry stock in middle
                        return 3; // Finished/expired/empty at bottom
                    };

                    const priorityA = getStatusPriority(a);
                    const priorityB = getStatusPriority(b);

                    if (priorityA !== priorityB) {
                        return priorityA - priorityB;
                    }

                    // Within same priority group, sort by most recent date
                    if (priorityA === 1) {
                        // Active vials: sort by reconstitution date (newest first)
                        return new Date(b.reconstitution_date || 0) - new Date(a.reconstitution_date || 0);
                    } else if (priorityA === 2) {
                        // Dry stock: sort by order date (newest first)
                        return new Date(b.order_date || 0) - new Date(a.order_date || 0);
                    } else {
                        // Finished: sort by expiration date (oldest first)
                        return new Date(a.expiration_date || 0) - new Date(b.expiration_date || 0);
                    }
                });

                sortedVials.forEach(vial => {
                    const vialItem = this.createVialListItem(vial);
                    vialsList.appendChild(vialItem);
                });

                this.updateInventoryStats();
            }

            updateSettingsTab() {
                // Update injection frequency
                document.getElementById('injection-frequency').value = this.data.settings.injectionFrequency;

                // Update default dose
                if (this.data.settings.defaultDose) {
                    document.getElementById('default-dose').value = this.data.settings.defaultDose;
                }

                // Update day of dose
                if (this.data.settings.dayOfDose !== undefined) {
                    document.getElementById('day-of-dose').value = this.data.settings.dayOfDose;
                }

                // Update user height
                if (this.data.settings.heightCm) {
                    document.getElementById('user-height').value = this.data.settings.heightCm;
                }

                // Update goal weight
                if (this.data.settings.goalWeightKg) {
                    document.getElementById('goal-weight').value = this.data.settings.goalWeightKg;
                }

                // Update version information
                this.updateVersionInfo();
            }

            async updateVersionInfo() {
                // Display frontend version
                const frontendVersionEl = document.getElementById('frontend-version');
                if (frontendVersionEl) {
                    frontendVersionEl.textContent = APP_VERSION.frontend;
                }

                // Fetch backend version (no auth required for version endpoint)
                const backendVersionEl = document.getElementById('backend-version');
                if (backendVersionEl) {
                    try {
                        // Use apiClient baseURL (apiClient is a global from api-client.js)
                        if (typeof apiClient !== 'undefined' && apiClient.baseURL) {
                            const response = await fetch(`${apiClient.baseURL}/v1/version`, {
                                method: 'GET',
                                headers: {
                                    'Content-Type': 'application/json'
                                }
                            });
                            if (response.ok) {
                                const data = await response.json();
                                backendVersionEl.textContent = data.version || 'Unknown';
                            } else {
                                backendVersionEl.textContent = 'Not available';
                            }
                        } else {
                            backendVersionEl.textContent = 'API not configured';
                        }
                    } catch (error) {
                        console.error('Error fetching backend version:', error);
                        backendVersionEl.textContent = 'Not available';
                    }
                }
            }


            calculateNextShotDays() {
                if (this.data.injections.length === 0) return 0;

                const lastInjection = this.getMostRecentInjection();
                const lastShot = new Date(lastInjection.timestamp);
                const nextShot = new Date(lastShot);
                nextShot.setDate(nextShot.getDate() + this.data.settings.injectionFrequency);

                const now = new Date();
                const diffTime = nextShot - now;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                return Math.max(0, diffDays);
            }

            // ====================================
            // EVENT LISTENERS
            // ====================================

            setupEventListeners() {
                this.setupNavigation();
                this.setupModalHandlers();
                this.setupFormHandlers();
            }

            setupNavigation() {
                const navButtons = document.querySelectorAll('.nav-btn');
                const tabContents = document.querySelectorAll('.tab-content');

                navButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const targetTab = btn.dataset.tab;

                        navButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        tabContents.forEach(tab => {
                            tab.style.display = 'none';
                        });
                        document.getElementById(targetTab + '-tab').style.display = 'block';

                        // Update charts when switching tabs
                        if (targetTab === 'summary') this.updateSupplyForecast();
                        if (targetTab === 'results') this.updateWeightChart();
                        if (targetTab === 'settings') this.updateSettingsTab();
                    });
                });
            }

            hideLoadingScreen() {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('summary-tab').style.display = 'block';
                document.getElementById('current-date').textContent = new Date().toLocaleDateString();
            }

            // ====================================
            // PLACEHOLDER FUNCTIONS (TO BE IMPLEMENTED)
            // ====================================

            setupModalHandlers() {
                const overlay = document.getElementById('modal-overlay');
                const modals = document.querySelectorAll('.modal');

                // Add Shot Button handlers
                document.getElementById('add-shot-btn').addEventListener('click', () => {
                    this.openModal('add-shot-modal');
                });
                document.getElementById('add-shot-modal-btn').addEventListener('click', () => {
                    this.openModal('add-shot-modal');
                });

                // Add Vial Button handler
                document.getElementById('add-vial-btn').addEventListener('click', () => {
                    this.openModal('add-vial-modal');
                });

                // Activate Vial Button handler
                document.getElementById('activate-vial-btn').addEventListener('click', () => {
                    this.openModal('activate-vial-modal');
                });

                // Note: Add shot button is now in the Results header (no need to dynamically create it)

                // Close modal handlers
                document.querySelectorAll('.modal-close, [data-modal]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (btn.classList.contains('modal-close') || btn.textContent === 'Cancel') {
                            this.closeModal();
                        }
                    });
                });

                // Click outside modal to close
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        this.closeModal();
                    }
                });
            }

            setupFormHandlers() {
                // Add Shot Form
                document.getElementById('add-shot-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddShot();
                });

                // Add Vial Form
                document.getElementById('add-vial-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddVial();
                });

                // Edit Vial Form
                document.getElementById('edit-vial-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleEditVial();
                });

                // Activate Vial Form
                document.getElementById('activate-vial-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleActivateVial();
                });

                // Add Weight Form
                document.getElementById('add-weight-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddWeight();
                });

                // Settings form handlers
                document.getElementById('injection-frequency').addEventListener('change', (e) => {
                    this.data.settings.injectionFrequency = parseInt(e.target.value);
                    this.saveData();
                    this.updateUI();
                    this.showSettingSaveIndicator(e.target);
                });

                // Default dose handler
                document.getElementById('default-dose').addEventListener('change', (e) => {
                    this.data.settings.defaultDose = parseFloat(e.target.value);
                    this.saveData();
                    this.updateUI();
                    this.showSettingSaveIndicator(e.target);
                });

                // Day of dose handler
                document.getElementById('day-of-dose').addEventListener('change', (e) => {
                    this.data.settings.dayOfDose = parseInt(e.target.value);
                    this.saveData();
                    this.updateUI();
                    this.showSettingSaveIndicator(e.target);
                });

                // Height handler
                document.getElementById('user-height').addEventListener('change', (e) => {
                    this.data.settings.heightCm = parseFloat(e.target.value);
                    this.saveData();
                    this.updateBMI();
                    this.showSettingSaveIndicator(e.target);
                });

                // Goal weight handler
                document.getElementById('goal-weight').addEventListener('change', (e) => {
                    this.data.settings.goalWeightKg = parseFloat(e.target.value);
                    this.saveData();
                    this.updateGoalProgress();
                    this.showSettingSaveIndicator(e.target);
                });

                // Export data
                document.getElementById('export-data-btn').addEventListener('click', () => {
                    this.exportData();
                });

                // Planned dose change listener
                const plannedDoseInput = document.getElementById('planned-dose');
                if (plannedDoseInput) {
                    plannedDoseInput.addEventListener('input', () => {
                        this.updateSupplyForecast();
                    });
                }

                // Import data
                document.getElementById('import-data-btn').addEventListener('click', () => {
                    this.importData();
                });

                // Cloud backup
                document.getElementById('create-cloud-backup-btn').addEventListener('click', () => {
                    this.createCloudBackup();
                });
            }

            // ====================================
            // DATA EXPORT/IMPORT
            // ====================================

            exportData() {
                const dataStr = JSON.stringify(this.data, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `injection_data_${new Date().toISOString().split('T')[0]}.json`;
                link.click();

                URL.revokeObjectURL(url);

                // Also generate CSV for injections
                this.exportInjectionsCSV();
            }

            exportInjectionsCSV() {
                if (this.data.injections.length === 0) {
                    alert('No injection data to export');
                    return;
                }

                const headers = ['Date', 'Time', 'Dose (mg)', 'Site', 'Weight (kg)', 'Notes'];
                const rows = this.data.injections.map(inj => {
                    const date = new Date(inj.timestamp);
                    return [
                        date.toLocaleDateString(),
                        date.toLocaleTimeString(),
                        inj.dose_mg,
                        inj.injection_site,
                        inj.weight_kg || '',
                        inj.notes || ''
                    ];
                });

                let csv = headers.join(',') + '\n';
                rows.forEach(row => {
                    csv += row.map(cell => `"${cell}"`).join(',') + '\n';
                });

                const blob = new Blob([csv], {type: 'text/csv'});
                const url = URL.createObjectURL(blob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `injection_log_${new Date().toISOString().split('T')[0]}.csv`;
                link.click();

                URL.revokeObjectURL(url);
            }

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const text = await file.text();
                        const importedData = JSON.parse(text);

                        if (confirm('This will replace all your current data. Are you sure?')) {
                            this.data = importedData;
                            await this.saveData();
                            this.updateUI();
                            const issues = this.validateDataIntegrity();
                            if (issues.length > 0) {
                                alert('Data imported successfully!\n\nNote: Some data integrity issues were found. Check the console for details.');
                            } else {
                                alert('Data imported successfully!');
                            }
                        }
                    } catch (error) {
                        alert('Error importing data: ' + error.message);
                    }
                };

                input.click();
            }

            async importHistoricalData() {
                // Check Firebase auth directly
                const currentUser = firebase.auth().currentUser;
                if (!currentUser) {
                    throw new Error('Please sign in first');
                }

                const token = await currentUser.getIdToken();
                const API_BASE = 'https://5is9pmy9be.execute-api.eu-west-1.amazonaws.com/v1';

                const injections = [
                    { timestamp: '2025-08-06T09:00:00.000Z', doseMg: 0.25, site: 'abdomen', notes: 'Right abdomen. First micro-dose (2.5 units) to start titration.', vialId: null },
                    { timestamp: '2025-08-12T09:00:00.000Z', doseMg: 0.5, site: 'abdomen', notes: 'Right abdomen. Second dose (5 units). No major side effects.', vialId: null },
                    { timestamp: '2025-08-19T09:00:00.000Z', doseMg: 1, site: 'abdomen', notes: 'Right abdomen. First 1.0 mg (10 units). Mild nausea only.', vialId: null },
                    { timestamp: '2025-08-30T10:12:00.000Z', doseMg: 2, site: 'abdomen', notes: 'Right abdomen. First 2.0 mg dose (20 units). Mild appetite suppression.', vialId: null },
                    { timestamp: '2025-09-06T09:00:00.000Z', doseMg: 3, site: 'abdomen', notes: 'Right abdomen. 3.0 mg (30 units). Tolerated well, little nausea.', vialId: null },
                    { timestamp: '2025-09-13T09:00:00.000Z', doseMg: 4, site: 'abdomen', notes: 'Right abdomen. New vial reconstituted (10 mg + 1 mL BAC). First 4.0 mg dose (40 units).', vialId: 'vial-1' },
                    { timestamp: '2025-09-20T09:00:00.000Z', doseMg: 4, site: 'abdomen', notes: 'Right abdomen. Second 4.0 mg dose. Mild suppression noticed.', vialId: 'vial-1' },
                    { timestamp: '2025-09-27T10:51:00.000Z', doseMg: 4.2, site: 'abdomen', notes: 'Right abdomen. Only 42 units left in vial. Finished it. Suppression moderate.', vialId: 'vial-1' }
                ];

                const weights = [
                    { timestamp: '2025-08-06T09:00:00.000Z', weightKg: 95, notes: '' },
                    { timestamp: '2025-08-19T09:00:00.000Z', weightKg: 96, notes: '' },
                    { timestamp: '2025-08-30T10:12:00.000Z', weightKg: 93.6, notes: '' },
                    { timestamp: '2025-09-06T09:00:00.000Z', weightKg: 93, notes: '' },
                    { timestamp: '2025-09-20T09:00:00.000Z', weightKg: 90.9, notes: '' },
                    { timestamp: '2025-09-27T10:51:00.000Z', weightKg: 89.7, notes: '' }
                ];

                const vialData = {
                    startDate: '2025-09-13',
                    initialVolumeMl: 1,
                    concentrationMgPerMl: 10,
                    currentVolumeMl: 0,
                    usedVolumeMl: 1,
                    status: 'finished',
                    source: '',
                    notes: 'Reconstituted 10mg with 1mL BAC water'
                };

                // Import vial first (so injections can reference it)
                const vialRes = await fetch(`${API_BASE}/vials`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(vialData)
                });
                if (!vialRes.ok) {
                    const errorText = await vialRes.text();
                    throw new Error(`Failed to import vial: ${vialRes.status} - ${errorText}`);
                }
                const vialResult = await vialRes.json();
                const vialId = vialResult.data.id;

                // Update injection vialIds with the actual created vial ID
                const updatedInjections = injections.map(inj => ({
                    ...inj,
                    vialId: inj.vialId === 'vial-1' ? vialId : null
                }));

                // Import injections
                for (const inj of updatedInjections) {
                    const res = await fetch(`${API_BASE}/injections`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(inj)
                    });
                    if (!res.ok) {
                        const errorText = await res.text();
                        throw new Error(`Failed to import injection: ${res.status} - ${errorText}`);
                    }
                }

                // Import weights
                for (const wt of weights) {
                    const res = await fetch(`${API_BASE}/weights`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(wt)
                    });
                    if (!res.ok) {
                        const errorText = await res.text();
                        throw new Error(`Failed to import weight: ${res.status} - ${errorText}`);
                    }
                }
            }


            async createCloudBackup() {
                try {
                    // Check if authenticated
                    if (!authManager.isAuthenticated()) {
                        alert('Please sign in to use cloud backup.\n\nGo to Settings  Cloud Sync section.');
                        return;
                    }

                    // Show loading state
                    const button = document.getElementById('create-cloud-backup-btn');
                    const originalText = button.textContent;
                    button.textContent = 'Creating backup...';
                    button.disabled = true;

                    // Call API to create backup
                    const result = await apiClient.createBackup();

                    // Update UI with success
                    const timestamp = new Date(result.timestamp).toLocaleString();
                    const counts = result.counts;

                    alert(
                        ` Cloud Backup Created Successfully!\n\n` +
                        `Timestamp: ${timestamp}\n` +
                        `Injections: ${counts.injections}\n` +
                        `Vials: ${counts.vials}\n` +
                        `Weights: ${counts.weights}\n\n` +
                        `Your data is now safely stored in AWS S3.\n` +
                        `Only the 4 most recent backups are kept.`
                    );

                    // Store last backup info in localStorage
                    localStorage.setItem('lastCloudBackup', JSON.stringify({
                        timestamp: result.timestamp,
                        key: result.key
                    }));

                    // Update cloud backup status
                    this.updateCloudBackupStatus();

                    // Reset button
                    button.textContent = originalText;
                    button.disabled = false;

                } catch (error) {
                    console.error('Failed to create cloud backup:', error);

                    // Reset button
                    const button = document.getElementById('create-cloud-backup-btn');
                    button.textContent = 'Backup to Cloud';
                    button.disabled = false;

                    alert(
                        ' Cloud Backup Failed\n\n' +
                        error.message + '\n\n' +
                        'Please check your internet connection and try again.'
                    );
                }
            }

            updateCloudBackupStatus() {
                const statusEl = document.getElementById('cloud-backup-status');
                const timestampEl = document.getElementById('cloud-backup-timestamp');
                const lastDiv = document.getElementById('cloud-backup-last');
                const nextBackupEl = document.getElementById('next-backup-date');

                if (authManager.isAuthenticated()) {
                    statusEl.textContent = ' Ready';
                    statusEl.style.color = 'var(--success-color)';

                    // Check for last backup
                    const lastBackup = localStorage.getItem('lastCloudBackup');
                    if (lastBackup) {
                        const backup = JSON.parse(lastBackup);
                        timestampEl.textContent = new Date(backup.timestamp).toLocaleString();
                        lastDiv.style.display = 'flex';
                    }

                    // Calculate next scheduled backup (next Monday at 9 AM)
                    const nextMonday = this.getNextMonday();
                    if (nextBackupEl) {
                        nextBackupEl.textContent = nextMonday.toLocaleString('en-US', {
                            weekday: 'long',
                            month: 'short',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                    }
                } else {
                    statusEl.textContent = 'Not authenticated';
                    statusEl.style.color = 'var(--text-muted)';
                    lastDiv.style.display = 'none';
                }
            }

            getNextMonday() {
                const now = new Date();
                const dayOfWeek = now.getDay();
                const daysUntilMonday = dayOfWeek === 0 ? 1 : (8 - dayOfWeek);

                const nextMonday = new Date(now);
                nextMonday.setDate(now.getDate() + daysUntilMonday);
                nextMonday.setHours(9, 0, 0, 0);

                return nextMonday;
            }

            async checkAutoBackup() {
                // Only run if authenticated
                if (!authManager.isAuthenticated()) {
                    return;
                }

                const lastBackup = localStorage.getItem('lastCloudBackup');
                const now = new Date();

                // Check if it's Monday and between 9 AM and 10 AM
                const dayOfWeek = now.getDay();
                const hour = now.getHours();

                if (dayOfWeek !== 1 || hour !== 9) {
                    // Not Monday morning, skip
                    return;
                }

                // If we have a last backup, check if it was within the last 7 days
                if (lastBackup) {
                    const backup = JSON.parse(lastBackup);
                    const lastBackupDate = new Date(backup.timestamp);
                    const daysSinceLastBackup = (now - lastBackupDate) / (1000 * 60 * 60 * 24);

                    if (daysSinceLastBackup < 7) {
                        console.log('Auto-backup skipped: Recent backup exists');
                        return;
                    }
                }

                // Check if we already did an auto-backup today
                const lastAutoBackup = localStorage.getItem('lastAutoBackupDate');
                if (lastAutoBackup) {
                    const lastAutoDate = new Date(lastAutoBackup);
                    if (lastAutoDate.toDateString() === now.toDateString()) {
                        console.log('Auto-backup already done today');
                        return;
                    }
                }

                console.log('Performing automatic weekly backup...');

                // Create backup silently
                try {
                    const result = await apiClient.createBackup();

                    // Store last backup info
                    localStorage.setItem('lastCloudBackup', JSON.stringify({
                        timestamp: result.timestamp,
                        key: result.key
                    }));

                    // Mark that we did an auto-backup today
                    localStorage.setItem('lastAutoBackupDate', now.toISOString());

                    // Update UI
                    this.updateCloudBackupStatus();

                    console.log('Auto-backup completed successfully');
                } catch (error) {
                    console.error('Auto-backup failed:', error);
                }
            }

            openModal(modalId) {
                const overlay = document.getElementById('modal-overlay');
                const modal = document.getElementById(modalId);

                // Trigger haptic feedback
                this.triggerHaptic('light');

                // Set current date/time for date inputs with smart defaults
                const now = new Date();
                const localDateTime = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);

                if (modalId === 'add-shot-modal') {
                    // Smart default: Use last injection time + frequency
                    const lastInjection = this.data.injections[0];
                    if (lastInjection) {
                        const lastDate = new Date(lastInjection.timestamp);
                        const nextDate = new Date(lastDate.getTime() + this.data.settings.injectionFrequency * 24 * 60 * 60 * 1000);

                        // If next date is in the past or more than a week in future, use current time
                        if (nextDate <= now && nextDate >= new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)) {
                            const nextDateTime = new Date(nextDate.getTime() - nextDate.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                            document.getElementById('shot-date').value = nextDateTime;

                            // Pre-fill last dose if available
                            const lastDose = document.getElementById('shot-dose');
                            if (lastDose && lastInjection.dose_mg) {
                                lastDose.value = lastInjection.dose_mg;
                            }
                        } else {
                            document.getElementById('shot-date').value = localDateTime;
                        }
                    } else {
                        document.getElementById('shot-date').value = localDateTime;
                    }

                    this.populateVialSelect();
                } else if (modalId === 'add-vial-modal') {
                    document.getElementById('vial-order-date').value = now.toISOString().split('T')[0];
                } else if (modalId === 'activate-vial-modal') {
                    document.getElementById('activate-reconstitution-date').value = localDateTime;
                    this.populateActivateVialDropdown();
                } else if (modalId === 'add-weight-modal') {
                    document.getElementById('weight-date').value = localDateTime;
                }

                overlay.style.display = 'flex';
                modal.style.display = 'block';
                document.body.style.overflow = 'hidden';
            }

            populateActivateVialDropdown() {
                const select = document.getElementById('activate-vial-id');
                select.innerHTML = '<option value="">Select a vial to activate...</option>';

                const dryStockVials = this.data.vials.filter(v => v.status === 'dry_stock');
                dryStockVials.forEach(vial => {
                    const option = document.createElement('option');
                    option.value = vial.vial_id;
                    option.textContent = `${vial.total_mg}mg from ${vial.supplier || 'Unknown'} (${new Date(vial.order_date).toLocaleDateString()})`;
                    select.appendChild(option);
                });
            }

            closeModal() {
                const overlay = document.getElementById('modal-overlay');
                const modals = document.querySelectorAll('.modal');

                overlay.style.display = 'none';
                modals.forEach(modal => modal.style.display = 'none');
                document.body.style.overflow = '';

                // Reset forms
                document.querySelectorAll('form').forEach(form => form.reset());
            }

            populateVialSelect() {
                const select = document.getElementById('shot-vial');
                select.innerHTML = '<option value="">Select vial</option>';

                // Filter for active vials with remaining volume
                const activeVials = this.data.vials.filter(v => {
                    // Support both 'active' and 'activated' status
                    const isActive = v.status === 'active' || v.status === 'activated';
                    // Check both property names for backwards compatibility (Hotfix)
                    const hasVolume = (v.current_volume_ml || v.remaining_ml || 0) > 0;

                    return isActive && hasVolume;
                });

                activeVials.forEach(vial => {
                    const option = document.createElement('option');
                    option.value = vial.vial_id;
                    const concentration = vial.concentration_mg_per_ml || vial.concentration_mg_ml || 0;
                    const remaining = vial.current_volume_ml || vial.remaining_ml || 0;
                    option.textContent = `${vial.total_mg}mg (${concentration.toFixed(1)} mg/ml) - ${remaining.toFixed(2)}ml left`;
                    select.appendChild(option);
                });

                if (activeVials.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No active vials available';
                    option.disabled = true;
                    select.appendChild(option);
                }
            }

            async handleAddShot() {
                try {
                    const form = document.getElementById('add-shot-form');

                    // Validate form before processing
                    if (!form.checkValidity()) {
                        form.reportValidity();
                        return;
                    }

                    // Get and validate dose
                    const doseMg = parseFloat(document.getElementById('shot-dose').value);
                    if (isNaN(doseMg) || doseMg <= 0 || doseMg > 50) {
                        alert('Please enter a valid dose between 0 and 50 mg');
                        return;
                    }

                    // Validate vial selection
                    const vialId = document.getElementById('shot-vial').value;
                    if (!vialId) {
                        alert('Please select a vial');
                        return;
                    }

                    const injection = {
                        timestamp: new Date(document.getElementById('shot-date').value).toISOString(),
                        dose_mg: doseMg,
                        injection_site: document.getElementById('shot-site').value,
                        vial_id: vialId,
                        notes: document.getElementById('shot-notes').value
                    };

                    await this.addInjection(injection);

                    // Reset form after successful submission
                    form.reset();

                } catch (error) {
                    console.error('Error adding shot:', error);
                    alert('Shot saved locally. Cloud sync will retry automatically.');
                } finally {
                    // Always close modal, even on error
                    setTimeout(() => {
                        this.closeModal();
                    }, 300);
                }
            }

            async handleAddVial() {
                const orderDate = document.getElementById('vial-order-date').value;
                const supplier = document.getElementById('vial-supplier').value;
                const totalMg = parseFloat(document.getElementById('vial-mg').value);
                const quantity = parseInt(document.getElementById('vial-quantity').value) || 1;

                if (!orderDate || !totalMg || !quantity) {
                    alert('Please fill in all required fields');
                    return;
                }

                // Add multiple vials to dry stock
                const newVials = [];
                for (let i = 0; i < quantity; i++) {
                    const vial = {
                        vial_id: this.generateId(),
                        order_date: orderDate,
                        supplier: supplier || '',
                        total_mg: totalMg,
                        bac_water_ml: null,
                        concentration_mg_ml: null,
                        reconstitution_date: null,
                        expiration_date: this.calculateExpirationDate(null, orderDate),
                        remaining_ml: 0,
                        doses_used: 0,
                        status: 'dry_stock'
                    };

                    this.data.vials.push(vial);
                    newVials.push(vial);
                }

                this.data.vials.sort((a, b) => new Date(b.order_date) - new Date(a.order_date));
                this.saveData();
                this.updateUI();

                // Push all new vials to sync queue (Phase 1B: Reliable sync with retry)
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    for (const vial of newVials) {
                        this.syncQueue.add({
                            type: 'create',
                            entity: 'vial',
                            localId: vial.vial_id,
                            data: {
                                id: vial.vial_id,
                                startDate: vial.order_date,
                                initialVolumeMl: 0,  // Dry stock has no volume yet
                                concentrationMgPerMl: 0,  // No concentration until reconstituted
                                currentVolumeMl: 0,
                                usedVolumeMl: 0,
                                status: vial.status,
                                source: vial.supplier || '',
                                notes: `${totalMg}mg dry stock`
                            }
                        });
                        console.log(`Vial ${vial.vial_id} added to sync queue`);
                    }
                }

                // Delay modal close to show save indicator
                setTimeout(() => {
                    this.closeModal();
                }, 300);
            }

            openEditVialModal(vialId) {
                const vial = this.findVialById(vialId);
                if (!vial) {
                    alert('Vial not found');
                    return;
                }

                // Populate the form with vial data
                document.getElementById('edit-vial-id').value = vial.vial_id;
                document.getElementById('edit-vial-order-date').value = new Date(vial.order_date).toISOString().split('T')[0];
                document.getElementById('edit-vial-supplier').value = vial.supplier || '';
                document.getElementById('edit-vial-mg').value = vial.total_mg;

                // Open the modal
                this.openModal('edit-vial-modal');
            }

            async handleEditVial() {
                const vialId = document.getElementById('edit-vial-id').value;
                const orderDate = document.getElementById('edit-vial-order-date').value;
                const supplier = document.getElementById('edit-vial-supplier').value;
                const totalMg = parseFloat(document.getElementById('edit-vial-mg').value);

                if (!vialId || !orderDate || !totalMg) {
                    alert('Please fill in all required fields');
                    return;
                }

                const vial = this.findVialById(vialId);
                if (!vial) {
                    alert('Vial not found');
                    return;
                }

                // Update vial properties
                vial.order_date = orderDate;
                vial.supplier = supplier || '';
                vial.total_mg = totalMg;

                // If vial is activated, update concentration
                if (vial.bac_water_ml && vial.bac_water_ml > 0) {
                    vial.concentration_mg_ml = totalMg / vial.bac_water_ml;
                }

                // Update expiration date if vial hasn't been activated
                if (vial.status === 'dry_stock') {
                    vial.expiration_date = this.calculateExpirationDate(null, orderDate);
                }

                this.data.vials.sort((a, b) => new Date(b.order_date) - new Date(a.order_date));
                this.saveData();
                this.updateUI();

                // Push update to sync queue
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'update',
                        entity: 'vial',
                        localId: vial.vial_id,
                        data: {
                            id: vial.vial_id,
                            startDate: vial.order_date,
                            initialVolumeMl: vial.bac_water_ml || 0,
                            concentrationMgPerMl: vial.concentration_mg_ml || 0,
                            currentVolumeMl: vial.remaining_ml || 0,
                            usedVolumeMl: vial.bac_water_ml ? (vial.bac_water_ml - vial.remaining_ml) : 0,
                            status: vial.status,
                            source: vial.supplier || '',
                            notes: `${totalMg}mg ${vial.status === 'dry_stock' ? 'dry stock' : 'active'}`
                        }
                    });
                    console.log(`Vial ${vial.vial_id} update added to sync queue`);
                }

                // Delay modal close to show save indicator
                setTimeout(() => {
                    this.closeModal();
                }, 300);
            }

            async handleActivateVial() {
                const vialId = document.getElementById('activate-vial-id').value;
                const bacWaterMl = parseFloat(document.getElementById('activate-bac-water').value);
                const reconstitutionDateRaw = document.getElementById('activate-reconstitution-date').value;

                if (!vialId || !bacWaterMl || !reconstitutionDateRaw) {
                    alert('Please fill in all required fields');
                    return;
                }

                const vial = this.findVialById(vialId);
                if (!vial || vial.status !== 'dry_stock') {
                    alert('Invalid vial selected');
                    return;
                }

                // Convert to ISO string
                const reconstitutionDate = new Date(reconstitutionDateRaw).toISOString();

                // Calculate concentration and expiration
                const concentrationMgMl = vial.total_mg / bacWaterMl;
                const expirationDate = this.calculateExpirationDate(reconstitutionDate, null);

                // Update vial to active status
                vial.bac_water_ml = bacWaterMl;
                vial.concentration_mg_ml = concentrationMgMl;
                vial.reconstitution_date = reconstitutionDate;
                vial.expiration_date = expirationDate;
                vial.remaining_ml = bacWaterMl; // Start with full volume
                vial.current_volume_ml = bacWaterMl; // Sync property for consistency (Hotfix)
                vial.status = 'active';

                this.saveData();
                this.updateUI();

                // Push activated vial to sync queue (Phase 1B: Reliable sync with retry)
                if (authManager && authManager.isAuthenticated() && this.syncQueue) {
                    this.syncQueue.add({
                        type: 'create',
                        entity: 'vial',
                        localId: vial.vial_id,
                        data: {
                            id: vial.vial_id,
                            startDate: vial.reconstitution_date,
                            initialVolumeMl: bacWaterMl,
                            concentrationMgPerMl: concentrationMgMl,
                            currentVolumeMl: vial.remaining_ml,
                            usedVolumeMl: 0,
                            status: vial.status,
                            source: vial.supplier || '',
                            notes: `${vial.total_mg}mg reconstituted`
                        }
                    });
                    console.log(`Vial ${vial.vial_id} activation added to sync queue`);
                }

                // Delay modal close to show save indicator
                setTimeout(() => {
                    this.closeModal();
                }, 300);
            }

            async handleAddWeight() {
                try {
                    const weight = {
                        timestamp: new Date(document.getElementById('weight-date').value).toISOString(),
                        weight_kg: parseFloat(document.getElementById('weight-kg').value),
                        body_fat_percentage: document.getElementById('weight-body-fat').value ?
                            parseFloat(document.getElementById('weight-body-fat').value) : null,
                        source: 'manual'
                    };

                    await this.addWeight(weight);
                } catch (error) {
                    console.error('Error adding weight:', error);
                    alert('Weight saved locally. Cloud sync will retry automatically.');
                } finally {
                    // Always close modal, even on error
                    setTimeout(() => {
                        this.closeModal();
                    }, 300);
                }
            }

            createShotListItem(injection) {
                const div = document.createElement('div');
                div.className = 'shot-item';
                div.setAttribute('data-item-id', injection.id);
                div.setAttribute('data-timestamp', injection.timestamp);
                div.innerHTML = `
                    <div class="shot-content">
                        <div class="shot-header">
                            <div class="shot-dose">${injection.dose_mg} mg</div>
                            <div class="shot-date">${this.formatDate(injection.timestamp)}</div>
                        </div>
                        <div class="shot-details">
                            <div>Site: ${injection.injection_site}</div>
                            <div>Weight: ${injection.weight_kg ? injection.weight_kg + ' kg' : 'N/A'}</div>
                        </div>
                    </div>
                    <button class="delete-btn" aria-label="Delete injection" title="Delete this injection">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                            <path d="M10 11v6M14 11v6"/>
                        </svg>
                    </button>
                    <div class="delete-action">Delete</div>
                `;

                // Add swipe to delete handlers
                this.addSwipeToDeleteHandlers(div);

                return div;
            }

            createVialListItem(vial) {
                const div = document.createElement('div');
                div.className = `vial-item ${vial.status}`;
                div.setAttribute('data-item-id', vial.vial_id);
                div.setAttribute('data-timestamp', vial.order_date);

                if (vial.status === 'dry_stock') {
                    div.innerHTML = `
                        <div class="vial-content">
                            <div class="vial-header">
                                <div class="vial-info">
                                    <div class="vial-title">${vial.total_mg}mg Vial</div>
                                    <div class="vial-subtitle">${vial.supplier || 'Unknown Supplier'}</div>
                                    <div class="vial-subtitle">Ordered: ${this.formatDate(vial.order_date)}</div>
                                </div>
                                <div class="vial-status dry_stock">Dry Stock</div>
                            </div>
                            <div class="vial-details">
                                <div class="vial-detail-row">
                                    <span>Status:</span>
                                    <span>Ready for activation with BAC water</span>
                                </div>
                                <div class="vial-detail-row">
                                    <span>Powder Expires:</span>
                                    <span>${vial.expiration_date ? this.formatDate(vial.expiration_date) : 'Not set'}</span>
                                </div>
                            </div>
                        </div>
                        <button class="edit-btn" aria-label="Edit vial" title="Edit this vial">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                        <button class="delete-btn" aria-label="Delete vial" title="Delete this vial">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                                <path d="M10 11v6M14 11v6"/>
                            </svg>
                        </button>
                    `;
                    return div;
                }

                // Handle active and other statuses
                const now = new Date();
                const expirationDate = new Date(vial.expiration_date);
                const isExpired = expirationDate < now;
                const daysUntilExpiry = Math.ceil((expirationDate - now) / (1000 * 60 * 60 * 24));

                let status = vial.status;
                let statusText = vial.status === 'active' ? 'Active' : vial.status;

                if (vial.status === 'active') {
                    if (isExpired) {
                        status = 'expired';
                        statusText = 'Expired';
                    } else if (daysUntilExpiry <= 3) {
                        status = 'expiring';
                        statusText = `${daysUntilExpiry}d left`;
                    } else if (vial.remaining_ml <= 0) {
                        status = 'empty';
                        statusText = 'Empty';
                    }
                }

                // Calculate remaining doses based on default dose from settings
                const defaultDose = this.data.settings.defaultDose || 2.0;
                const remainingDoses = vial.concentration_mg_ml ? ((vial.remaining_ml * vial.concentration_mg_ml) / defaultDose).toFixed(1) : 0;

                div.innerHTML = `
                    <div class="vial-content">
                        <div class="vial-header">
                            <div class="vial-info">
                                <div class="vial-title">${vial.total_mg}mg Vial</div>
                                <div class="vial-subtitle">${vial.supplier || 'Unknown Supplier'}</div>
                                <div class="vial-subtitle">Ordered: ${this.formatDate(vial.order_date)}</div>
                            </div>
                            <div class="vial-status ${status}">${statusText}</div>
                        </div>
                        <div class="vial-details">
                            ${vial.concentration_mg_ml ? `
                            <div class="vial-detail-row">
                                <span>Concentration:</span>
                                <span>${vial.concentration_mg_ml.toFixed(1)} mg/ml</span>
                            </div>
                            <div class="vial-detail-row">
                                <span>Remaining:</span>
                                <span>${vial.remaining_ml.toFixed(2)} ml (${remainingDoses} doses)</span>
                            </div>
                            <div class="vial-detail-row">
                                <span>Reconstituted:</span>
                                <span>${this.formatDate(vial.reconstitution_date)}</span>
                            </div>
                            ` : `
                            <div class="vial-detail-row">
                                <span>Status:</span>
                                <span>Ready for activation with BAC water</span>
                            </div>
                            `}
                            <div class="vial-detail-row">
                                <span>Expires:</span>
                                <span>${vial.expiration_date ? this.formatDate(vial.expiration_date) : 'Not set'}</span>
                            </div>
                            ${vial.concentration_mg_ml ? `
                            <div class="vial-detail-row">
                                <span>Doses Used:</span>
                                <span>${vial.doses_used}</span>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    <button class="edit-btn" aria-label="Edit vial" title="Edit this vial">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
                            <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
                        </svg>
                    </button>
                    <button class="delete-btn" aria-label="Delete vial" title="Delete this vial">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                            <path d="M10 11v6M14 11v6"/>
                        </svg>
                    </button>
                `;
                return div;
            }

            // Phase 2: Extract calculation logic with validation
            calculateSupplyForecast(plannedWeeklyDose = 4.0) {
                // Validate input data
                const vials = this.data.vials || [];
                if (vials.length === 0) {
                    return {
                        success: false,
                        error: 'No vial data available',
                        totalSupplyMg: 0,
                        weeksRemaining: 0,
                        daysRemaining: 0,
                        activeVialCount: 0,
                        dryStockCount: 0
                    };
                }

                // Validate planned dose
                const dose = parseFloat(plannedWeeklyDose);
                if (isNaN(dose) || dose <= 0) {
                    return {
                        success: false,
                        error: 'Invalid planned dose (must be > 0)',
                        totalSupplyMg: 0
                    };
                }

                let totalSupplyMg = 0;
                let validActiveCount = 0;
                let invalidActiveCount = 0;
                let validDryStockCount = 0;
                let invalidDryStockCount = 0;

                // Process active vials
                const activeVials = vials.filter(v => {
                    const isActive = v.status === 'active' || v.status === 'activated';
                    const isNotEmpty = v.status !== 'empty' && v.status !== 'finished';
                    return isActive && isNotEmpty;
                });

                activeVials.forEach(vial => {
                    const concentration = vial.concentration_mg_per_ml || vial.concentration_mg_ml;
                    const volume = vial.current_volume_ml || vial.remaining_ml;

                    // Phase 2: Validate vial data
                    if (!concentration || concentration <= 0) {
                        console.warn('[SupplyForecast] Invalid concentration for vial:', vial.vial_id || vial.id);
                        invalidActiveCount++;
                        return;
                    }

                    if (!volume || volume <= 0) {
                        console.warn('[SupplyForecast] Invalid volume for vial:', vial.vial_id || vial.id);
                        invalidActiveCount++;
                        return;
                    }

                    const remainingMg = volume * concentration;
                    totalSupplyMg += remainingMg;
                    validActiveCount++;
                    console.log(`Vial ${vial.vial_id || vial.id} (active): ${remainingMg.toFixed(1)}mg remaining (${volume.toFixed(2)}ml @ ${concentration}mg/ml)`);
                });

                // Process dry stock vials
                const dryStockVials = vials.filter(v => v.status === 'dry_stock');

                dryStockVials.forEach(vial => {
                    const totalMg = vial.total_mg;

                    // Phase 2: Validate dry stock data
                    if (!totalMg || totalMg <= 0) {
                        console.warn('[SupplyForecast] Invalid total_mg for dry stock vial:', vial.vial_id || vial.id);
                        invalidDryStockCount++;
                        return;
                    }

                    totalSupplyMg += totalMg;
                    validDryStockCount++;
                    console.log(`Vial ${vial.vial_id || vial.id} (dry_stock): ${totalMg}mg available`);
                });

                console.log(`Total remaining supply: ${totalSupplyMg.toFixed(1)}mg (${validActiveCount} active + ${validDryStockCount} dry stock)`);

                // Calculate duration
                const weeksRemaining = dose > 0 ? Math.floor(totalSupplyMg / dose) : 0;
                const daysRemaining = Math.floor((totalSupplyMg / dose) * 7);

                // Return structured result
                return {
                    success: true,
                    totalSupplyMg,
                    weeksRemaining,
                    daysRemaining,
                    activeVialCount: validActiveCount,
                    dryStockCount: validDryStockCount,
                    invalidActiveCount,
                    invalidDryStockCount,
                    warning: (invalidActiveCount + invalidDryStockCount) > 0
                        ? `${invalidActiveCount + invalidDryStockCount} vial(s) skipped due to invalid data`
                        : null
                };
            }

            updateSupplyForecast() {
                // Get planned dose from input
                const plannedDoseInput = document.getElementById('planned-dose');
                const plannedWeeklyDose = parseFloat(plannedDoseInput?.value || 4.0);

                // Phase 2: Use validated calculation
                const forecast = this.calculateSupplyForecast(plannedWeeklyDose);

                if (!forecast.success) {
                    console.error('[SupplyForecast] Calculation failed:', forecast.error);
                    document.getElementById('total-supply').textContent = '0 mg';
                    document.getElementById('supply-duration').textContent = 'No data';
                    document.getElementById('run-out-date').textContent = 'No supply';
                    document.getElementById('reorder-days').textContent = 'N/A';

                    // Phase 3: Add validation indicators for error state
                    const errorIndicator = `
                        <span class="validation-indicator validation-error validation-tooltip">
                            <span class="validation-icon"></span>
                            <span class="tooltip-content">${forecast.error}</span>
                        </span>
                    `;
                    document.getElementById('supply-duration-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('run-out-date-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('reorder-days-validation-indicator').innerHTML = errorIndicator;
                    return;
                }

                const { totalSupplyMg, weeksRemaining, daysRemaining } = forecast;

                // Calculate run out date
                const runOutDate = new Date();
                runOutDate.setDate(runOutDate.getDate() + daysRemaining);

                // Calculate reorder date (2 weeks before running out)
                const reorderDays = Math.max(0, daysRemaining - 14);

                // Update display
                document.getElementById('total-supply').textContent = `${totalSupplyMg.toFixed(1)} mg`;
                document.getElementById('supply-duration').textContent = `${weeksRemaining} weeks (${daysRemaining} days)`;
                document.getElementById('run-out-date').textContent = daysRemaining > 0 ? runOutDate.toLocaleDateString() : 'No supply';
                document.getElementById('reorder-days').textContent = reorderDays > 0 ? `${reorderDays} days` : 'Order now!';

                // Phase 3: Determine validation status
                const hasWarning = forecast.warning;
                const validationHTML = hasWarning
                    ? `<span class="validation-indicator validation-warning validation-tooltip">
                           <span class="validation-icon"></span>
                           <span class="tooltip-content">${forecast.warning}</span>
                       </span>`
                    : `<span class="validation-indicator validation-success">
                           <span class="validation-icon"></span>
                       </span>`;

                document.getElementById('supply-duration-validation-indicator').innerHTML = validationHTML;
                document.getElementById('run-out-date-validation-indicator').innerHTML = validationHTML;
                document.getElementById('reorder-days-validation-indicator').innerHTML = validationHTML;

                // Update colors based on supply levels
                const supplyDurationElement = document.getElementById('supply-duration');
                const runOutElement = document.getElementById('run-out-date');
                const reorderElement = document.getElementById('reorder-days');

                if (daysRemaining < 7) {
                    supplyDurationElement.style.color = '#FF3B30'; // Red
                    runOutElement.style.color = '#FF3B30';
                    reorderElement.style.color = '#FF3B30';
                } else if (daysRemaining < 21) {
                    supplyDurationElement.style.color = '#FF9500'; // Orange
                    runOutElement.style.color = '#FF9500';
                    reorderElement.style.color = '#FF9500';
                } else {
                    supplyDurationElement.style.color = '#34C759'; // Green
                    runOutElement.style.color = '#34C759';
                    reorderElement.style.color = '#34C759';
                }
            }

            updateMedicationChart() {
                // Keeping old function for compatibility - now calls updateSupplyForecast
                this.updateSupplyForecast();
                return;

                // Check if Chart.js is loaded
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not loaded, skipping chart update');
                    return;
                }

                // Destroy existing chart if it exists
                if (this.charts.medicationChart) {
                    this.charts.medicationChart.destroy();
                }

                if (this.data.injections.length === 0) {
                    // Show empty state
                    ctx.fillStyle = '#888888';
                    ctx.font = '16px -apple-system, BlinkMacSystemFont, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('No injection data yet', canvas.width / 2, canvas.height / 2);
                    return;
                }

                const chartData = this.generateMedicationLevelData();

                this.charts.medicationChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: chartData.labels,
                        datasets: [{
                            label: 'Medication Level',
                            data: chartData.levels,
                            borderColor: '#007AFF',
                            backgroundColor: 'rgba(0, 122, 255, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: '#007AFF',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2,
                            pointRadius: 4
                        }, {
                            label: 'Projected Level',
                            data: chartData.projectedLevels,
                            borderColor: '#007AFF',
                            backgroundColor: 'transparent',
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff',
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(42, 42, 42, 0.9)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#333333',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: 11
                                    }
                                }
                            },
                            y: {
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: 11
                                    },
                                    callback: function(value) {
                                        return value.toFixed(1) + ' mg';
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Medication Level (mg)',
                                    color: '#cccccc'
                                }
                            }
                        }
                    }
                });
            }

            generateMedicationLevelData() {
                const now = new Date();
                const startDate = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000)); // 30 days ago
                const endDate = new Date(now.getTime() + (14 * 24 * 60 * 60 * 1000)); // 14 days in future

                const labels = [];
                const levels = [];
                const projectedLevels = [];

                // Generate data points every 6 hours
                for (let date = new Date(startDate); date <= endDate; date = new Date(date.getTime() + 6 * 60 * 60 * 1000)) {
                    const levelResult = this.calculateCurrentMedicationLevel(date.toISOString());
                    const level = levelResult.value || 0; // Phase 2: Extract value from result
                    const isProjected = date > now;

                    labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));

                    if (isProjected) {
                        levels.push(null);
                        projectedLevels.push(level);
                    } else {
                        levels.push(level);
                        projectedLevels.push(null);
                    }
                }

                return { labels, levels, projectedLevels };
            }

            updateWeightChart(view = 'combined') {
                // Check if Chart.js is loaded
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not loaded, skipping weight chart update');
                    return;
                }

                // Update both charts
                this.updateShotsWithWeightChart();
                this.updateWeightOnlyChart();
            }

            updateShotsWithWeightChart() {
                const canvas = document.getElementById('shots-weight-chart');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // Destroy existing chart if it exists
                if (this.charts.shotsWeightChart) {
                    this.charts.shotsWeightChart.destroy();
                }

                // Filter data based on selected time range
                const now = new Date();
                let cutoffDate = null;
                if (this.timeRange !== 'all') {
                    cutoffDate = new Date(now.getTime() - this.timeRange * 24 * 60 * 60 * 1000);
                }

                const sortedWeights = [...this.data.weights]
                    .filter(w => this.timeRange === 'all' || new Date(w.timestamp) >= cutoffDate)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                const sortedInjections = [...this.data.injections]
                    .filter(i => this.timeRange === 'all' || new Date(i.timestamp) >= cutoffDate)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                // Filter to only show injections that have a matching weight (within 24 hours)
                const injectionsWithWeights = sortedInjections.filter(injection => {
                    const injDate = new Date(injection.timestamp);
                    return sortedWeights.some(weight => {
                        const weightDate = new Date(weight.timestamp);
                        const timeDiff = Math.abs(weightDate - injDate);
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        return hoursDiff <= 24;
                    });
                });

                // Filter weights to only show those that have a matching injection
                const weightsWithInjections = sortedWeights.filter(weight => {
                    const weightDate = new Date(weight.timestamp);
                    return injectionsWithWeights.some(injection => {
                        const injDate = new Date(injection.timestamp);
                        const timeDiff = Math.abs(weightDate - injDate);
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        return hoursDiff <= 24;
                    });
                });

                if (injectionsWithWeights.length === 0 || weightsWithInjections.length === 0) {
                    // Show empty state
                    const container = canvas.parentElement;
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"></div>
                            <h3>No shots with weight data yet</h3>
                            <p>Add weight entries on the same day as your shots to see them here</p>
                        </div>
                    `;
                    return;
                }

                // Ensure canvas exists for chart
                if (!canvas.parentElement.querySelector('canvas')) {
                    const container = canvas.parentElement;
                    container.innerHTML = '<canvas id="shots-weight-chart"></canvas>';
                }

                // Detect mobile screen for responsive chart configuration
                const isMobile = window.innerWidth <= 480;
                const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;

                // Dynamic font sizing based on screen size
                const fontSize = isMobile ? {
                    legend: 11,
                    tick: 10,
                    title: 11
                } : isTablet ? {
                    legend: 11,
                    tick: 10,
                    title: 12
                } : {
                    legend: 12,
                    tick: 11,
                    title: 12
                };

                // Build datasets - only show weights that have matching injections
                const colorPalette = ['#FF6B6B', '#FF9500', '#34C759', '#5AC8FA', '#007AFF', '#AF52DE'];
                const pointColors = weightsWithInjections.map((w, idx) => colorPalette[idx % colorPalette.length]);

                const datasets = [{
                    label: 'Weight (kg)',
                    data: weightsWithInjections.map(w => ({
                        x: w.timestamp,
                        y: w.weight_kg
                    })),
                    borderColor: '#AF52DE',
                    backgroundColor: 'transparent',
                    fill: false,
                    tension: 0.4,
                    yAxisID: 'y',
                    pointRadius: isMobile ? 6 : 5,
                    pointHoverRadius: isMobile ? 8 : 7,
                    pointHitRadius: isMobile ? 14 : 12,
                    pointBackgroundColor: pointColors,
                    pointBorderColor: pointColors,
                    pointBorderWidth: 2,
                    segment: {
                        borderColor: (ctx) => {
                            if (!ctx.p0DataIndex || ctx.p0DataIndex >= pointColors.length - 1) return colorPalette[0];
                            return pointColors[ctx.p0DataIndex];
                        }
                    }
                }];

                // Custom plugin to draw dose labels - only for injections with matching weights
                const doseLabelsPlugin = {
                    id: 'doseLabels',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const xScale = chart.scales.x;
                        const yScale = chart.scales.y;

                        if (!injectionsWithWeights.length) return;

                        // Calculate data density for adaptive label sizing
                        const chartWidth = xScale.right - xScale.left;
                        const avgSpacing = injectionsWithWeights.length > 1 ? chartWidth / injectionsWithWeights.length : chartWidth;

                        // Since we only show shots with weights (weekly), keep labels large and readable
                        // Use consistent sizing with minimal density-based reduction
                        let fontSize, padding, pillHeight, yOffset;
                        const labelFormat = 'full'; // Always show "mg" suffix

                        if (avgSpacing < 40) {
                            // Dense mode (many data points)
                            fontSize = isMobile ? 11 : 14;
                            padding = isMobile ? 5 : 8;
                            pillHeight = isMobile ? 18 : 22;
                            yOffset = isMobile ? 24 : 30;
                        } else {
                            // Normal mode (comfortable spacing)
                            fontSize = isMobile ? 12 : 15;
                            padding = isMobile ? 6 : 9;
                            pillHeight = isMobile ? 20 : 24;
                            yOffset = isMobile ? 28 : 36;
                        }

                        ctx.save();
                        ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';

                        // Draw a label for each injection that has a matching weight
                        injectionsWithWeights.forEach((injection, index) => {
                            const injDate = new Date(injection.timestamp);
                            const x = xScale.getPixelForValue(injDate);

                            // Find the matching weight to position the label above it
                            const matchingWeight = weightsWithInjections.find(weight => {
                                const weightDate = new Date(weight.timestamp);
                                const timeDiff = Math.abs(weightDate - injDate);
                                const hoursDiff = timeDiff / (1000 * 60 * 60);
                                return hoursDiff <= 24;
                            });

                            // Position above the matching weight point
                            const y = yScale.getPixelForValue(matchingWeight.weight_kg);

                            // Always show full label with "mg" suffix for clarity
                            const label = `${injection.dose_mg}mg`;

                            // No staggering needed since we only show shots with weights (naturally spaced)
                            const staggerOffset = 0;

                            // Draw background pill with colorful gradient
                            const textWidth = ctx.measureText(label).width;
                            const pillWidth = textWidth + padding * 2;
                            const pillX = x - pillWidth / 2;
                            const pillY = y - yOffset - staggerOffset;

                            // Cycle through color palette for variety
                            const color = colorPalette[index % colorPalette.length];
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.roundRect(pillX, pillY, pillWidth, pillHeight, pillHeight / 2);
                            ctx.fill();

                            // Draw text
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillText(label, x, pillY + pillHeight - 3);
                        });

                        ctx.restore();
                    }
                };

                // Pass plugin directly to chart instance instead of global registration
                this.charts.shotsWeightChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    plugins: [doseLabelsPlugin],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                top: 35,
                                left: 10,
                                right: 10,
                                bottom: 5
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff',
                                    font: {
                                        size: fontSize.legend
                                    },
                                    padding: isMobile ? 8 : 12,
                                    boxWidth: isMobile ? 30 : 40
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(42, 42, 42, 0.95)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#333333',
                                borderWidth: 1,
                                padding: isMobile ? 10 : 12,
                                titleFont: {
                                    size: isMobile ? 12 : 13
                                },
                                bodyFont: {
                                    size: isMobile ? 12 : 13
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'day',
                                    displayFormats: {
                                        day: isMobile ? 'M/d' : 'MMM d'
                                    }
                                },
                                // Add padding on both sides for visibility (2 days on each side)
                                min: weightsWithInjections.length > 0 ?
                                    new Date(new Date(weightsWithInjections[0].timestamp).getTime() - 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    undefined,
                                max: weightsWithInjections.length > 0 ?
                                    new Date(new Date(weightsWithInjections[weightsWithInjections.length - 1].timestamp).getTime() + 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    new Date().toISOString(),
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : isTablet ? 8 : 10,
                                    maxRotation: isMobile ? 45 : 0,
                                    minRotation: isMobile ? 45 : 0
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : 8,
                                    callback: function(value) {
                                        return value.toFixed(1);
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Weight (kg)',
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.title
                                    }
                                },
                                beginAtZero: false,
                                grace: '5%'
                            }
                        }
                    }
                });
            }

            updateWeightOnlyChart() {
                const canvas = document.getElementById('weight-only-chart');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // Destroy existing chart if it exists
                if (this.charts.weightOnlyChart) {
                    this.charts.weightOnlyChart.destroy();
                }

                // Filter data based on selected time range
                const now = new Date();
                let cutoffDate = null;
                if (this.timeRange !== 'all') {
                    cutoffDate = new Date(now.getTime() - this.timeRange * 24 * 60 * 60 * 1000);
                }

                const sortedWeights = [...this.data.weights]
                    .filter(w => this.timeRange === 'all' || new Date(w.timestamp) >= cutoffDate)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                if (sortedWeights.length === 0) {
                    // Show empty state
                    const container = canvas.parentElement;
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"></div>
                            <h3>No weight data yet</h3>
                            <p>Start tracking your progress by adding your first weight entry</p>
                            <button class="btn-primary" onclick="app.openModal('add-weight-modal')">Add Weight</button>
                        </div>
                    `;
                    return;
                }

                // Ensure canvas exists for chart
                if (!canvas.parentElement.querySelector('canvas')) {
                    const container = canvas.parentElement;
                    container.innerHTML = '<canvas id="weight-only-chart"></canvas>';
                }

                // Detect mobile screen for responsive chart configuration
                const isMobile = window.innerWidth <= 480;
                const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;

                // Dynamic font sizing based on screen size
                const fontSize = isMobile ? {
                    legend: 11,
                    tick: 10,
                    title: 11
                } : isTablet ? {
                    legend: 11,
                    tick: 10,
                    title: 12
                } : {
                    legend: 12,
                    tick: 11,
                    title: 12
                };

                // Build datasets - show all weights
                const colorPalette = ['#FF6B6B', '#FF9500', '#34C759', '#5AC8FA', '#007AFF', '#AF52DE'];
                const pointColors = sortedWeights.map((w, idx) => colorPalette[idx % colorPalette.length]);

                const datasets = [{
                    label: 'Weight (kg)',
                    data: sortedWeights.map(w => ({
                        x: w.timestamp,
                        y: w.weight_kg
                    })),
                    borderColor: '#AF52DE',
                    backgroundColor: 'transparent',
                    fill: false,
                    tension: 0.4,
                    yAxisID: 'y',
                    pointRadius: isMobile ? 6 : 5,
                    pointHoverRadius: isMobile ? 8 : 7,
                    pointHitRadius: isMobile ? 14 : 12,
                    pointBackgroundColor: pointColors,
                    pointBorderColor: pointColors,
                    pointBorderWidth: 2,
                    segment: {
                        borderColor: (ctx) => {
                            if (!ctx.p0DataIndex || ctx.p0DataIndex >= pointColors.length - 1) return colorPalette[0];
                            return pointColors[ctx.p0DataIndex];
                        }
                    }
                }];

                // Create chart without dose labels plugin
                this.charts.weightOnlyChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                top: 15,
                                left: 10,
                                right: 10,
                                bottom: 5
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff',
                                    font: {
                                        size: fontSize.legend
                                    },
                                    padding: isMobile ? 8 : 12,
                                    boxWidth: isMobile ? 30 : 40
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(42, 42, 42, 0.95)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#333333',
                                borderWidth: 1,
                                padding: isMobile ? 10 : 12,
                                titleFont: {
                                    size: isMobile ? 12 : 13
                                },
                                bodyFont: {
                                    size: isMobile ? 12 : 13
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'day',
                                    displayFormats: {
                                        day: isMobile ? 'M/d' : 'MMM d'
                                    }
                                },
                                // Add padding on both sides for visibility (2 days on each side)
                                min: sortedWeights.length > 0 ?
                                    new Date(new Date(sortedWeights[0].timestamp).getTime() - 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    undefined,
                                max: sortedWeights.length > 0 ?
                                    new Date(new Date(sortedWeights[sortedWeights.length - 1].timestamp).getTime() + 2 * 24 * 60 * 60 * 1000).toISOString() :
                                    new Date().toISOString(),
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : isTablet ? 8 : 10,
                                    maxRotation: isMobile ? 45 : 0,
                                    minRotation: isMobile ? 45 : 0
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                grid: {
                                    color: '#333333'
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.tick
                                    },
                                    maxTicksLimit: isMobile ? 6 : 8,
                                    callback: function(value) {
                                        return value.toFixed(1);
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Weight (kg)',
                                    color: '#cccccc',
                                    font: {
                                        size: fontSize.title
                                    }
                                },
                                beginAtZero: false,
                                grace: '5%'
                            }
                        }
                    }
                });
            }

            // Helper function: Convert kg to lb
            kgToLbs(kg) {
                return kg * 2.20462;
            }

            // Helper function: Convert lb to kg
            lbsToKg(lbs) {
                return lbs / 2.20462;
            }

            // Helper function: Get date range for display
            getDateRangeText(weights) {
                if (!weights || weights.length === 0) return '';

                const sorted = [...weights].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const start = new Date(sorted[0].timestamp);
                const end = new Date(sorted[sorted.length - 1].timestamp);

                const formatOptions = { month: 'short', day: 'numeric', year: 'numeric' };
                return `${start.toLocaleDateString('en-US', formatOptions)} - ${end.toLocaleDateString('en-US', formatOptions)}`;
            }

            // Phase 2: Extract weight statistics calculation with validation
            calculateWeightStats(timeRangeDays = null) {
                // Validate input data
                const weights = this.data.weights || [];
                if (weights.length === 0) {
                    return {
                        success: false,
                        error: 'No weight data available',
                        metrics: this.getDefaultWeightMetrics()
                    };
                }

                // Filter by time range if specified
                let filteredWeights = weights;
                if (timeRangeDays && timeRangeDays !== 'all') {
                    const cutoffDate = new Date(Date.now() - timeRangeDays * 24 * 60 * 60 * 1000);
                    filteredWeights = weights.filter(w => new Date(w.timestamp) >= cutoffDate);
                }

                // Phase 2: Validate minimum data requirement
                if (filteredWeights.length < 2) {
                    return {
                        success: false,
                        error: 'Need at least 2 weight entries to calculate statistics',
                        metrics: this.getDefaultWeightMetrics(),
                        dataCount: filteredWeights.length
                    };
                }

                // Sort and validate weight entries
                let validCount = 0;
                let invalidCount = 0;
                const validWeights = [];

                filteredWeights.forEach(w => {
                    // Phase 2: Validate each weight entry
                    if (!w.timestamp || !w.weight_kg) {
                        console.warn('[WeightStats] Invalid weight entry:', w.id, 'missing timestamp or weight_kg');
                        invalidCount++;
                        return;
                    }

                    const timestamp = new Date(w.timestamp).getTime();
                    if (isNaN(timestamp)) {
                        console.warn('[WeightStats] Invalid timestamp for weight:', w.id);
                        invalidCount++;
                        return;
                    }

                    const weightKg = parseFloat(w.weight_kg);
                    if (isNaN(weightKg) || weightKg < 20 || weightKg > 300) {
                        console.warn('[WeightStats] Invalid weight value:', w.id, weightKg);
                        invalidCount++;
                        return;
                    }

                    validWeights.push({ ...w, weight_kg: weightKg, timestamp: new Date(w.timestamp) });
                    validCount++;
                });

                // Check if we still have enough valid data
                if (validWeights.length < 2) {
                    return {
                        success: false,
                        error: `Only ${validWeights.length} valid weight entries (need at least 2)`,
                        metrics: this.getDefaultWeightMetrics(),
                        validCount,
                        invalidCount
                    };
                }

                // Sort by timestamp
                const sortedWeights = validWeights.sort((a, b) => a.timestamp - b.timestamp);
                const firstWeight = sortedWeights[0];
                const lastWeight = sortedWeights[sortedWeights.length - 1];

                // Calculate metrics
                const weightChangeKg = lastWeight.weight_kg - firstWeight.weight_kg;
                const currentWeightKg = lastWeight.weight_kg;
                const startWeightKg = firstWeight.weight_kg;

                // Calculate percent change
                const percentChange = (weightChangeKg / startWeightKg) * 100;

                // Calculate weekly average
                const daysDiff = (lastWeight.timestamp - firstWeight.timestamp) / (1000 * 60 * 60 * 24);
                const weeks = daysDiff / 7;
                const weeklyAvgKg = weeks > 0 ? (weightChangeKg / weeks) : 0;

                // Calculate goal progress
                let goalProgress = null;
                if (this.data.settings.goalWeightKg) {
                    const goalWeightKg = this.data.settings.goalWeightKg;
                    const totalToLose = startWeightKg - goalWeightKg;
                    const lostSoFar = startWeightKg - currentWeightKg;
                    goalProgress = totalToLose > 0 ? (lostSoFar / totalToLose) * 100 : 0;
                }

                return {
                    success: true,
                    metrics: {
                        weightChangeKg,
                        currentWeightKg,
                        startWeightKg,
                        percentChange,
                        weeklyAvgKg,
                        goalProgress,
                        daysDiff,
                        weeks
                    },
                    validCount,
                    invalidCount,
                    totalCount: filteredWeights.length,
                    warning: invalidCount > 0 ? `${invalidCount} weight entries skipped due to invalid data` : null
                };
            }

            // Phase 2: Helper method for default metrics
            getDefaultWeightMetrics() {
                return {
                    weightChangeKg: 0,
                    currentWeightKg: 0,
                    startWeightKg: 0,
                    percentChange: 0,
                    weeklyAvgKg: 0,
                    goalProgress: null,
                    daysDiff: 0,
                    weeks: 0
                };
            }

            updateWeightStats() {
                // Get weights for current time range
                const timeRangeDays = this.timeRange === 'all' ? 'all' : this.timeRange;

                // Update date range display
                const cutoffDate = timeRangeDays === 'all' ? new Date(0) :
                    new Date(Date.now() - timeRangeDays * 24 * 60 * 60 * 1000);
                const filteredWeights = this.data.weights.filter(w =>
                    timeRangeDays === 'all' || new Date(w.timestamp) >= cutoffDate
                );

                const dateRangeEl = document.getElementById('date-range-display');
                if (dateRangeEl) {
                    dateRangeEl.textContent = this.getDateRangeText(filteredWeights);
                }

                // Phase 2: Use validated calculation
                const statsResult = this.calculateWeightStats(timeRangeDays);

                if (!statsResult.success) {
                    console.warn('[WeightStats] Calculation failed:', statsResult.error);
                    // Set defaults if not enough data
                    document.getElementById('total-change').textContent = '0 kg';
                    document.getElementById('current-weight').textContent = '0 kg';
                    document.getElementById('current-bmi').textContent = '--';
                    document.getElementById('percent-change').textContent = '0%';
                    document.getElementById('weekly-avg').textContent = '0 kg/wk';
                    document.getElementById('goal-progress').textContent = '--';

                    // Phase 3: Add validation indicators for error state
                    const errorIndicator = `
                        <span class="validation-indicator validation-error validation-tooltip">
                            <span class="validation-icon"></span>
                            <span class="tooltip-content">${statsResult.error}</span>
                        </span>
                    `;
                    document.getElementById('total-change-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('current-weight-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('percent-change-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('weekly-avg-validation-indicator').innerHTML = errorIndicator;
                    document.getElementById('goal-progress-validation-indicator').innerHTML = errorIndicator;
                    return;
                }

                const { weightChangeKg, currentWeightKg, percentChange, weeklyAvgKg, goalProgress } = statsResult.metrics;

                // Phase 3: Determine validation status
                const hasWarning = statsResult.warning;
                const validationHTML = hasWarning
                    ? `<span class="validation-indicator validation-warning validation-tooltip">
                           <span class="validation-icon"></span>
                           <span class="tooltip-content">${statsResult.warning}</span>
                       </span>`
                    : `<span class="validation-indicator validation-success">
                           <span class="validation-icon"></span>
                       </span>`;

                // 1. Total change (in kg)
                const totalChangeText = weightChangeKg >= 0 ?
                    `+${Math.abs(weightChangeKg).toFixed(1)} kg` :
                    `${weightChangeKg.toFixed(1)} kg`;
                document.getElementById('total-change').textContent = totalChangeText;
                document.getElementById('total-change-validation-indicator').innerHTML = validationHTML;

                // 2. Current weight (in kg)
                document.getElementById('current-weight').textContent = `${currentWeightKg.toFixed(1)} kg`;
                document.getElementById('current-weight-validation-indicator').innerHTML = validationHTML;

                // 3. Current BMI
                this.updateBMI();

                // 4. Percent change
                const percentText = percentChange >= 0 ?
                    `+${percentChange.toFixed(0)}%` :
                    `${percentChange.toFixed(0)}%`;
                document.getElementById('percent-change').textContent = percentText;
                document.getElementById('percent-change-validation-indicator').innerHTML = validationHTML;

                // 5. Weekly average (kg/wk)
                const weeklyText = weeklyAvgKg >= 0 ?
                    `+${weeklyAvgKg.toFixed(1)} kg/wk` :
                    `${weeklyAvgKg.toFixed(1)} kg/wk`;
                document.getElementById('weekly-avg').textContent = weeklyText;
                document.getElementById('weekly-avg-validation-indicator').innerHTML = validationHTML;

                // 6. Goal progress (%)
                if (goalProgress !== null) {
                    document.getElementById('goal-progress').textContent =
                        `${Math.max(0, Math.min(100, goalProgress)).toFixed(0)}%`;
                    document.getElementById('goal-progress-validation-indicator').innerHTML = validationHTML;
                } else {
                    document.getElementById('goal-progress').textContent = '--';
                    document.getElementById('goal-progress-validation-indicator').innerHTML = '';
                }

                // Color coding for total change
                const totalChangeEl = document.getElementById('total-change');
                if (weightChangeKg < 0) {
                    totalChangeEl.style.color = '#34C759'; // Green for weight loss
                } else if (weightChangeKg > 0) {
                    totalChangeEl.style.color = '#FF9500'; // Orange for weight gain
                } else {
                    totalChangeEl.style.color = 'var(--text-primary)';
                }

                // Color coding for percent change
                const percentEl = document.getElementById('percent-change');
                if (percentChange < 0) {
                    percentEl.style.color = '#34C759';
                } else if (percentChange > 0) {
                    percentEl.style.color = '#FF9500';
                } else {
                    percentEl.style.color = 'var(--text-primary)';
                }

                // Color coding for weekly average
                const weeklyEl = document.getElementById('weekly-avg');
                if (weeklyAvgKg < 0) {
                    weeklyEl.style.color = '#34C759';
                } else if (weeklyAvgKg > 0) {
                    weeklyEl.style.color = '#FF9500';
                } else {
                    weeklyEl.style.color = 'var(--text-primary)';
                }
            }

            // Phase 2: Extract BMI calculation with validation
            calculateBMI() {
                // Validate input data
                const weights = this.data.weights || [];
                if (weights.length === 0) {
                    return {
                        success: false,
                        error: 'No weight data available',
                        value: 0
                    };
                }

                const heightCm = this.data.settings?.heightCm;
                if (!heightCm) {
                    return {
                        success: false,
                        error: 'Height not set in settings',
                        value: 0
                    };
                }

                // Phase 2: Validate height is reasonable (100-250cm)
                const height = parseFloat(heightCm);
                if (isNaN(height) || height < 100 || height > 250) {
                    return {
                        success: false,
                        error: `Invalid height: ${heightCm}cm (must be 100-250cm)`,
                        value: 0
                    };
                }

                // Get last weight
                const sortedWeights = [...weights].sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                );
                const lastWeight = sortedWeights[sortedWeights.length - 1];

                // Phase 2: Validate weight is reasonable (20-300kg)
                const weightKg = parseFloat(lastWeight.weight_kg);
                if (isNaN(weightKg) || weightKg < 20 || weightKg > 300) {
                    return {
                        success: false,
                        error: `Invalid weight: ${lastWeight.weight_kg}kg (must be 20-300kg)`,
                        value: 0
                    };
                }

                // Calculate BMI
                const heightM = height / 100;
                const bmi = weightKg / (heightM * heightM);

                // Phase 2: Validate BMI is reasonable (10-60)
                if (bmi < 10 || bmi > 60) {
                    return {
                        success: false,
                        error: `Calculated BMI ${bmi.toFixed(1)} is out of reasonable range (10-60)`,
                        value: bmi,
                        warning: 'BMI calculation may be incorrect - check height and weight settings'
                    };
                }

                return {
                    success: true,
                    value: bmi,
                    weightKg,
                    heightCm: height,
                    category: bmi < 18.5 ? 'underweight' :
                             bmi < 25 ? 'normal' :
                             bmi < 30 ? 'overweight' : 'obese'
                };
            }

            updateBMI() {
                const bmiElement = document.getElementById('current-bmi');
                const validationIndicator = document.getElementById('bmi-validation-indicator');

                // Phase 2: Use validated calculation
                const bmiResult = this.calculateBMI();

                if (!bmiResult.success) {
                    console.warn('[BMI] Calculation failed:', bmiResult.error);
                    bmiElement.textContent = '--';
                    bmiElement.style.color = 'var(--text-primary)';

                    // Phase 3: Add validation indicator
                    validationIndicator.innerHTML = `
                        <span class="validation-indicator validation-error validation-tooltip">
                            <span class="validation-icon"></span>
                            <span class="tooltip-content">${bmiResult.error}</span>
                        </span>
                    `;
                    return;
                }

                const bmi = bmiResult.value;
                bmiElement.textContent = bmi.toFixed(1);

                // Color code BMI
                if (bmi < 18.5) {
                    bmiElement.style.color = '#007AFF'; // Blue - underweight
                } else if (bmi < 25) {
                    bmiElement.style.color = '#34C759'; // Green - normal
                } else if (bmi < 30) {
                    bmiElement.style.color = '#FF9500'; // Orange - overweight
                } else {
                    bmiElement.style.color = '#FF3B30'; // Red - obese
                }

                // Phase 3: Add validation indicator for warnings
                if (bmiResult.warning) {
                    validationIndicator.innerHTML = `
                        <span class="validation-indicator validation-warning validation-tooltip">
                            <span class="validation-icon"></span>
                            <span class="tooltip-content">${bmiResult.warning}</span>
                        </span>
                    `;
                } else {
                    validationIndicator.innerHTML = `
                        <span class="validation-indicator validation-success">
                            <span class="validation-icon"></span>
                        </span>
                    `;
                }
            }

            updateGoalProgress() {
                const goalCard = document.getElementById('goal-progress-card');

                // Hide card if no goal weight or insufficient weight data
                if (!this.data.settings.goalWeightKg || this.data.weights.length < 2) {
                    goalCard.style.display = 'none';
                    return;
                }

                const sortedWeights = [...this.data.weights].sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                );

                const startWeight = sortedWeights[0].weight_kg;
                const currentWeight = sortedWeights[sortedWeights.length - 1].weight_kg;
                const goalWeight = this.data.settings.goalWeightKg;

                // Check if goal is already reached
                if (currentWeight <= goalWeight) {
                    goalCard.style.display = 'block';
                    document.getElementById('goal-start-weight').textContent = startWeight.toFixed(1);
                    document.getElementById('goal-target-weight').textContent = goalWeight.toFixed(1);
                    document.getElementById('goal-progress-percent').textContent = '100';
                    document.getElementById('goal-progress-bar').style.width = '100%';
                    document.getElementById('goal-remaining').textContent = '0 kg';
                    document.getElementById('goal-weekly-rate').textContent = '--';
                    document.getElementById('goal-eta-date').textContent = 'Achieved!';
                    document.getElementById('goal-message').textContent = ' Congratulations! You\'ve reached your goal!';
                    document.getElementById('goal-message').style.background = 'rgba(52, 199, 89, 0.2)';
                    return;
                }

                // Calculate progress
                const totalToLose = startWeight - goalWeight;
                const alreadyLost = startWeight - currentWeight;
                const remaining = currentWeight - goalWeight;
                const progressPercent = Math.max(0, Math.min(100, (alreadyLost / totalToLose) * 100));

                // Calculate weekly rate (last 4 weeks)
                const fourWeeksAgo = new Date();
                fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);
                const recentWeights = sortedWeights.filter(w =>
                    new Date(w.timestamp) >= fourWeeksAgo
                );

                let weeklyRate = 0;
                let etaText = '--';

                if (recentWeights.length >= 2) {
                    const oldestRecent = recentWeights[0];
                    const newestRecent = recentWeights[recentWeights.length - 1];
                    const daysDiff = (new Date(newestRecent.timestamp) - new Date(oldestRecent.timestamp)) / (1000 * 60 * 60 * 24);
                    const weightDiff = oldestRecent.weight_kg - newestRecent.weight_kg;

                    if (daysDiff > 0) {
                        weeklyRate = (weightDiff / daysDiff) * 7;

                        // Calculate ETA
                        if (weeklyRate > 0) {
                            const weeksToGoal = remaining / weeklyRate;
                            const etaDate = new Date();
                            etaDate.setDate(etaDate.getDate() + (weeksToGoal * 7));

                            // Format date based on how far away it is
                            if (weeksToGoal < 8) {
                                etaText = `${Math.ceil(weeksToGoal)} weeks`;
                            } else {
                                etaText = etaDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                            }
                        } else {
                            etaText = '--';
                        }
                    }
                }

                // Update UI
                goalCard.style.display = 'block';
                document.getElementById('goal-start-weight').textContent = startWeight.toFixed(1);
                document.getElementById('goal-target-weight').textContent = goalWeight.toFixed(1);
                document.getElementById('goal-progress-percent').textContent = progressPercent.toFixed(0);
                document.getElementById('goal-progress-bar').style.width = progressPercent + '%';
                document.getElementById('goal-remaining').textContent = remaining.toFixed(1) + ' kg';
                document.getElementById('goal-weekly-rate').textContent = weeklyRate > 0 ?
                    '-' + weeklyRate.toFixed(2) + ' kg' : '--';
                document.getElementById('goal-eta-date').textContent = etaText;

                // Update message based on progress
                const messageEl = document.getElementById('goal-message');
                if (progressPercent >= 75) {
                    messageEl.textContent = ' Almost there! You\'re in the home stretch!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.15)';
                } else if (progressPercent >= 50) {
                    messageEl.textContent = ' Great progress! You\'re halfway to your goal!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.1)';
                } else if (progressPercent >= 25) {
                    messageEl.textContent = ' Keep going! You\'re making steady progress!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.1)';
                } else if (weeklyRate > 0) {
                    messageEl.textContent = ' You\'re on track! Stay consistent!';
                    messageEl.style.background = 'rgba(52, 199, 89, 0.1)';
                } else {
                    messageEl.textContent = ' Keep tracking to see your progress!';
                    messageEl.style.background = 'rgba(128, 128, 128, 0.1)';
                    messageEl.style.color = 'var(--text-secondary)';
                }
            }

            showSettingSaveIndicator(inputElement) {
                if (!inputElement) return;
                const wrapper = inputElement.closest('.setting-input-wrapper');
                if (!wrapper) return;

                const indicator = wrapper.querySelector('.save-indicator');
                if (!indicator) return;

                // Show checkmark
                indicator.classList.add('show');
                indicator.style.color = '#34C759';

                // Hide after 2 seconds
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            }

            showSettingsSavedNotification() {
                // Debounce: Clear existing timeout
                if (this.settingsSaveTimeout) {
                    clearTimeout(this.settingsSaveTimeout);
                }

                // Set new timeout to show notification after 1 second
                this.settingsSaveTimeout = setTimeout(() => {
                    if (window.deleteManager && window.deleteManager.notificationManager) {
                        window.deleteManager.notificationManager.show('Settings saved successfully', 'success');
                    }
                }, 1000);
            }

            updateWeightsList() {
                const weightsList = document.getElementById('weights-list');
                weightsList.innerHTML = '';

                if (this.data.weights.length === 0) {
                    weightsList.innerHTML = '<p style="text-align: center; color: var(--text-muted); padding: 24px;">No weight entries yet</p>';
                    return;
                }

                // Filter out invalid weights first
                const validWeights = this.data.weights.filter(w => w && w.weight_kg && w.timestamp);

                const sortedWeights = [...validWeights].sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                sortedWeights.forEach(weight => {
                    const weightItem = this.createWeightListItem(weight);
                    if (weightItem && weightItem.hasChildNodes()) {
                        weightsList.appendChild(weightItem);
                    }
                });
            }

            createWeightListItem(weight) {
                // Safety check for invalid weight data
                if (!weight || !weight.weight_kg) {
                    console.warn('Invalid weight data:', weight);
                    return document.createElement('div');
                }

                const div = document.createElement('div');
                div.className = 'weight-item';
                div.setAttribute('data-item-id', weight.id || weight.timestamp);
                div.setAttribute('data-timestamp', weight.timestamp);
                div.innerHTML = `
                    <div class="weight-content">
                        <div class="shot-header">
                            <div class="shot-dose">${weight.weight_kg.toFixed(1)} kg</div>
                            <div class="shot-date">${this.formatDate(weight.timestamp)}</div>
                        </div>
                        ${weight.body_fat_percentage ? `
                        <div class="shot-details">
                            <div>Body Fat: ${weight.body_fat_percentage}%</div>
                        </div>
                        ` : ''}
                    </div>
                    <button class="delete-btn" aria-label="Delete weight entry" title="Delete this weight entry">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"/>
                            <path d="M10 11v6M14 11v6"/>
                        </svg>
                    </button>
                `;
                return div;
            }

            updateInventoryStats() {
                const activeVials = this.data.vials.filter(v =>
                    v.status === 'active' &&
                    v.remaining_ml > 0 &&
                    new Date(v.expiration_date) > new Date()
                );

                const dryStockVials = this.data.vials.filter(v =>
                    v.status === 'dry_stock' &&
                    new Date(v.expiration_date) > new Date()
                );

                const expiredVials = this.data.vials.filter(v =>
                    new Date(v.expiration_date) < new Date()
                );

                const defaultDose = this.data.settings.defaultDose || 2.0;
                let totalDoses = 0;
                let totalMgUsed = 0;

                // Count doses from active vials
                activeVials.forEach(vial => {
                    const dosesInVial = (vial.remaining_ml * vial.concentration_mg_ml) / defaultDose;
                    totalDoses += dosesInVial;
                });

                // Count doses from dry stock vials (full vials)
                dryStockVials.forEach(vial => {
                    const dosesInVial = vial.total_mg / defaultDose;
                    totalDoses += dosesInVial;
                });

                this.data.vials.forEach(vial => {
                    totalMgUsed += vial.doses_used * defaultDose;
                });

                // Calculate days remaining based on dose day
                const daysRemaining = this.calculateDaysRemaining(totalDoses);


                // Update basic stats
                document.getElementById('total-stock').textContent = totalDoses.toFixed(1);
                document.getElementById('days-remaining').textContent = daysRemaining;
                // Cost fields removed - no longer tracking costs

                // Update colors based on stock levels
                const stockElement = document.getElementById('total-stock');
                const daysElement = document.getElementById('days-remaining');

                if (totalDoses < 5 || daysRemaining < 14) {
                    stockElement.style.color = '#FF3B30'; // Red for low stock
                    daysElement.style.color = '#FF3B30';
                } else if (totalDoses < 10 || daysRemaining < 30) {
                    stockElement.style.color = '#FF9500'; // Orange for medium stock
                    daysElement.style.color = '#FF9500';
                } else {
                    stockElement.style.color = '#34C759'; // Green for good stock
                    daysElement.style.color = '#34C759';
                }

                // Update analytics
                this.updateInventoryAnalytics(totalDoses, daysRemaining, expiredVials);
            }

            updateInventoryAnalytics(totalDoses, daysRemaining, expiredVials) {
                // Reorder Alert
                let reorderAlert = "Stock levels look good";
                let reorderColor = '#34C759';

                if (totalDoses < 5 || daysRemaining < 14) {
                    reorderAlert = " Critical - Order immediately!";
                    reorderColor = '#FF3B30';
                } else if (totalDoses < 8 || daysRemaining < 21) {
                    reorderAlert = " Low stock - Order soon";
                    reorderColor = '#FF9500';
                } else if (totalDoses < 12 || daysRemaining < 30) {
                    reorderAlert = " Consider ordering";
                    reorderColor = '#FF9500';
                }

                const reorderElement = document.getElementById('reorder-alert');
                if (reorderElement) {
                    reorderElement.textContent = reorderAlert;
                    reorderElement.style.color = reorderColor;
                }

                // Usage Rate - calculated from default dose and injection frequency
                const defaultDose = this.data.settings.defaultDose || 2.0;
                const injectionFrequency = this.data.settings.injectionFrequency || 7;
                const dosesPerWeek = 7 / injectionFrequency;
                const mgPerWeek = defaultDose * dosesPerWeek;
                const usageRate = `${mgPerWeek.toFixed(1)} mg/week`;
                const usageRateElement = document.getElementById('usage-rate');
                if (usageRateElement) {
                    usageRateElement.textContent = usageRate;
                }

                // Waste Tracking
                let wasteText = "No expired vials";
                let wasteColor = '#34C759';

                if (expiredVials.length > 0) {
                    const expiredMg = expiredVials.reduce((sum, vial) => {
                        return sum + (vial.remaining_ml * vial.concentration_mg_ml);
                    }, 0);
                    wasteText = `${expiredVials.length} expired (${expiredMg.toFixed(0)}mg lost)`;
                    wasteColor = '#FF3B30';
                }

                const wasteElement = document.getElementById('waste-tracking');
                if (wasteElement) {
                    wasteElement.textContent = wasteText;
                    wasteElement.style.color = wasteColor;
                }

                // Next Order Suggestion
                let nextOrderText = "Order in 30+ days";
                let nextOrderColor = '#34C759';

                if (daysRemaining <= 14) {
                    nextOrderText = "Order now!";
                    nextOrderColor = '#FF3B30';
                } else if (daysRemaining <= 30) {
                    nextOrderText = `Order in ${Math.max(0, daysRemaining - 14)} days`;
                    nextOrderColor = '#FF9500';
                } else {
                    const orderInDays = Math.max(daysRemaining - 21, 1);
                    nextOrderText = `Order in ${orderInDays} days`;
                }

                const nextOrderElement = document.getElementById('next-order');
                if (nextOrderElement) {
                    nextOrderElement.textContent = nextOrderText;
                    nextOrderElement.style.color = nextOrderColor;
                }
            }

            // ====================================
            // COUNTDOWN FUNCTIONALITY
            // ====================================

            startCountdownTimer() {
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                }

                this.countdownInterval = setInterval(() => {
                    this.updateCountdown();
                }, 1000);
            }

            updateCountdown() {
                if (this.data.injections.length === 0) {
                    document.getElementById('next-shot-day').textContent = 'No shots recorded';
                    document.getElementById('next-shot-date').textContent = '';
                    document.getElementById('next-shot-time').textContent = '';
                    this.updateCountdownProgress(0);
                    return;
                }

                const now = new Date();
                const lastInjection = this.getMostRecentInjection();
                const lastShot = new Date(lastInjection.timestamp);

                // Calculate next shot based on injection frequency
                const nextShot = new Date(lastShot);
                nextShot.setDate(nextShot.getDate() + this.data.settings.injectionFrequency);

                // Format the date display
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

                const dayName = dayNames[nextShot.getDay()];
                const monthName = monthNames[nextShot.getMonth()];
                const date = nextShot.getDate();

                // Format time
                let hours = nextShot.getHours();
                const minutes = nextShot.getMinutes();
                const ampm = hours >= 12 ? 'PM' : 'AM';
                hours = hours % 12;
                hours = hours ? hours : 12; // 0 should be 12
                const timeString = `${hours}:${minutes.toString().padStart(2, '0')} ${ampm}`;

                document.getElementById('next-shot-day').textContent = dayName;
                document.getElementById('next-shot-date').textContent = `${monthName} ${date}`;
                document.getElementById('next-shot-time').textContent = timeString;

                // Calculate progress and update colors
                const timeDiff = nextShot.getTime() - now.getTime();
                const totalTime = this.data.settings.injectionFrequency * 24 * 60 * 60 * 1000;
                const elapsedTime = now.getTime() - lastShot.getTime();
                const progress = Math.min(100, (elapsedTime / totalTime) * 100);

                this.updateCountdownProgress(progress);

                // Update colors based on timing
                const dayElement = document.getElementById('next-shot-day');
                const dateElement = document.getElementById('next-shot-date');

                if (timeDiff <= 0) {
                    // Shot is overdue
                    dayElement.style.color = '#FF3B30';
                    dateElement.style.color = '#FF3B30';
                    dayElement.textContent = 'OVERDUE';
                    dateElement.textContent = '';
                } else if (timeDiff <= 24 * 60 * 60 * 1000) {
                    // Due within 24 hours
                    dayElement.style.color = '#FF9500';
                    dateElement.style.color = '#FF9500';
                } else {
                    // Normal timing
                    dayElement.style.color = 'var(--accent-color)';
                    dateElement.style.color = 'var(--text-primary)';
                }
            }

            updateCountdownProgress(percentage) {
                const circle = document.getElementById('countdown-circle');
                const circumference = 2 * Math.PI * 90; // radius = 90
                const offset = circumference - (percentage / 100) * circumference;
                circle.style.strokeDashoffset = offset;
            }

            // ====================================
            // GOOGLE DRIVE INTEGRATION
            // ====================================

            async initGoogleDrive() {
                // Google API client ID (you'll need to replace this with your own)
                this.CLIENT_ID = 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com';
                this.API_KEY = 'YOUR_GOOGLE_API_KEY';
                this.DISCOVERY_DOCS = ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'];
                this.SCOPES = 'https://www.googleapis.com/auth/drive.appdata';

                this.loadGoogleAPI();
            }

            loadGoogleAPI() {
                const script = document.createElement('script');
                script.src = 'https://apis.google.com/js/api.js';
                script.onload = () => this.handleGoogleAPILoad();
                document.body.appendChild(script);
            }

            handleGoogleAPILoad() {
                gapi.load('client:auth2', () => {
                    gapi.client.init({
                        apiKey: this.API_KEY,
                        clientId: this.CLIENT_ID,
                        discoveryDocs: this.DISCOVERY_DOCS,
                        scope: this.SCOPES
                    }).then(() => {
                        // Listen for sign-in state changes
                        gapi.auth2.getAuthInstance().isSignedIn.listen((isSignedIn) => {
                            this.handleGoogleSignInStatus(isSignedIn);
                        });

                        // Handle initial sign-in state
                        this.handleGoogleSignInStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
                    });
                });
            }

            handleGoogleSignInStatus(isSignedIn) {
                const connectBtn = document.getElementById('google-drive-btn');
                if (isSignedIn) {
                    connectBtn.textContent = 'Disconnect Google Drive';
                    connectBtn.classList.add('connected');
                    this.data.settings.googleDriveConnected = true;
                    this.syncToGoogleDrive();
                } else {
                    connectBtn.textContent = 'Connect Google Drive';
                    connectBtn.classList.remove('connected');
                    this.data.settings.googleDriveConnected = false;
                }
                this.saveData();
            }

            async syncToGoogleDrive() {
                if (!this.data.settings.googleDriveConnected) {
                    console.log('Google Drive not connected');
                    return;
                }

                try {
                    const boundary = '-------314159265358979323846';
                    const delimiter = "\r\n--" + boundary + "\r\n";
                    const close_delim = "\r\n--" + boundary + "--";

                    const metadata = {
                        'name': 'injection_data.json',
                        'mimeType': 'application/json',
                        'parents': ['appDataFolder']
                    };

                    const multipartRequestBody =
                        delimiter +
                        'Content-Type: application/json\r\n\r\n' +
                        JSON.stringify(metadata) +
                        delimiter +
                        'Content-Type: application/json\r\n\r\n' +
                        JSON.stringify(this.data) +
                        close_delim;

                    // Check if file exists
                    const response = await gapi.client.drive.files.list({
                        'spaces': 'appDataFolder',
                        'fields': 'files(id, name)',
                        'pageSize': 10
                    });

                    const files = response.result.files;
                    let fileId = null;

                    if (files && files.length > 0) {
                        fileId = files[0].id;
                    }

                    if (fileId) {
                        // Update existing file
                        await gapi.client.request({
                            'path': `/upload/drive/v3/files/${fileId}`,
                            'method': 'PATCH',
                            'params': {'uploadType': 'multipart'},
                            'headers': {
                                'Content-Type': 'multipart/related; boundary="' + boundary + '"'
                            },
                            'body': multipartRequestBody
                        });
                        console.log('Data synced to Google Drive');
                    } else {
                        // Create new file
                        await gapi.client.request({
                            'path': '/upload/drive/v3/files',
                            'method': 'POST',
                            'params': {'uploadType': 'multipart'},
                            'headers': {
                                'Content-Type': 'multipart/related; boundary="' + boundary + '"'
                            },
                            'body': multipartRequestBody
                        });
                        console.log('Data uploaded to Google Drive');
                    }

                    this.data.settings.lastSync = new Date().toISOString();
                    this.updateSyncStatus();
                } catch (error) {
                    console.error('Error syncing to Google Drive:', error);
                }
            }

            async loadFromGoogleDrive() {
                if (!this.data.settings.googleDriveConnected) return;

                try {
                    const response = await gapi.client.drive.files.list({
                        'spaces': 'appDataFolder',
                        'fields': 'files(id, name)',
                        'pageSize': 10
                    });

                    const files = response.result.files;
                    if (files && files.length > 0) {
                        const file = await gapi.client.drive.files.get({
                            'fileId': files[0].id,
                            'alt': 'media'
                        });

                        const cloudData = JSON.parse(file.body);

                        // Merge cloud data with local data (prefer newer)
                        if (cloudData.settings && cloudData.settings.lastSync) {
                            const cloudTime = new Date(cloudData.settings.lastSync);
                            const localTime = this.data.settings.lastSync ? new Date(this.data.settings.lastSync) : new Date(0);

                            if (cloudTime > localTime) {
                                this.data = cloudData;
                                await this.saveData();
                                this.updateUI();
                                console.log('Loaded data from Google Drive');
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error loading from Google Drive:', error);
                }
            }

            updateSyncStatus() {
                if (this.data.settings.lastSync) {
                    const lastSync = new Date(this.data.settings.lastSync);
                    const syncStatus = document.createElement('div');
                    syncStatus.className = 'sync-status';
                    syncStatus.textContent = `Last synced: ${lastSync.toLocaleString()}`;

                    const settingsContainer = document.querySelector('#settings-tab .container');
                    const existingStatus = settingsContainer.querySelector('.sync-status');
                    if (existingStatus) {
                        existingStatus.textContent = syncStatus.textContent;
                    } else {
                        settingsContainer.appendChild(syncStatus);
                    }
                }
            }

            // ====================================
            // WITHINGS HEALTH API INTEGRATION
            // ====================================

            connectWithings() {
                // Withings OAuth 2.0 configuration
                // Replace with your actual Withings Client ID from developer.withings.com
                const WITHINGS_CLIENT_ID = 'YOUR_WITHINGS_CLIENT_ID';

                // Check if client ID has been configured
                if (WITHINGS_CLIENT_ID === 'YOUR_WITHINGS_CLIENT_ID') {
                    alert('Withings integration not configured. Please update WITHINGS_CLIENT_ID with your actual client ID from developer.withings.com');
                    return;
                }
                const WITHINGS_REDIRECT_URI = window.location.origin + '/withings-callback';
                const WITHINGS_AUTH_URL = 'https://account.withings.com/oauth2_user/authorize2';

                // Generate state for security
                const state = Math.random().toString(36).substring(2, 15);
                sessionStorage.setItem('withings_state', state);

                // Build authorization URL
                const params = new URLSearchParams({
                    response_type: 'code',
                    client_id: WITHINGS_CLIENT_ID,
                    scope: 'user.metrics',
                    redirect_uri: WITHINGS_REDIRECT_URI,
                    state: state
                });

                const authUrl = `${WITHINGS_AUTH_URL}?${params.toString()}`;

                // For demo purposes, show configuration instructions
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-header">
                        <h3 class="modal-title">Connect Withings Health</h3>
                        <button class="modal-close" onclick="this.parentElement.parentElement.remove(); document.getElementById('modal-overlay').style.display='none';">&times;</button>
                    </div>
                    <div class="modal-content">
                        <p>To enable Withings integration:</p>
                        <ol>
                            <li>Register your app at <a href="https://developer.withings.com" target="_blank">developer.withings.com</a></li>
                            <li>Get your Client ID and Secret</li>
                            <li>Update the WITHINGS_CLIENT_ID in this app</li>
                            <li>Configure OAuth redirect URL</li>
                        </ol>
                        <p>Once configured, this will allow automatic import of:</p>
                        <ul>
                            <li>Weight measurements</li>
                            <li>Body fat percentage</li>
                            <li>BMI calculations</li>
                            <li>Historical data</li>
                        </ul>
                        <button class="btn-primary" onclick="window.open('${authUrl}', '_blank')">Proceed to Withings</button>
                    </div>
                `;

                document.getElementById('modal-overlay').style.display = 'flex';
                document.getElementById('modal-overlay').appendChild(modal);
            }

            async handleWithingsCallback(code) {
                // This would handle the OAuth callback
                // Exchange code for access token
                // Store token securely
                // Fetch user data
                console.log('Withings callback handling for code:', code);

                // For production, implement token exchange and data fetching
                this.data.settings.withingsConnected = true;
                await this.saveData();
                this.fetchWithingsData();
            }

            async fetchWithingsData() {
                if (!this.data.settings.withingsConnected) return;

                try {
                    // In production, this would use the Withings API
                    // For now, simulate the API response structure
                    const mockWithingsData = {
                        body: {
                            measuregrps: [
                                {
                                    date: Math.floor(Date.now() / 1000),
                                    measures: [
                                        {
                                            value: 82500, // 82.5 kg
                                            type: 1, // Weight
                                            unit: -3 // kg
                                        },
                                        {
                                            value: 185, // 18.5%
                                            type: 6, // Fat percentage
                                            unit: -1
                                        }
                                    ]
                                }
                            ]
                        }
                    };

                    // Process Withings data
                    mockWithingsData.body.measuregrps.forEach(group => {
                        const timestamp = new Date(group.date * 1000).toISOString();
                        let weight_kg = null;
                        let body_fat_percentage = null;

                        group.measures.forEach(measure => {
                            if (measure.type === 1) { // Weight
                                weight_kg = measure.value * Math.pow(10, measure.unit);
                            } else if (measure.type === 6) { // Fat percentage
                                body_fat_percentage = measure.value * Math.pow(10, measure.unit);
                            }
                        });

                        if (weight_kg) {
                            // Check if we already have this weight entry
                            const existingEntry = this.data.weights.find(w =>
                                Math.abs(new Date(w.timestamp) - new Date(timestamp)) < 60000 // Within 1 minute
                            );

                            if (!existingEntry) {
                                this.addWeight({
                                    timestamp: timestamp,
                                    weight_kg: weight_kg,
                                    body_fat_percentage: body_fat_percentage,
                                    source: 'withings'
                                });
                            }
                        }
                    });

                    console.log('Withings data fetched and processed');
                } catch (error) {
                    console.error('Error fetching Withings data:', error);
                }
            }

            // ====================================
            // PWA FUNCTIONALITY
            // ====================================

            registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('/sw.js')
                        .then(registration => {
                            console.log('Service Worker registered successfully:', registration.scope);

                            // Force update check on every page load to bust cache
                            registration.update().then(() => {
                                console.log('Service Worker update check completed');
                            });

                            // Listen for new service worker
                            registration.addEventListener('updatefound', () => {
                                const newWorker = registration.installing;
                                console.log('New Service Worker found, installing...');

                                newWorker.addEventListener('statechange', () => {
                                    if (newWorker.state === 'activated') {
                                        console.log('New Service Worker activated - reloading page');
                                        // Reload page to use new service worker
                                        window.location.reload();
                                    }
                                });
                            });
                        })
                        .catch(error => {
                            console.log('Service Worker registration failed:', error);
                        });
                }
            }

            // Confetti animations
            triggerConfetti(type = 'default') {
                if (typeof confetti === 'undefined') return;

                switch (type) {
                    case 'milestone':
                        // Milestone achievement - big celebration
                        confetti({
                            particleCount: 100,
                            spread: 70,
                            origin: { y: 0.6 },
                            colors: ['#007AFF', '#34C759', '#FF9500']
                        });
                        break;

                    case 'goal':
                        // Weight loss goal - shower from top
                        const duration = 3 * 1000;
                        const animationEnd = Date.now() + duration;
                        const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 10000 };

                        function randomInRange(min, max) {
                            return Math.random() * (max - min) + min;
                        }

                        const interval = setInterval(function() {
                            const timeLeft = animationEnd - Date.now();

                            if (timeLeft <= 0) {
                                return clearInterval(interval);
                            }

                            const particleCount = 50 * (timeLeft / duration);
                            confetti(Object.assign({}, defaults, {
                                particleCount,
                                origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
                            }));
                            confetti(Object.assign({}, defaults, {
                                particleCount,
                                origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
                            }));
                        }, 250);
                        break;

                    case 'ontrack':
                        // Adheren ce milestone - small celebration
                        confetti({
                            particleCount: 50,
                            angle: 60,
                            spread: 55,
                            origin: { x: 0 },
                            colors: ['#34C759', '#00C853']
                        });
                        confetti({
                            particleCount: 50,
                            angle: 120,
                            spread: 55,
                            origin: { x: 1 },
                            colors: ['#34C759', '#00C853']
                        });
                        break;

                    default:
                        // Default celebration
                        confetti({
                            particleCount: 30,
                            spread: 60,
                            origin: { y: 0.7 }
                        });
                }
            }

            // Check for milestones and trigger celebrations
            checkMilestones() {
                const totalInjections = this.data.injections.length;
                const weights = this.data.weights;

                // Injection milestones
                if ([10, 25, 50, 100].includes(totalInjections)) {
                    this.triggerConfetti('milestone');
                    this.showEnhancedNotification({
                        title: ` ${totalInjections} Injections Milestone!`,
                        body: `You've completed ${totalInjections} injections. Great progress!`,
                        tag: 'milestone-' + totalInjections,
                        requireInteraction: true
                    });
                }

                // Weight loss milestones (if we have enough data)
                if (weights.length >= 2) {
                    const sorted = [...weights].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    const firstWeight = sorted[0].weight_kg;
                    const currentWeight = sorted[sorted.length - 1].weight_kg;
                    const loss = firstWeight - currentWeight;

                    // 5kg, 10kg, 15kg, 20kg milestones
                    const milestones = [5, 10, 15, 20, 25, 30];
                    milestones.forEach(target => {
                        if (loss >= target && !localStorage.getItem(`milestone-${target}kg`)) {
                            localStorage.setItem(`milestone-${target}kg`, 'true');
                            this.triggerConfetti('goal');
                            this.showEnhancedNotification({
                                title: ` ${target}kg Weight Loss!`,
                                body: `Amazing progress! You've lost ${loss.toFixed(1)}kg total!`,
                                tag: 'weightloss-' + target,
                                requireInteraction: true,
                                actions: [
                                    { action: 'view', title: ' View Progress' }
                                ]
                            });
                        }
                    });
                }

                // Perfect adherence week
                const now = new Date();
                const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                const weekInjections = this.data.injections.filter(i => new Date(i.timestamp) >= oneWeekAgo);
                const expectedInjections = Math.floor(7 / this.data.settings.injectionFrequency);

                if (weekInjections.length >= expectedInjections && expectedInjections > 0) {
                    const weekKey = `week-${now.getFullYear()}-${now.getMonth()}-${Math.floor(now.getDate() / 7)}`;
                    if (!localStorage.getItem(`adherence-${weekKey}`)) {
                        localStorage.setItem(`adherence-${weekKey}`, 'true');
                        this.triggerConfetti('ontrack');
                    }
                }
            }

            // ====================================
            // DATA INTEGRITY VALIDATION
            // ====================================

            validateDataIntegrity() {
                const issues = [];

                // Check vial integrity
                this.data.vials.forEach(vial => {
                    // Check if vial has been used more than its capacity
                    if (vial.status === 'active' && vial.concentration_mg_ml > 0) {
                        const totalUsedMg = vial.doses_used * (vial.total_mg / (vial.bac_water_ml * vial.concentration_mg_ml));
                        const calculatedRemainingMg = vial.total_mg - totalUsedMg;
                        const reportedRemainingMg = vial.remaining_ml * vial.concentration_mg_ml;

                        if (Math.abs(calculatedRemainingMg - reportedRemainingMg) > 0.1) {
                            issues.push(`Vial ${vial.vial_id}: Calculated remaining (${calculatedRemainingMg.toFixed(1)}mg) doesn't match reported (${reportedRemainingMg.toFixed(1)}mg)`);
                        }
                    }

                    // Check for impossible remaining volumes
                    if (vial.remaining_ml < 0) {
                        issues.push(`Vial ${vial.vial_id}: Negative remaining volume (${vial.remaining_ml}ml)`);
                    }

                    // Check for vials marked as empty but still have volume
                    if (vial.status === 'empty' && vial.remaining_ml > 0) {
                        issues.push(`Vial ${vial.vial_id}: Marked as empty but has ${vial.remaining_ml}ml remaining`);
                    }

                    // Check for expired active vials
                    if (vial.status === 'active' && new Date(vial.expiration_date) < new Date()) {
                        issues.push(`Vial ${vial.vial_id}: Marked as active but expired on ${new Date(vial.expiration_date).toLocaleDateString()}`);
                    }
                });

                // Check injection integrity
                this.data.injections.forEach(injection => {
                    // Only validate vial reference if injection has a vial_id (null is valid)
                    if (injection.vial_id && injection.vial_id !== 'null') {
                        const vial = this.findVialById(injection.vial_id); // Phase 2: Use helper method
                        if (!vial) {
                            issues.push(`Injection ${injection.id}: References non-existent vial ${injection.vial_id}`);
                        }
                    }
                });

                if (issues.length > 0) {
                    console.warn('Data integrity issues found:', issues);
                    return issues;
                } else {
                    console.log('Data integrity check passed ');
                    return [];
                }
            }
        }

        // ====================================
        // NOTIFICATION SYSTEM
        // ====================================

        class SimpleNotificationManager {
            constructor() {
                this.container = null;
            }

            initialize() {
                this.container = document.getElementById('notification-container');
            }

            show(type, message) {
                if (!this.container) this.initialize();

                const notification = document.createElement('div');
                notification.className = `notification ${type}`;

                const icons = {
                    'success': '',
                    'error': '',
                    'warning': '',
                    'info': ''
                };

                const titles = {
                    'success': 'Success',
                    'error': 'Error',
                    'warning': 'Warning',
                    'info': 'Info'
                };

                notification.innerHTML = `
                    <div class="notification-icon">${icons[type] || ''}</div>
                    <div class="notification-content">
                        <div class="notification-title">${titles[type] || 'Notification'}</div>
                        <div class="notification-message">${message}</div>
                    </div>
                    <button class="notification-close" aria-label="Close"></button>
                `;

                this.container.appendChild(notification);

                const closeBtn = notification.querySelector('.notification-close');
                closeBtn.onclick = () => this.hide(notification);

                setTimeout(() => this.hide(notification), 3000);
            }

            hide(notification) {
                notification.classList.add('hiding');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }

            success(message) { this.show('success', message); }
            error(message) { this.show('error', message); }
            warning(message) { this.show('warning', message); }
            info(message) { this.show('info', message); }
        }

        // ====================================
        // DELETE MANAGER
        // ====================================

        class SimpleDeleteManager {
            constructor() {
                this.undoStack = [];
                this.maxUndoStack = 20;
                this.notificationManager = new SimpleNotificationManager();
                this.undoButton = null;
            }

            initialize() {
                this.notificationManager.initialize();
                this.undoButton = document.getElementById('undo-button');

                if (this.undoButton) {
                    this.undoButton.onclick = () => this.undoLastDelete();
                }
            }

            enableDeleteForShots() {
                const setupDeleteButtons = () => {
                    const shotItems = document.querySelectorAll('.shot-item');
                    shotItems.forEach(item => {
                        const deleteBtn = item.querySelector('.delete-btn');
                        if (deleteBtn && !deleteBtn.dataset.initialized) {
                            deleteBtn.dataset.initialized = 'true';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteShot(item, itemId, timestamp);
                            };
                        }

                        // Also add handler to the delete action button that appears after swipe
                        const deleteAction = item.querySelector('.delete-action');
                        if (deleteAction && !deleteAction.dataset.initialized) {
                            deleteAction.dataset.initialized = 'true';
                            deleteAction.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteShot(item, itemId, timestamp);
                            };
                        }
                    });
                };

                // Run immediately and after any UI update
                setupDeleteButtons();
                const observer = new MutationObserver(() => setupDeleteButtons());
                observer.observe(document.getElementById('shots-list'), {
                    childList: true,
                    subtree: true
                });
            }

            enableDeleteForVials() {
                const setupDeleteButtons = () => {
                    const vialItems = document.querySelectorAll('.vial-item');
                    vialItems.forEach(item => {
                        const deleteBtn = item.querySelector('.delete-btn');
                        if (deleteBtn && !deleteBtn.dataset.initialized) {
                            deleteBtn.dataset.initialized = 'true';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteVial(item, itemId, timestamp);
                            };
                        }

                        // Add handler for edit button
                        const editBtn = item.querySelector('.edit-btn');
                        if (editBtn && !editBtn.dataset.initialized) {
                            editBtn.dataset.initialized = 'true';
                            editBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                app.openEditVialModal(itemId);
                            };
                        }

                        // Also add handler to the delete action button that appears after swipe
                        const deleteAction = item.querySelector('.delete-action');
                        if (deleteAction && !deleteAction.dataset.initialized) {
                            deleteAction.dataset.initialized = 'true';
                            deleteAction.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteVial(item, itemId, timestamp);
                            };
                        }
                    });
                };

                setupDeleteButtons();
                const observer = new MutationObserver(() => setupDeleteButtons());
                observer.observe(document.getElementById('vials-list'), {
                    childList: true,
                    subtree: true
                });
            }

            enableDeleteForWeights() {
                const setupDeleteButtons = () => {
                    const weightItems = document.querySelectorAll('.weight-item');
                    weightItems.forEach(item => {
                        const deleteBtn = item.querySelector('.delete-btn');
                        if (deleteBtn && !deleteBtn.dataset.initialized) {
                            deleteBtn.dataset.initialized = 'true';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteWeight(item, itemId, timestamp);
                            };
                        }

                        // Also add handler to the delete action button that appears after swipe
                        const deleteAction = item.querySelector('.delete-action');
                        if (deleteAction && !deleteAction.dataset.initialized) {
                            deleteAction.dataset.initialized = 'true';
                            deleteAction.onclick = (e) => {
                                e.stopPropagation();
                                const itemId = item.getAttribute('data-item-id');
                                const timestamp = item.getAttribute('data-timestamp');
                                this.handleDeleteWeight(item, itemId, timestamp);
                            };
                        }
                    });
                };

                setupDeleteButtons();
                const observer = new MutationObserver(() => setupDeleteButtons());
                observer.observe(document.getElementById('weights-list'), {
                    childList: true,
                    subtree: true
                });
            }

            async handleDeleteShot(element, shotId, timestamp) {
                if (!confirm('Delete this injection?')) {
                    return;
                }

                // Find and delete the injection
                const index = app.data.injections.findIndex(inj => inj.id === shotId);
                if (index === -1) {
                    this.notificationManager.error('Injection not found');
                    return;
                }

                const deletedInjection = app.data.injections[index];

                // Mark as pending deletion to prevent sync from re-adding
                app._pendingDeletions.add(shotId);
                console.log(`Added ${shotId} to pending deletions`);

                // Add to undo stack
                this.undoStack.push({
                    type: 'injection',
                    data: deletedInjection,
                    index: index,
                    timestamp: Date.now()
                });

                if (this.undoStack.length > this.maxUndoStack) {
                    this.undoStack.shift();
                }

                // Reverse vial usage if injection had a vial
                if (deletedInjection.vial_id && deletedInjection.dose_mg) {
                    await app.reverseVialUsage(deletedInjection.vial_id, deletedInjection.dose_mg);
                }

                // Remove from app data
                app.data.injections.splice(index, 1);

                // Save and update UI
                app.saveData();
                app.updateUI();

                // Push deletion to sync queue (Phase 1B: Reliable sync with retry)
                // Note: Pending deletion will auto-expire after 2 minutes
                if (authManager && authManager.isAuthenticated() && app.syncQueue) {
                    app.syncQueue.add({
                        type: 'delete',
                        entity: 'injection',
                        localId: shotId,
                        data: { id: shotId }
                    });
                    console.log('Injection deletion added to sync queue');
                }
                // If offline, deletion will be queued and synced when back online

                // Animate out
                element.style.opacity = '0';
                element.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (element.parentNode) {
                        element.remove();
                    }
                }, 300);

                this.notificationManager.success('Injection deleted');
                this.showUndoButton();
            }

            async handleDeleteVial(element, vialId, timestamp) {
                // Check if vial has been used for any injections
                const hasInjections = app.data.injections.some(inj => inj.vial_id === vialId);

                if (hasInjections) {
                    if (!confirm('This vial has been used for injections. Delete anyway? (Injections will remain)')) {
                        return;
                    }
                }

                if (!hasInjections && !confirm('Delete this vial?')) {
                    return;
                }

                const index = app.data.vials.findIndex(v => app.getVialId(v) === vialId);
                if (index === -1) {
                    this.notificationManager.error('Vial not found');
                    return;
                }

                const deletedVial = app.data.vials[index];

                // Mark as pending deletion to prevent sync from re-adding
                app._pendingDeletions.add(vialId);
                console.log(`Added ${vialId} to pending deletions`);

                // Add to undo stack
                this.undoStack.push({
                    type: 'vial',
                    data: deletedVial,
                    index: index,
                    timestamp: Date.now()
                });

                if (this.undoStack.length > this.maxUndoStack) {
                    this.undoStack.shift();
                }

                // Remove from app data
                app.data.vials.splice(index, 1);

                // Save and update UI
                app.saveData();
                app.updateUI();

                // Sync deletion to cloud
                // Note: Pending deletion will auto-expire after 2 minutes (set in add() call above)
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        await apiClient.deleteVial(vialId);
                        console.log('Vial deleted from cloud successfully');
                        // Pending deletion will auto-expire, no manual cleanup needed
                    } catch (error) {
                        console.error('Failed to delete vial from cloud:', error);
                        // Pending deletion will auto-expire, allowing retry on next sync
                    }
                }
                // If offline, pending deletion persists until sync succeeds or expires

                // Animate out
                element.style.opacity = '0';
                element.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (element.parentNode) {
                        element.remove();
                    }
                }, 300);

                this.notificationManager.success('Vial deleted');
                this.showUndoButton();
            }

            async handleDeleteWeight(element, weightId, timestamp) {
                if (!confirm('Delete this weight entry?')) {
                    return;
                }

                // Try to find by ID first, fallback to timestamp for backwards compatibility
                let index = app.data.weights.findIndex(w => w.id === weightId);
                if (index === -1) {
                    index = app.data.weights.findIndex(w => w.timestamp === timestamp);
                }

                if (index === -1) {
                    this.notificationManager.error('Weight entry not found');
                    return;
                }

                const deletedWeight = app.data.weights[index];
                const actualWeightId = deletedWeight.id || weightId;

                // Mark as pending deletion to prevent sync from re-adding
                app._pendingDeletions.add(actualWeightId);
                console.log(`Added ${actualWeightId} to pending deletions`);

                // Add to undo stack
                this.undoStack.push({
                    type: 'weight',
                    data: deletedWeight,
                    index: index,
                    timestamp: Date.now()
                });

                if (this.undoStack.length > this.maxUndoStack) {
                    this.undoStack.shift();
                }

                // Remove from app data
                app.data.weights.splice(index, 1);

                // Save and update UI
                app.saveData();
                app.updateUI();

                // Push deletion to sync queue (Phase 1B: Reliable sync with retry)
                // Note: Pending deletion will auto-expire after 2 minutes
                if (authManager && authManager.isAuthenticated() && actualWeightId && app.syncQueue) {
                    app.syncQueue.add({
                        type: 'delete',
                        entity: 'weight',
                        localId: actualWeightId,
                        data: { id: actualWeightId }
                    });
                    console.log('Weight deletion added to sync queue');
                }
                // If offline, deletion will be queued and synced when back online

                // Animate out
                element.style.opacity = '0';
                element.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (element.parentNode) {
                        element.remove();
                    }
                }, 300);

                this.notificationManager.success('Weight entry deleted');
                this.showUndoButton();
            }

            showUndoButton() {
                if (this.undoButton) {
                    this.undoButton.classList.add('show');
                    setTimeout(() => {
                        this.undoButton.classList.remove('show');
                    }, 5000);
                }
            }

            async undoLastDelete() {
                if (this.undoStack.length === 0) {
                    this.notificationManager.warning('Nothing to undo');
                    return;
                }

                const operation = this.undoStack.pop();

                // Remove from pending deletions if present
                const itemId = operation.type === 'vial' ? operation.data.vial_id :
                               operation.type === 'injection' ? operation.data.id :
                               operation.data.timestamp;
                if (app._pendingDeletions.has(itemId)) {
                    app._pendingDeletions.delete(itemId);
                    console.log(`Removed ${itemId} from pending deletions (undo)`);
                }

                // Restore locally
                switch (operation.type) {
                    case 'injection':
                        app.data.injections.splice(operation.index, 0, operation.data);
                        break;
                    case 'vial':
                        app.data.vials.splice(operation.index, 0, operation.data);
                        break;
                    case 'weight':
                        app.data.weights.splice(operation.index, 0, operation.data);
                        break;
                }

                app.saveData();
                app.updateUI();

                // Sync restoration to cloud
                if (authManager && authManager.isAuthenticated()) {
                    try {
                        switch (operation.type) {
                            case 'injection':
                                await apiClient.createInjection({
                                    id: operation.data.id,
                                    timestamp: operation.data.timestamp,
                                    doseMg: operation.data.dose_mg,
                                    site: operation.data.injection_site,
                                    vialId: operation.data.vial_id,
                                    notes: operation.data.notes || ''
                                });
                                console.log('Undone injection synced to cloud');
                                break;
                            case 'vial':
                                await apiClient.createVial({
                                    id: operation.data.vial_id,
                                    startDate: operation.data.order_date,
                                    initialVolumeMl: operation.data.bac_water_ml,
                                    concentrationMgPerMl: operation.data.concentration_mg_per_ml,
                                    currentVolumeMl: operation.data.current_volume_ml,
                                    usedVolumeMl: operation.data.used_volume_ml,
                                    status: operation.data.status,
                                    source: operation.data.supplier || '',
                                    notes: operation.data.notes || ''
                                });
                                console.log('Undone vial synced to cloud');
                                break;
                            case 'weight':
                                await apiClient.createWeight({
                                    timestamp: operation.data.timestamp,
                                    weightKg: operation.data.weight_kg,
                                    source: operation.data.source || 'manual',
                                    notes: operation.data.notes || ''
                                });
                                console.log('Undone weight synced to cloud');
                                break;
                        }
                    } catch (error) {
                        console.error('Failed to sync undo to cloud:', error);
                        this.notificationManager.warning('Restored locally but cloud sync failed');
                    }
                }

                const typeNames = {
                    'injection': 'Injection',
                    'vial': 'Vial',
                    'weight': 'Weight entry'
                };
                this.notificationManager.success(`${typeNames[operation.type]} restored`);

                if (this.undoButton) {
                    this.undoButton.classList.remove('show');
                }
            }
        }

        // ====================================
        // RESILIENT BACKUP SYSTEM
        // ====================================

        class ResilientBackupManager {
            constructor() {
                this.storageKey = 'injectionTrackerData';
                this.dbName = 'RetatrutideDB';
                this.dbVersion = 1;
                this.storeName = 'appData';
                this.db = null;
            }

            async initialize() {
                // Initialize IndexedDB
                await this.initIndexedDB();

                console.log('Resilient backup system initialized');
            }

            initIndexedDB() {
                return new Promise((resolve) => {
                    if (!window.indexedDB) {
                        console.warn('IndexedDB not available');
                        resolve(null);
                        return;
                    }

                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = () => {
                        console.error('IndexedDB open failed');
                        resolve(null);
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        console.log('IndexedDB initialized');
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const objectStore = db.createObjectStore(this.storeName, { keyPath: 'key' });
                            objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            }

            async saveData(data) {
                // Save to localStorage
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(data));
                } catch (error) {
                    console.error('Failed to save to localStorage:', error);
                }

                // Save to IndexedDB as fallback
                if (this.db) {
                    await this.saveToIndexedDB(data);
                }

                return true;
            }

            async saveToIndexedDB(data) {
                if (!this.db) return false;

                return new Promise((resolve) => {
                    try {
                        const transaction = this.db.transaction([this.storeName], 'readwrite');
                        const objectStore = transaction.objectStore(this.storeName);

                        const record = {
                            key: this.storageKey,
                            data: data,
                            timestamp: Date.now(),
                            date: new Date().toISOString()
                        };

                        const request = objectStore.put(record);
                        request.onsuccess = () => resolve(true);
                        request.onerror = () => resolve(false);
                    } catch (error) {
                        console.error('IndexedDB save error:', error);
                        resolve(false);
                    }
                });
            }

            async loadData() {
                // Try localStorage first
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) {
                        return JSON.parse(stored);
                    }
                } catch (error) {
                    console.error('Failed to load from localStorage:', error);
                }

                // Try IndexedDB as fallback
                if (this.db) {
                    return await this.loadFromIndexedDB();
                }

                return null;
            }

            async loadFromIndexedDB() {
                if (!this.db) return null;

                return new Promise((resolve) => {
                    try {
                        const transaction = this.db.transaction([this.storeName], 'readonly');
                        const objectStore = transaction.objectStore(this.storeName);
                        const request = objectStore.get(this.storageKey);

                        request.onsuccess = () => {
                            if (request.result) {
                                resolve(request.result.data);
                            } else {
                                resolve(null);
                            }
                        };

                        request.onerror = () => resolve(null);
                    } catch (error) {
                        console.error('IndexedDB load error:', error);
                        resolve(null);
                    }
                });
            }

        }

        // ====================================
        // INITIALIZE APPLICATION
        // ====================================

        let app;
        let deleteManager;
        let backupManager;

        document.addEventListener('DOMContentLoaded', async function() {
            console.log('[INIT] DOMContentLoaded event fired');

            // CRITICAL: Set up auth button IMMEDIATELY for mobile compatibility
            const authGateButtonEarly = document.getElementById('auth-gate-button');
            if (authGateButtonEarly) {
                console.log('[INIT] Setting up early auth button handler for mobile');

                const handleSignIn = async (event) => {
                    event.preventDefault();
                    console.log('[AUTH-EARLY] Sign in button activated');
                    authGateButtonEarly.textContent = 'Redirecting...';
                    authGateButtonEarly.disabled = true;
                    try {
                        if (typeof authManager !== 'undefined') {
                            await authManager.signInWithGoogle();
                        } else {
                            alert('Authentication system not ready. Please refresh the page.');
                            authGateButtonEarly.textContent = 'Sign In with Google';
                            authGateButtonEarly.disabled = false;
                        }
                    } catch (error) {
                        console.error('[AUTH-EARLY] Error:', error);
                        authGateButtonEarly.textContent = 'Sign In with Google';
                        authGateButtonEarly.disabled = false;
                        alert(error.message || 'Sign in failed. Please try again.');
                    }
                };

                // Add both click and touchend for maximum mobile compatibility
                authGateButtonEarly.addEventListener('click', handleSignIn, { passive: false });
                authGateButtonEarly.addEventListener('touchend', handleSignIn, { passive: false, once: false });
                console.log('[INIT] Auth button handlers attached (click + touchend)');
            } else {
                console.error('[INIT] Auth gate button not found at initialization!');
            }

            // CRITICAL: Check test mode FIRST before any async operations (localhost only!)
            const urlParams = new URLSearchParams(window.location.search);
            const isTestMode = urlParams.get('test') === 'true';
            const isLocalhost = window.location.hostname === 'localhost' ||
                                window.location.hostname === '127.0.0.1';

            if (isTestMode && isLocalhost) {
                console.log('[INIT] Test mode detected on localhost - setting SKIP_AUTH_INIT flag');
                window.SKIP_AUTH_INIT = true;

                // Immediately hide auth gate and show app content
                const authGate = document.getElementById('auth-gate');
                const appContent = document.getElementById('app-content');
                const appHeader = document.getElementById('app-header');
                const bottomNav = document.getElementById('bottom-nav');

                if (authGate) authGate.style.display = 'none';
                if (appContent) appContent.style.display = 'block';
                if (appHeader) appHeader.style.display = 'block';
                if (bottomNav) bottomNav.style.display = 'flex';

                console.log('[INIT] Test mode UI elements configured');
            } else if (isTestMode && !isLocalhost) {
                console.warn('[INIT] Test mode parameter detected on production - IGNORING for security');
            }

            console.log('[INIT] Creating InjectionTracker instance');
            app = new InjectionTracker();
            window.app = app; // Expose globally for tests
            console.log('[INIT] window.app set, registering service worker');
            app.registerServiceWorker();

            // Initialize backup system
            console.log('[INIT] Initializing backup manager');
            backupManager = new ResilientBackupManager();
            await backupManager.initialize();
            console.log('[INIT] Backup manager initialized');

            // Initialize delete functionality
            deleteManager = new SimpleDeleteManager();
            deleteManager.initialize();
            deleteManager.enableDeleteForShots();
            deleteManager.enableDeleteForVials();
            deleteManager.enableDeleteForWeights();

            // Initialize cloud integration
            apiClient.initialize(authManager);
            // Legacy cloud storage disabled - using direct API sync instead
            // await cloudStorage.initialize(authManager, apiClient, app.storage);
            migrationWizard.initialize(authManager, apiClient);

            // Set up auth state change listener (after all initializations)
            setupAuthStateListener();

            // Handle URL parameters for PWA shortcuts (reuse urlParams from above)
            if (urlParams.get('action') === 'add_shot') {
                setTimeout(() => app.openModal('add-shot-modal'), 500);
            } else if (urlParams.get('tab')) {
                const tab = urlParams.get('tab');
                setTimeout(() => {
                    document.querySelector(`[data-tab="${tab}"]`)?.click();
                }, 500);
            }
        });

        // Update UI based on auth state
        function updateAuthUI(user) {
            const authButton = document.getElementById('auth-button');
            const userInfo = document.getElementById('user-info');

            if (user) {
                // User is signed in
                if (authButton) {
                    authButton.textContent = 'Logout';
                    authButton.onclick = () => authManager.signOut();
                }
                if (userInfo) {
                    userInfo.textContent = `Signed in as ${user.displayName || user.email}`;
                    userInfo.style.display = 'block';
                }
            } else {
                // User is signed out
                if (authButton) {
                    authButton.textContent = 'Sign In with Google';
                    authButton.onclick = async () => {
                        authButton.textContent = 'Redirecting...';
                        authButton.disabled = true;
                        try {
                            await authManager.signInWithGoogle();
                            // Page will redirect, so no need to reset button state
                        } catch (error) {
                            console.error('Sign in error:', error);
                            authButton.textContent = 'Sign In with Google';
                            authButton.disabled = false;
                            alert(error.message || 'Failed to sign in. Please try again.');
                        }
                    };
                }
                if (userInfo) {
                    userInfo.style.display = 'none';
                }
            }
        }

        // Auth state listener setup function
        function setupAuthStateListener() {
            console.log('[INIT] Setting up auth state listener');

            const authGate = document.getElementById('auth-gate');
            const authGateButton = document.getElementById('auth-gate-button');
            const appContent = document.getElementById('app-content');
            let lastAuthUserId = null;  // Track last known user to prevent duplicate syncs

            // Test mode bypass: skip authentication ONLY if on localhost with test param
            const urlParams = new URLSearchParams(window.location.search);
            const isTestMode = urlParams.get('test') === 'true';
            const isLocalhost = window.location.hostname === 'localhost' ||
                                window.location.hostname === '127.0.0.1';

            if (isTestMode && isLocalhost && window.SKIP_AUTH_INIT) {
                console.log('[INIT] Test mode active on localhost - skipping auth setup');
                // Disable cloud backup button in test mode
                const cloudBackupBtn = document.getElementById('create-cloud-backup-btn');
                if (cloudBackupBtn) {
                    cloudBackupBtn.disabled = true;
                }
                // Hide sync queue modal in test mode (prevents UI interference)
                const syncQueueModal = document.getElementById('sync-queue-modal');
                if (syncQueueModal) {
                    syncQueueModal.style.display = 'none';
                }
                return; // Skip auth setup entirely in test mode
            } else if (isTestMode && !isLocalhost) {
                console.warn('[INIT] Test mode parameter detected on production - IGNORING for security');
            }

            // Auth button handler is now set up early in DOMContentLoaded for mobile compatibility
            // No need to set it up again here - just verify it exists
            if (authGateButton) {
                console.log('[AUTH-SETUP] Auth gate button found (handler already attached during init)');
            } else {
                console.error('[AUTH-SETUP] Auth gate button not found!');
            }

            // Show/hide content based on auth state
            authManager.onAuthStateChange((user) => {
            if (user) {
                // Check if this is a new auth state (not just a token refresh)
                const isNewAuth = lastAuthUserId !== user.uid;
                lastAuthUserId = user.uid;

                // User signed in - show app, hide gate
                if (authGate) authGate.style.display = 'none';
                if (appContent) appContent.style.display = 'block';

                // Show header and navigation
                const appHeader = document.getElementById('app-header');
                const bottomNav = document.getElementById('bottom-nav');
                if (appHeader) appHeader.style.display = 'block';
                if (bottomNav) bottomNav.style.display = 'flex';

                updateAuthUI(user);

                // Phase 1B: Initialize sync queue (only once)
                if (!app.syncQueue && window.SyncQueue) {
                    app.syncQueue = new window.SyncQueue(apiClient);
                    console.log('[Phase1B] Sync queue initialized');
                }

                // Enable cloud backup button
                const cloudBackupBtn = document.getElementById('create-cloud-backup-btn');
                if (cloudBackupBtn) {
                    cloudBackupBtn.disabled = false;
                }

                // Only run these on actual sign-in, not on token refresh
                if (isNewAuth && app) {
                    console.log('New auth detected, syncing data...');

                    // Update cloud backup status
                    app.updateCloudBackupStatus();

                    // Check if auto-backup is needed
                    app.checkAutoBackup();

                    // Sync data from cloud (protected by guard)
                    app.syncFromCloud();

                    // Trigger migration wizard
                    setTimeout(() => {
                        migrationWizard.autoStart();
                    }, 1000);
                }
            } else {
                // User signed out - reset tracking and show gate
                lastAuthUserId = null;
                if (authGate) authGate.style.display = 'flex';
                if (appContent) appContent.style.display = 'none';

                // Hide header and navigation
                const appHeader = document.getElementById('app-header');
                const bottomNav = document.getElementById('bottom-nav');
                if (appHeader) appHeader.style.display = 'none';
                if (bottomNav) bottomNav.style.display = 'none';

                // Reset auth gate button to initial state
                if (authGateButton) {
                    authGateButton.textContent = 'Sign In with Google';
                    authGateButton.disabled = false;
                }

                // Disable cloud backup button
                const cloudBackupBtn = document.getElementById('create-cloud-backup-btn');
                if (cloudBackupBtn) {
                    cloudBackupBtn.disabled = true;
                }

                // Update cloud backup status
                if (app) {
                    app.updateCloudBackupStatus();
                }
            }
            });
        }
    </script>
    </div> <!-- Close app-content -->
</body>
</html>